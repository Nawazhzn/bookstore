{"ast":null,"code":"\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(`composition is only allowed when selector is single :local class name not in \"${root}\"`);\n    }\n    node = node.nodes[0];\n    if (node.type !== \"pseudo\" || node.value !== \":local\" || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n    node = node.first;\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n    node = node.first;\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n    return node.value;\n  });\n}\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\");\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace ? escaped : high < 0 ?\n    // BMP codepoint\n    String.fromCharCode(high + 0x10000) :\n    // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n  });\n}\nconst plugin = (options = {}) => {\n  const generateScopedName = options && options.generateScopedName || plugin.generateScopedName;\n  const generateExportEntry = options && options.generateExportEntry || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, {\n      rule\n    }) {\n      const exports = Object.create(null);\n      function exportScopedName(name, rawName) {\n        const scopedName = generateScopedName(rawName ? rawName : name, root.source.input.from, root.source.input.css);\n        const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root.source.input.from, root.source.input.css);\n        const {\n          key,\n          value\n        } = exportEntry;\n        exports[key] = exports[key] || [];\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n        return scopedName;\n      }\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map(localizeNode);\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n            });\n          case \"id\":\n            {\n              return selectorParser.id({\n                value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n              });\n            }\n        }\n        throw new Error(`${node.type} (\"${node}\") is not allowed in a :local block`);\n      }\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n              const selector = localizeNode(node.first, node.spaces);\n              // move the spaces that were around the psuedo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n              const nextNode = node.next();\n              if (nextNode && nextNode.type === \"combinator\" && nextNode.value === \" \" && /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)) {\n                selector.last.spaces.after = \" \";\n              }\n              node.replaceWith(selector);\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\":\n            {\n              node.each(traverseNode);\n              break;\n            }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n      root.walkRules(/^:import\\(.+\\)$/, rule => {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules(rule => {\n        let parsedSelector = selectorParser().astSync(rule);\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n        rule.walkDecls(/composes|compose-with/i, decl => {\n          const localNames = getSingleLocalNamesForComposes(parsedSelector);\n          const classes = decl.value.split(/\\s+/);\n          classes.forEach(className => {\n            const global = /^global\\(([^)]+)\\)$/.exec(className);\n            if (global) {\n              localNames.forEach(exportedName => {\n                exports[exportedName].push(global[1]);\n              });\n            } else if (hasOwnProperty.call(importedNames, className)) {\n              localNames.forEach(exportedName => {\n                exports[exportedName].push(className);\n              });\n            } else if (hasOwnProperty.call(exports, className)) {\n              localNames.forEach(exportedName => {\n                exports[className].forEach(item => {\n                  exports[exportedName].push(item);\n                });\n              });\n            } else {\n              throw decl.error(`referenced class name \"${className}\" in ${decl.prop} not found`);\n            }\n          });\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls(decl => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n              return result;\n            } else {\n              return token;\n            }\n          });\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, atRule => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n        if (!localMatch) {\n          return;\n        }\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n      if (exportedNames.length > 0) {\n        const exportRule = rule({\n          selector: \":export\"\n        });\n        exportedNames.forEach(exportedName => exportRule.append({\n          prop: exportedName,\n          value: exports[exportedName].join(\" \"),\n          raws: {\n            before: \"\\n  \"\n          }\n        }));\n        root.append(exportRule);\n      }\n    }\n  };\n};\nplugin.postcss = true;\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path.replace(/\\.[^./\\\\]+$/, \"\").replace(/[\\W_]+/g, \"_\").replace(/^_|_$/g, \"\");\n  return `_${sanitisedPath}__${name}`.trim();\n};\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName)\n  };\n};\nmodule.exports = plugin;","map":{"version":3,"names":["selectorParser","require","hasOwnProperty","Object","prototype","getSingleLocalNamesForComposes","root","nodes","map","node","type","length","Error","value","first","whitespace","unescapeRegExp","RegExp","unescape","str","replace","_","escaped","escapedWhitespace","high","String","fromCharCode","plugin","options","generateScopedName","generateExportEntry","exportGlobals","postcssPlugin","Once","rule","exports","create","exportScopedName","name","rawName","scopedName","source","input","from","css","exportEntry","key","indexOf","push","localizeNode","className","raws","id","traverseNode","selector","spaces","nextNode","next","test","last","after","replaceWith","each","importedNames","walkRules","walkDecls","decl","prop","parsedSelector","astSync","clone","toString","localNames","classes","split","forEach","global","exec","exportedName","call","item","error","remove","tokens","token","idx","result","localMatch","matchPattern","matchVal","newVal","join","walkAtRules","atRule","params","exportedNames","keys","exportRule","append","before","postcss","path","sanitisedPath","trim","module"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/postcss-modules-scope/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map((node) => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== \"pseudo\" ||\n      node.value !== \":local\" ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\n  \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\",\n  \"ig\"\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n      ? // BMP codepoint\n        String.fromCharCode(high + 0x10000)\n      : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst plugin = (options = {}) => {\n  const generateScopedName =\n    (options && options.generateScopedName) || plugin.generateScopedName;\n  const generateExportEntry =\n    (options && options.generateExportEntry) || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, { rule }) {\n      const exports = Object.create(null);\n\n      function exportScopedName(name, rawName) {\n        const scopedName = generateScopedName(\n          rawName ? rawName : name,\n          root.source.input.from,\n          root.source.input.css\n        );\n        const exportEntry = generateExportEntry(\n          rawName ? rawName : name,\n          scopedName,\n          root.source.input.from,\n          root.source.input.css\n        );\n        const { key, value } = exportEntry;\n\n        exports[key] = exports[key] || [];\n\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n\n        return scopedName;\n      }\n\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map(localizeNode);\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null\n              ),\n            });\n          case \"id\": {\n            return selectorParser.id({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null\n              ),\n            });\n          }\n        }\n\n        throw new Error(\n          `${node.type} (\"${node}\") is not allowed in a :local block`\n        );\n      }\n\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n\n              const selector = localizeNode(node.first, node.spaces);\n              // move the spaces that were around the psuedo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n\n              const nextNode = node.next();\n\n              if (\n                nextNode &&\n                nextNode.type === \"combinator\" &&\n                nextNode.value === \" \" &&\n                /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n              ) {\n                selector.last.spaces.after = \" \";\n              }\n\n              node.replaceWith(selector);\n\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\": {\n            node.each(traverseNode);\n            break;\n          }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n\n      root.walkRules(/^:import\\(.+\\)$/, (rule) => {\n        rule.walkDecls((decl) => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules((rule) => {\n        let parsedSelector = selectorParser().astSync(rule);\n\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n        rule.walkDecls(/composes|compose-with/i, (decl) => {\n          const localNames = getSingleLocalNamesForComposes(parsedSelector);\n          const classes = decl.value.split(/\\s+/);\n\n          classes.forEach((className) => {\n            const global = /^global\\(([^)]+)\\)$/.exec(className);\n\n            if (global) {\n              localNames.forEach((exportedName) => {\n                exports[exportedName].push(global[1]);\n              });\n            } else if (hasOwnProperty.call(importedNames, className)) {\n              localNames.forEach((exportedName) => {\n                exports[exportedName].push(className);\n              });\n            } else if (hasOwnProperty.call(exports, className)) {\n              localNames.forEach((exportedName) => {\n                exports[className].forEach((item) => {\n                  exports[exportedName].push(item);\n                });\n              });\n            } else {\n              throw decl.error(\n                `referenced class name \"${className}\" in ${decl.prop} not found`\n              );\n            }\n          });\n\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls((decl) => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n\n              return result;\n            } else {\n              return token;\n            }\n          });\n\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, (atRule) => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n\n        if (!localMatch) {\n          return;\n        }\n\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n\n      if (exportedNames.length > 0) {\n        const exportRule = rule({ selector: \":export\" });\n\n        exportedNames.forEach((exportedName) =>\n          exportRule.append({\n            prop: exportedName,\n            value: exports[exportedName].join(\" \"),\n            raws: { before: \"\\n  \" },\n          })\n        );\n\n        root.append(exportRule);\n      }\n    },\n  };\n};\n\nplugin.postcss = true;\n\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^./\\\\]+$/, \"\")\n    .replace(/[\\W_]+/g, \"_\")\n    .replace(/^_|_$/g, \"\");\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nmodule.exports = plugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}