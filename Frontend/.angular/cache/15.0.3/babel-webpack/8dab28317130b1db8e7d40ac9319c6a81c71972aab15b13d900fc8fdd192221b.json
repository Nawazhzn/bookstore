{"ast":null,"code":"// GENERATED FILE. DO NOT EDIT.\nvar ipCodec = function (exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.decode = decode;\n  exports.encode = encode;\n  exports.familyOf = familyOf;\n  exports.name = void 0;\n  exports.sizeOf = sizeOf;\n  exports.v6 = exports.v4 = void 0;\n  const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\n  const v4Size = 4;\n  const v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n  const v6Size = 16;\n  const v4 = {\n    name: 'v4',\n    size: v4Size,\n    isFormat: ip => v4Regex.test(ip),\n    encode(ip, buff, offset) {\n      offset = ~~offset;\n      buff = buff || new Uint8Array(offset + v4Size);\n      const max = ip.length;\n      let n = 0;\n      for (let i = 0; i < max;) {\n        const c = ip.charCodeAt(i++);\n        if (c === 46) {\n          // \".\"\n          buff[offset++] = n;\n          n = 0;\n        } else {\n          n = n * 10 + (c - 48);\n        }\n      }\n      buff[offset] = n;\n      return buff;\n    },\n    decode(buff, offset) {\n      offset = ~~offset;\n      return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;\n    }\n  };\n  exports.v4 = v4;\n  const v6 = {\n    name: 'v6',\n    size: v6Size,\n    isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n    encode(ip, buff, offset) {\n      offset = ~~offset;\n      let end = offset + v6Size;\n      let fill = -1;\n      let hexN = 0;\n      let decN = 0;\n      let prevColon = true;\n      let useDec = false;\n      buff = buff || new Uint8Array(offset + v6Size); // Note: This algorithm needs to check if the offset\n      // could exceed the buffer boundaries as it supports\n      // non-standard compliant encodings that may go beyond\n      // the boundary limits. if (offset < end) checks should\n      // not be necessary...\n\n      for (let i = 0; i < ip.length; i++) {\n        let c = ip.charCodeAt(i);\n        if (c === 58) {\n          // :\n          if (prevColon) {\n            if (fill !== -1) {\n              // Not Standard! (standard doesn't allow multiple ::)\n              // We need to treat\n              if (offset < end) buff[offset] = 0;\n              if (offset < end - 1) buff[offset + 1] = 0;\n              offset += 2;\n            } else if (offset < end) {\n              // :: in the middle\n              fill = offset;\n            }\n          } else {\n            // : ends the previous number\n            if (useDec === true) {\n              // Non-standard! (ipv4 should be at end only)\n              // A ipv4 address should not be found anywhere else but at\n              // the end. This codec also support putting characters\n              // after the ipv4 address..\n              if (offset < end) buff[offset] = decN;\n              offset++;\n            } else {\n              if (offset < end) buff[offset] = hexN >> 8;\n              if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n              offset += 2;\n            }\n            hexN = 0;\n            decN = 0;\n          }\n          prevColon = true;\n          useDec = false;\n        } else if (c === 46) {\n          // . indicates IPV4 notation\n          if (offset < end) buff[offset] = decN;\n          offset++;\n          decN = 0;\n          hexN = 0;\n          prevColon = false;\n          useDec = true;\n        } else {\n          prevColon = false;\n          if (c >= 97) {\n            c -= 87; // a-f ... 97~102 -87 => 10~15\n          } else if (c >= 65) {\n            c -= 55; // A-F ... 65~70 -55 => 10~15\n          } else {\n            c -= 48; // 0-9 ... starting from charCode 48\n\n            decN = decN * 10 + c;\n          } // We don't know yet if its a dec or hex number\n\n          hexN = (hexN << 4) + c;\n        }\n      }\n      if (prevColon === false) {\n        // Commiting last number\n        if (useDec === true) {\n          if (offset < end) buff[offset] = decN;\n          offset++;\n        } else {\n          if (offset < end) buff[offset] = hexN >> 8;\n          if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n          offset += 2;\n        }\n      } else if (fill === 0) {\n        // Not Standard! (standard doesn't allow multiple ::)\n        // This means that a : was found at the start AND end which means the\n        // end needs to be treated as 0 entry...\n        if (offset < end) buff[offset] = 0;\n        if (offset < end - 1) buff[offset + 1] = 0;\n        offset += 2;\n      } else if (fill !== -1) {\n        // Non-standard! (standard doens't allow multiple ::)\n        // Here we find that there has been a :: somewhere in the middle\n        // and the end. To treat the end with priority we need to move all\n        // written data two bytes to the right.\n        offset += 2;\n        for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n          buff[i] = buff[i - 2];\n        }\n        buff[fill] = 0;\n        buff[fill + 1] = 0;\n        fill = offset;\n      }\n      if (fill !== offset && fill !== -1) {\n        // Move the written numbers to the end while filling the everything\n        // \"fill\" to the bytes with zeros.\n        if (offset > end - 2) {\n          // Non Standard support, when the cursor exceeds bounds.\n          offset = end - 2;\n        }\n        while (end > fill) {\n          buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;\n        }\n      } else {\n        // Fill the rest with zeros\n        while (offset < end) {\n          buff[offset++] = 0;\n        }\n      }\n      return buff;\n    },\n    decode(buff, offset) {\n      offset = ~~offset;\n      let result = '';\n      for (let i = 0; i < v6Size; i += 2) {\n        if (i !== 0) {\n          result += ':';\n        }\n        result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);\n      }\n      return result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');\n    }\n  };\n  exports.v6 = v6;\n  const name = 'ip';\n  exports.name = name;\n  function sizeOf(ip) {\n    if (v4.isFormat(ip)) return v4.size;\n    if (v6.isFormat(ip)) return v6.size;\n    throw Error(`Invalid ip address: ${ip}`);\n  }\n  function familyOf(string) {\n    return sizeOf(string) === v4.size ? 1 : 2;\n  }\n  function encode(ip, buff, offset) {\n    offset = ~~offset;\n    const size = sizeOf(ip);\n    if (typeof buff === 'function') {\n      buff = buff(offset + size);\n    }\n    if (size === v4.size) {\n      return v4.encode(ip, buff, offset);\n    }\n    return v6.encode(ip, buff, offset);\n  }\n  function decode(buff, offset, length) {\n    offset = ~~offset;\n    length = length || buff.length - offset;\n    if (length === v4.size) {\n      return v4.decode(buff, offset, length);\n    }\n    if (length === v6.size) {\n      return v6.decode(buff, offset, length);\n    }\n    throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`);\n  }\n  return \"default\" in exports ? exports.default : exports;\n}({});\nif (typeof define === 'function' && define.amd) define([], function () {\n  return ipCodec;\n});else if (typeof module === 'object' && typeof exports === 'object') module.exports = ipCodec;","map":{"version":3,"names":["ipCodec","exports","Object","defineProperty","value","decode","encode","familyOf","name","sizeOf","v6","v4","v4Regex","v4Size","v6Regex","v6Size","size","isFormat","ip","test","buff","offset","Uint8Array","max","length","n","i","c","charCodeAt","end","fill","hexN","decN","prevColon","useDec","Math","min","result","toString","replace","Error","string","default","define","amd","module"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@leichtgewicht/ip-codec/index.cjs"],"sourcesContent":["// GENERATED FILE. DO NOT EDIT.\nvar ipCodec = (function(exports) {\n  \"use strict\";\n  \n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.decode = decode;\n  exports.encode = encode;\n  exports.familyOf = familyOf;\n  exports.name = void 0;\n  exports.sizeOf = sizeOf;\n  exports.v6 = exports.v4 = void 0;\n  const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\n  const v4Size = 4;\n  const v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n  const v6Size = 16;\n  const v4 = {\n    name: 'v4',\n    size: v4Size,\n    isFormat: ip => v4Regex.test(ip),\n  \n    encode(ip, buff, offset) {\n      offset = ~~offset;\n      buff = buff || new Uint8Array(offset + v4Size);\n      const max = ip.length;\n      let n = 0;\n  \n      for (let i = 0; i < max;) {\n        const c = ip.charCodeAt(i++);\n  \n        if (c === 46) {\n          // \".\"\n          buff[offset++] = n;\n          n = 0;\n        } else {\n          n = n * 10 + (c - 48);\n        }\n      }\n  \n      buff[offset] = n;\n      return buff;\n    },\n  \n    decode(buff, offset) {\n      offset = ~~offset;\n      return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;\n    }\n  \n  };\n  exports.v4 = v4;\n  const v6 = {\n    name: 'v6',\n    size: v6Size,\n    isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n  \n    encode(ip, buff, offset) {\n      offset = ~~offset;\n      let end = offset + v6Size;\n      let fill = -1;\n      let hexN = 0;\n      let decN = 0;\n      let prevColon = true;\n      let useDec = false;\n      buff = buff || new Uint8Array(offset + v6Size); // Note: This algorithm needs to check if the offset\n      // could exceed the buffer boundaries as it supports\n      // non-standard compliant encodings that may go beyond\n      // the boundary limits. if (offset < end) checks should\n      // not be necessary...\n  \n      for (let i = 0; i < ip.length; i++) {\n        let c = ip.charCodeAt(i);\n  \n        if (c === 58) {\n          // :\n          if (prevColon) {\n            if (fill !== -1) {\n              // Not Standard! (standard doesn't allow multiple ::)\n              // We need to treat\n              if (offset < end) buff[offset] = 0;\n              if (offset < end - 1) buff[offset + 1] = 0;\n              offset += 2;\n            } else if (offset < end) {\n              // :: in the middle\n              fill = offset;\n            }\n          } else {\n            // : ends the previous number\n            if (useDec === true) {\n              // Non-standard! (ipv4 should be at end only)\n              // A ipv4 address should not be found anywhere else but at\n              // the end. This codec also support putting characters\n              // after the ipv4 address..\n              if (offset < end) buff[offset] = decN;\n              offset++;\n            } else {\n              if (offset < end) buff[offset] = hexN >> 8;\n              if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n              offset += 2;\n            }\n  \n            hexN = 0;\n            decN = 0;\n          }\n  \n          prevColon = true;\n          useDec = false;\n        } else if (c === 46) {\n          // . indicates IPV4 notation\n          if (offset < end) buff[offset] = decN;\n          offset++;\n          decN = 0;\n          hexN = 0;\n          prevColon = false;\n          useDec = true;\n        } else {\n          prevColon = false;\n  \n          if (c >= 97) {\n            c -= 87; // a-f ... 97~102 -87 => 10~15\n          } else if (c >= 65) {\n            c -= 55; // A-F ... 65~70 -55 => 10~15\n          } else {\n            c -= 48; // 0-9 ... starting from charCode 48\n  \n            decN = decN * 10 + c;\n          } // We don't know yet if its a dec or hex number\n  \n  \n          hexN = (hexN << 4) + c;\n        }\n      }\n  \n      if (prevColon === false) {\n        // Commiting last number\n        if (useDec === true) {\n          if (offset < end) buff[offset] = decN;\n          offset++;\n        } else {\n          if (offset < end) buff[offset] = hexN >> 8;\n          if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n          offset += 2;\n        }\n      } else if (fill === 0) {\n        // Not Standard! (standard doesn't allow multiple ::)\n        // This means that a : was found at the start AND end which means the\n        // end needs to be treated as 0 entry...\n        if (offset < end) buff[offset] = 0;\n        if (offset < end - 1) buff[offset + 1] = 0;\n        offset += 2;\n      } else if (fill !== -1) {\n        // Non-standard! (standard doens't allow multiple ::)\n        // Here we find that there has been a :: somewhere in the middle\n        // and the end. To treat the end with priority we need to move all\n        // written data two bytes to the right.\n        offset += 2;\n  \n        for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n          buff[i] = buff[i - 2];\n        }\n  \n        buff[fill] = 0;\n        buff[fill + 1] = 0;\n        fill = offset;\n      }\n  \n      if (fill !== offset && fill !== -1) {\n        // Move the written numbers to the end while filling the everything\n        // \"fill\" to the bytes with zeros.\n        if (offset > end - 2) {\n          // Non Standard support, when the cursor exceeds bounds.\n          offset = end - 2;\n        }\n  \n        while (end > fill) {\n          buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;\n        }\n      } else {\n        // Fill the rest with zeros\n        while (offset < end) {\n          buff[offset++] = 0;\n        }\n      }\n  \n      return buff;\n    },\n  \n    decode(buff, offset) {\n      offset = ~~offset;\n      let result = '';\n  \n      for (let i = 0; i < v6Size; i += 2) {\n        if (i !== 0) {\n          result += ':';\n        }\n  \n        result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);\n      }\n  \n      return result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');\n    }\n  \n  };\n  exports.v6 = v6;\n  const name = 'ip';\n  exports.name = name;\n  \n  function sizeOf(ip) {\n    if (v4.isFormat(ip)) return v4.size;\n    if (v6.isFormat(ip)) return v6.size;\n    throw Error(`Invalid ip address: ${ip}`);\n  }\n  \n  function familyOf(string) {\n    return sizeOf(string) === v4.size ? 1 : 2;\n  }\n  \n  function encode(ip, buff, offset) {\n    offset = ~~offset;\n    const size = sizeOf(ip);\n  \n    if (typeof buff === 'function') {\n      buff = buff(offset + size);\n    }\n  \n    if (size === v4.size) {\n      return v4.encode(ip, buff, offset);\n    }\n  \n    return v6.encode(ip, buff, offset);\n  }\n  \n  function decode(buff, offset, length) {\n    offset = ~~offset;\n    length = length || buff.length - offset;\n  \n    if (length === v4.size) {\n      return v4.decode(buff, offset, length);\n    }\n  \n    if (length === v6.size) {\n      return v6.decode(buff, offset, length);\n    }\n  \n    throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`);\n  }\n  return \"default\" in exports ? exports.default : exports;\n})({});\nif (typeof define === 'function' && define.amd) define([], function() { return ipCodec; });\nelse if (typeof module === 'object' && typeof exports==='object') module.exports = ipCodec;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}