{"ast":null,"code":"const debug = require('debug')('log4js:fileSync');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\nconst eol = os.EOL;\nfunction touchFile(file, options) {\n  // attempt to create the directory\n  const mkdir = dir => {\n    try {\n      return fs.mkdirSync(dir, {\n        recursive: true\n      });\n    } catch (e) {\n      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)\n      // recursive creation of parent first\n      if (e.code === 'ENOENT') {\n        mkdir(path.dirname(dir));\n        return mkdir(dir);\n      }\n\n      // throw error for all except EEXIST and EROFS (read-only filesystem)\n      if (e.code !== 'EEXIST' && e.code !== 'EROFS') {\n        throw e;\n      }\n\n      // EEXIST: throw if file and not directory\n      // EROFS : throw if directory not found\n      else {\n        try {\n          if (fs.statSync(dir).isDirectory()) {\n            return dir;\n          }\n          throw e;\n        } catch (err) {\n          throw e;\n        }\n      }\n    }\n  };\n  mkdir(path.dirname(file));\n\n  // try to throw EISDIR, EROFS, EACCES\n  fs.appendFileSync(file, '', {\n    mode: options.mode,\n    flag: options.flags\n  });\n}\nclass RollingFileSync {\n  constructor(filename, maxLogSize, backups, options) {\n    debug('In RollingFileStream');\n    if (maxLogSize < 0) {\n      throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);\n    }\n    this.filename = filename;\n    this.size = maxLogSize;\n    this.backups = backups;\n    this.options = options;\n    this.currentSize = 0;\n    function currentFileSize(file) {\n      let fileSize = 0;\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n      return fileSize;\n    }\n    this.currentSize = currentFileSize(this.filename);\n  }\n  shouldRoll() {\n    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n    return this.currentSize >= this.size;\n  }\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n    function index(filename_) {\n      return parseInt(filename_.slice(`${path.basename(filename)}.`.length), 10) || 0;\n    }\n    function byIndex(a, b) {\n      return index(a) - index(b);\n    }\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n      if (that.backups === 0) {\n        fs.truncateSync(filename, 0);\n      } else if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {\n          // ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);\n      }\n    }\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n      const files = fs.readdirSync(path.dirname(filename));\n      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n    }\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  write(chunk, encoding) {\n    const that = this;\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n    debug('in write');\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n    writeTheChunk();\n  }\n}\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file the file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param options - options to be passed to the underlying stream\n * @param timezoneOffset - optional timezone offset in minutes (default system local)\n */\nfunction fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error(`Invalid filename: ${file}`);\n  } else if (file.endsWith(path.sep)) {\n    throw new Error(`Filename is a directory: ${file}`);\n  } else {\n    // handle ~ expansion: https://github.com/nodejs/node/issues/684\n    // exclude ~ and ~filename as these can be valid files\n    file = file.replace(new RegExp(`^~(?=${path.sep}.+)`), os.homedir());\n  }\n  file = path.normalize(file);\n  numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;\n  debug('Creating fileSync appender (', file, ', ', logSize, ', ', numBackups, ', ', options, ', ', timezoneOffset, ')');\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n    if (fileSize) {\n      stream = new RollingFileSync(filePath, fileSize, numFiles, options);\n    } else {\n      stream = (f => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          }\n        };\n      })(filePath);\n    }\n    return stream;\n  }\n  const logFile = openTheStream(file, logSize, numBackups);\n  return loggingEvent => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o600\n  };\n  return fileAppender(config.filename, layout, config.maxLogSize, config.backups, options, config.timezoneOffset);\n}\nmodule.exports.configure = configure;","map":{"version":3,"names":["debug","require","path","fs","os","eol","EOL","touchFile","file","options","mkdir","dir","mkdirSync","recursive","e","code","dirname","statSync","isDirectory","err","appendFileSync","mode","flag","flags","RollingFileSync","constructor","filename","maxLogSize","backups","Error","size","currentSize","currentFileSize","fileSize","shouldRoll","roll","that","nameMatcher","RegExp","basename","justTheseFiles","item","test","index","filename_","parseInt","slice","length","byIndex","a","b","increaseFileIndex","fileToRename","idx","truncateSync","unlinkSync","renameSync","join","renameTheFiles","files","readdirSync","filter","sort","reverse","forEach","write","chunk","encoding","writeTheChunk","fileAppender","layout","logSize","numBackups","timezoneOffset","endsWith","sep","replace","homedir","normalize","openTheStream","filePath","numFiles","stream","f","data","logFile","loggingEvent","configure","config","layouts","basicLayout","type","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/log4js/lib/appenders/fileSync.js"],"sourcesContent":["const debug = require('debug')('log4js:fileSync');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst eol = os.EOL;\n\nfunction touchFile(file, options) {\n  // attempt to create the directory\n  const mkdir = (dir) => {\n    try {\n      return fs.mkdirSync(dir, { recursive: true });\n    } catch (e) {\n      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)\n      // recursive creation of parent first\n      if (e.code === 'ENOENT') {\n        mkdir(path.dirname(dir));\n        return mkdir(dir);\n      }\n\n      // throw error for all except EEXIST and EROFS (read-only filesystem)\n      if (e.code !== 'EEXIST' && e.code !== 'EROFS') {\n        throw e;\n      }\n\n      // EEXIST: throw if file and not directory\n      // EROFS : throw if directory not found\n      else {\n        try {\n          if (fs.statSync(dir).isDirectory()) {\n            return dir;\n          }\n          throw e;\n        } catch (err) {\n          throw e;\n        }\n      }\n    }\n  };\n  mkdir(path.dirname(file));\n\n  // try to throw EISDIR, EROFS, EACCES\n  fs.appendFileSync(file, '', { mode: options.mode, flag: options.flags });\n}\n\nclass RollingFileSync {\n  constructor(filename, maxLogSize, backups, options) {\n    debug('In RollingFileStream');\n\n    if (maxLogSize < 0) {\n      throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);\n    }\n\n    this.filename = filename;\n    this.size = maxLogSize;\n    this.backups = backups;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug(\n      'should roll with current size %d, and max size %d',\n      this.currentSize,\n      this.size\n    );\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return (\n        parseInt(filename_.slice(`${path.basename(filename)}.`.length), 10) || 0\n      );\n    }\n\n    function byIndex(a, b) {\n      return index(a) - index(b);\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n      if (that.backups === 0) {\n        fs.truncateSync(filename, 0);\n      } else if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {\n          // ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(\n          path.join(path.dirname(filename), fileToRename),\n          `${filename}.${idx + 1}`\n        );\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n\n      const files = fs.readdirSync(path.dirname(filename));\n      files\n        .filter(justTheseFiles)\n        .sort(byIndex)\n        .reverse()\n        .forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  write(chunk, encoding) {\n    const that = this;\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n}\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file the file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param options - options to be passed to the underlying stream\n * @param timezoneOffset - optional timezone offset in minutes (default system local)\n */\nfunction fileAppender(\n  file,\n  layout,\n  logSize,\n  numBackups,\n  options,\n  timezoneOffset\n) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error(`Invalid filename: ${file}`);\n  } else if (file.endsWith(path.sep)) {\n    throw new Error(`Filename is a directory: ${file}`);\n  } else {\n    // handle ~ expansion: https://github.com/nodejs/node/issues/684\n    // exclude ~ and ~filename as these can be valid files\n    file = file.replace(new RegExp(`^~(?=${path.sep}.+)`), os.homedir());\n  }\n  file = path.normalize(file);\n  numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;\n\n  debug(\n    'Creating fileSync appender (',\n    file,\n    ', ',\n    logSize,\n    ', ',\n    numBackups,\n    ', ',\n    options,\n    ', ',\n    timezoneOffset,\n    ')'\n  );\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(filePath, fileSize, numFiles, options);\n    } else {\n      stream = ((f) => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          },\n        };\n      })(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n\n  return (loggingEvent) => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o600,\n  };\n\n  return fileAppender(\n    config.filename,\n    layout,\n    config.maxLogSize,\n    config.backups,\n    options,\n    config.timezoneOffset\n  );\n}\n\nmodule.exports.configure = configure;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}