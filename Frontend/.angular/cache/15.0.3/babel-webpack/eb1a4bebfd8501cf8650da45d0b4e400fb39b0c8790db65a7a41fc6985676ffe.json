{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.augmentIndexHtml = void 0;\nconst crypto_1 = require(\"crypto\");\nconst load_esm_1 = require(\"../load-esm\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n/*\n * Helper function used by the IndexHtmlWebpackPlugin.\n * Can also be directly used by builder, e. g. in order to generate an index.html\n * after processing several configurations in order to build different sets of\n * bundles for differential serving.\n */\nfunction augmentIndexHtml(_x) {\n  return _augmentIndexHtml.apply(this, arguments);\n}\nfunction _augmentIndexHtml() {\n  _augmentIndexHtml = _asyncToGenerator(function* (params) {\n    const {\n      loadOutputFile,\n      files,\n      entrypoints,\n      sri,\n      deployUrl = '',\n      lang,\n      baseHref,\n      html\n    } = params;\n    const warnings = [];\n    const errors = [];\n    let {\n      crossOrigin = 'none'\n    } = params;\n    if (sri && crossOrigin === 'none') {\n      crossOrigin = 'anonymous';\n    }\n    const stylesheets = new Set();\n    const scripts = new Map();\n    // Sort files in the order we want to insert them by entrypoint\n    for (const [entrypoint, isModule] of entrypoints) {\n      for (const {\n        extension,\n        file,\n        name\n      } of files) {\n        if (name !== entrypoint || scripts.has(file) || stylesheets.has(file)) {\n          continue;\n        }\n        switch (extension) {\n          case '.js':\n            // Also, non entrypoints need to be loaded as no module as they can contain problematic code.\n            scripts.set(file, isModule);\n            break;\n          case '.css':\n            stylesheets.add(file);\n            break;\n        }\n      }\n    }\n    let scriptTags = [];\n    for (const [src, isModule] of scripts) {\n      const attrs = [`src=\"${deployUrl}${src}\"`];\n      // This is also need for non entry-points as they may contain problematic code.\n      if (isModule) {\n        attrs.push('type=\"module\"');\n      } else {\n        attrs.push('defer');\n      }\n      if (crossOrigin !== 'none') {\n        attrs.push(`crossorigin=\"${crossOrigin}\"`);\n      }\n      if (sri) {\n        const content = yield loadOutputFile(src);\n        attrs.push(generateSriAttributes(content));\n      }\n      scriptTags.push(`<script ${attrs.join(' ')}></script>`);\n    }\n    let linkTags = [];\n    for (const src of stylesheets) {\n      const attrs = [`rel=\"stylesheet\"`, `href=\"${deployUrl}${src}\"`];\n      if (crossOrigin !== 'none') {\n        attrs.push(`crossorigin=\"${crossOrigin}\"`);\n      }\n      if (sri) {\n        const content = yield loadOutputFile(src);\n        attrs.push(generateSriAttributes(content));\n      }\n      linkTags.push(`<link ${attrs.join(' ')}>`);\n    }\n    const dir = lang ? yield getLanguageDirection(lang, warnings) : undefined;\n    const {\n      rewriter,\n      transformedContent\n    } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(html);\n    const baseTagExists = html.includes('<base');\n    rewriter.on('startTag', tag => {\n      switch (tag.tagName) {\n        case 'html':\n          // Adjust document locale if specified\n          if (isString(lang)) {\n            updateAttribute(tag, 'lang', lang);\n          }\n          if (dir) {\n            updateAttribute(tag, 'dir', dir);\n          }\n          break;\n        case 'head':\n          // Base href should be added before any link, meta tags\n          if (!baseTagExists && isString(baseHref)) {\n            rewriter.emitStartTag(tag);\n            rewriter.emitRaw(`<base href=\"${baseHref}\">`);\n            return;\n          }\n          break;\n        case 'base':\n          // Adjust base href if specified\n          if (isString(baseHref)) {\n            updateAttribute(tag, 'href', baseHref);\n          }\n          break;\n      }\n      rewriter.emitStartTag(tag);\n    }).on('endTag', tag => {\n      switch (tag.tagName) {\n        case 'head':\n          for (const linkTag of linkTags) {\n            rewriter.emitRaw(linkTag);\n          }\n          linkTags = [];\n          break;\n        case 'body':\n          // Add script tags\n          for (const scriptTag of scriptTags) {\n            rewriter.emitRaw(scriptTag);\n          }\n          scriptTags = [];\n          break;\n      }\n      rewriter.emitEndTag(tag);\n    });\n    const content = yield transformedContent();\n    return {\n      content: linkTags.length || scriptTags.length ?\n      // In case no body/head tags are not present (dotnet partial templates)\n      linkTags.join('') + scriptTags.join('') + content : content,\n      warnings,\n      errors\n    };\n  });\n  return _augmentIndexHtml.apply(this, arguments);\n}\nexports.augmentIndexHtml = augmentIndexHtml;\nfunction generateSriAttributes(content) {\n  const algo = 'sha384';\n  const hash = (0, crypto_1.createHash)(algo).update(content, 'utf8').digest('base64');\n  return `integrity=\"${algo}-${hash}\"`;\n}\nfunction updateAttribute(tag, name, value) {\n  const index = tag.attrs.findIndex(a => a.name === name);\n  const newValue = {\n    name,\n    value\n  };\n  if (index === -1) {\n    tag.attrs.push(newValue);\n  } else {\n    tag.attrs[index] = newValue;\n  }\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction getLanguageDirection(_x2, _x3) {\n  return _getLanguageDirection.apply(this, arguments);\n}\nfunction _getLanguageDirection() {\n  _getLanguageDirection = _asyncToGenerator(function* (locale, warnings) {\n    const dir = yield getLanguageDirectionFromLocales(locale);\n    if (!dir) {\n      warnings.push(`Locale data for '${locale}' cannot be found. 'dir' attribute will not be set for this locale.`);\n    }\n    return dir;\n  });\n  return _getLanguageDirection.apply(this, arguments);\n}\nfunction getLanguageDirectionFromLocales(_x4) {\n  return _getLanguageDirectionFromLocales.apply(this, arguments);\n}\nfunction _getLanguageDirectionFromLocales() {\n  _getLanguageDirectionFromLocales = _asyncToGenerator(function* (locale) {\n    try {\n      const localeData = (yield (0, load_esm_1.loadEsmModule)(`@angular/common/locales/${locale}`)).default;\n      const dir = localeData[localeData.length - 2];\n      return isString(dir) ? dir : undefined;\n    } catch {\n      // In some cases certain locales might map to files which are named only with language id.\n      // Example: `en-US` -> `en`.\n      const [languageId] = locale.split('-', 1);\n      if (languageId !== locale) {\n        return getLanguageDirectionFromLocales(languageId);\n      }\n    }\n    return undefined;\n  });\n  return _getLanguageDirectionFromLocales.apply(this, arguments);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","augmentIndexHtml","crypto_1","require","load_esm_1","html_rewriting_stream_1","params","loadOutputFile","files","entrypoints","sri","deployUrl","lang","baseHref","html","warnings","errors","crossOrigin","stylesheets","Set","scripts","Map","entrypoint","isModule","extension","file","name","has","set","add","scriptTags","src","attrs","push","content","generateSriAttributes","join","linkTags","dir","getLanguageDirection","undefined","rewriter","transformedContent","htmlRewritingStream","baseTagExists","includes","on","tag","tagName","isString","updateAttribute","emitStartTag","emitRaw","linkTag","scriptTag","emitEndTag","length","algo","hash","createHash","update","digest","index","findIndex","a","newValue","locale","getLanguageDirectionFromLocales","localeData","loadEsmModule","default","languageId","split"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@angular-devkit/build-angular/src/utils/index-file/augment-index-html.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.augmentIndexHtml = void 0;\nconst crypto_1 = require(\"crypto\");\nconst load_esm_1 = require(\"../load-esm\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n/*\n * Helper function used by the IndexHtmlWebpackPlugin.\n * Can also be directly used by builder, e. g. in order to generate an index.html\n * after processing several configurations in order to build different sets of\n * bundles for differential serving.\n */\nasync function augmentIndexHtml(params) {\n    const { loadOutputFile, files, entrypoints, sri, deployUrl = '', lang, baseHref, html } = params;\n    const warnings = [];\n    const errors = [];\n    let { crossOrigin = 'none' } = params;\n    if (sri && crossOrigin === 'none') {\n        crossOrigin = 'anonymous';\n    }\n    const stylesheets = new Set();\n    const scripts = new Map();\n    // Sort files in the order we want to insert them by entrypoint\n    for (const [entrypoint, isModule] of entrypoints) {\n        for (const { extension, file, name } of files) {\n            if (name !== entrypoint || scripts.has(file) || stylesheets.has(file)) {\n                continue;\n            }\n            switch (extension) {\n                case '.js':\n                    // Also, non entrypoints need to be loaded as no module as they can contain problematic code.\n                    scripts.set(file, isModule);\n                    break;\n                case '.css':\n                    stylesheets.add(file);\n                    break;\n            }\n        }\n    }\n    let scriptTags = [];\n    for (const [src, isModule] of scripts) {\n        const attrs = [`src=\"${deployUrl}${src}\"`];\n        // This is also need for non entry-points as they may contain problematic code.\n        if (isModule) {\n            attrs.push('type=\"module\"');\n        }\n        else {\n            attrs.push('defer');\n        }\n        if (crossOrigin !== 'none') {\n            attrs.push(`crossorigin=\"${crossOrigin}\"`);\n        }\n        if (sri) {\n            const content = await loadOutputFile(src);\n            attrs.push(generateSriAttributes(content));\n        }\n        scriptTags.push(`<script ${attrs.join(' ')}></script>`);\n    }\n    let linkTags = [];\n    for (const src of stylesheets) {\n        const attrs = [`rel=\"stylesheet\"`, `href=\"${deployUrl}${src}\"`];\n        if (crossOrigin !== 'none') {\n            attrs.push(`crossorigin=\"${crossOrigin}\"`);\n        }\n        if (sri) {\n            const content = await loadOutputFile(src);\n            attrs.push(generateSriAttributes(content));\n        }\n        linkTags.push(`<link ${attrs.join(' ')}>`);\n    }\n    const dir = lang ? await getLanguageDirection(lang, warnings) : undefined;\n    const { rewriter, transformedContent } = await (0, html_rewriting_stream_1.htmlRewritingStream)(html);\n    const baseTagExists = html.includes('<base');\n    rewriter\n        .on('startTag', (tag) => {\n        switch (tag.tagName) {\n            case 'html':\n                // Adjust document locale if specified\n                if (isString(lang)) {\n                    updateAttribute(tag, 'lang', lang);\n                }\n                if (dir) {\n                    updateAttribute(tag, 'dir', dir);\n                }\n                break;\n            case 'head':\n                // Base href should be added before any link, meta tags\n                if (!baseTagExists && isString(baseHref)) {\n                    rewriter.emitStartTag(tag);\n                    rewriter.emitRaw(`<base href=\"${baseHref}\">`);\n                    return;\n                }\n                break;\n            case 'base':\n                // Adjust base href if specified\n                if (isString(baseHref)) {\n                    updateAttribute(tag, 'href', baseHref);\n                }\n                break;\n        }\n        rewriter.emitStartTag(tag);\n    })\n        .on('endTag', (tag) => {\n        switch (tag.tagName) {\n            case 'head':\n                for (const linkTag of linkTags) {\n                    rewriter.emitRaw(linkTag);\n                }\n                linkTags = [];\n                break;\n            case 'body':\n                // Add script tags\n                for (const scriptTag of scriptTags) {\n                    rewriter.emitRaw(scriptTag);\n                }\n                scriptTags = [];\n                break;\n        }\n        rewriter.emitEndTag(tag);\n    });\n    const content = await transformedContent();\n    return {\n        content: linkTags.length || scriptTags.length\n            ? // In case no body/head tags are not present (dotnet partial templates)\n                linkTags.join('') + scriptTags.join('') + content\n            : content,\n        warnings,\n        errors,\n    };\n}\nexports.augmentIndexHtml = augmentIndexHtml;\nfunction generateSriAttributes(content) {\n    const algo = 'sha384';\n    const hash = (0, crypto_1.createHash)(algo).update(content, 'utf8').digest('base64');\n    return `integrity=\"${algo}-${hash}\"`;\n}\nfunction updateAttribute(tag, name, value) {\n    const index = tag.attrs.findIndex((a) => a.name === name);\n    const newValue = { name, value };\n    if (index === -1) {\n        tag.attrs.push(newValue);\n    }\n    else {\n        tag.attrs[index] = newValue;\n    }\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nasync function getLanguageDirection(locale, warnings) {\n    const dir = await getLanguageDirectionFromLocales(locale);\n    if (!dir) {\n        warnings.push(`Locale data for '${locale}' cannot be found. 'dir' attribute will not be set for this locale.`);\n    }\n    return dir;\n}\nasync function getLanguageDirectionFromLocales(locale) {\n    try {\n        const localeData = (await (0, load_esm_1.loadEsmModule)(`@angular/common/locales/${locale}`)).default;\n        const dir = localeData[localeData.length - 2];\n        return isString(dir) ? dir : undefined;\n    }\n    catch {\n        // In some cases certain locales might map to files which are named only with language id.\n        // Example: `en-US` -> `en`.\n        const [languageId] = locale.split('-', 1);\n        if (languageId !== locale) {\n            return getLanguageDirectionFromLocales(languageId);\n        }\n    }\n    return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}