{"ast":null,"code":"var util = require('util');\nvar events = require('events').EventEmitter;\nvar qjob = function (options) {\n  if (false === this instanceof qjob) {\n    return new qjob(options);\n  }\n  this.maxConcurrency = 10;\n  this.jobsRunning = 0;\n  this.jobsDone = 0;\n  this.jobsTotal = 0;\n  this.timeStart;\n  this.jobId = 0;\n  this.jobsList = [];\n  this.paused = false;\n  this.pausedId = null;\n  this.lastPause = 0;\n  this.interval = null;\n  this.stopAdding = false;\n  this.sleeping = false;\n  this.aborting = false;\n  if (options) {\n    this.maxConcurrency = options.maxConcurrency || this.maxConcurrency;\n    this.interval = options.interval || this.interval;\n  }\n  events.call(this);\n};\nutil.inherits(qjob, events);\n\n/*\n * helper to set max concurrency\n */\nqjob.prototype.setConcurrency = function (max) {\n  this.maxConcurrency = max;\n};\n\n/*\n * helper to set delay between rafales\n */\nqjob.prototype.setInterval = function (delay) {\n  this.interval = delay;\n};\n\n/*\n * add some jobs in the queue\n */\nqjob.prototype.add = function (job, args) {\n  var self = this;\n  self.jobsList.push([job, args]);\n  self.jobsTotal++;\n};\n\n/*\n *\n */\nqjob.prototype.sleepDueToInterval = function () {\n  var self = this;\n  if (this.interval === null) {\n    return;\n  }\n  if (this.sleeping) {\n    return true;\n  }\n  if (this.stopAdding) {\n    if (this.jobsRunning > 0) {\n      //console.log('waiting for '+jobsRunning+' jobs to finish');\n      return true;\n    }\n\n    //console.log('waiting for '+rafaleDelay+' ms');\n    this.sleeping = true;\n    self.emit('sleep');\n    setTimeout(function () {\n      this.stopAdding = false;\n      this.sleeping = false;\n      self.emit('continu');\n      self.run();\n    }.bind(self), this.interval);\n    return true;\n  }\n  if (this.jobsRunning + 1 == this.maxConcurrency) {\n    //console.log('max concurrent jobs reached');\n    this.stopAdding = true;\n    return true;\n  }\n};\n\n/*\n * run the queue\n */\nqjob.prototype.run = function () {\n  var self = this;\n\n  // first launch, let's emit start event\n  if (this.jobsDone == 0) {\n    self.emit('start');\n    this.timeStart = Date.now();\n  }\n  if (self.sleepDueToInterval()) return;\n  if (self.aborting) {\n    this.jobsList = [];\n  }\n\n  // while queue is empty and number of job running\n  // concurrently are less than max job running,\n  // then launch the next job\n\n  while (this.jobsList.length && this.jobsRunning < this.maxConcurrency) {\n    // get the next job and\n    // remove it from the queue\n    var job = self.jobsList.shift();\n\n    // increment number of job running\n    self.jobsRunning++;\n\n    // fetch args for the job\n    var args = job[1];\n\n    // add jobId in args\n    args._jobId = this.jobId++;\n\n    // emit jobStart event\n    self.emit('jobStart', args);\n\n    // run the job\n    setTimeout(function () {\n      this.j(this.args, self.next.bind(self, this.args));\n    }.bind({\n      j: job[0],\n      args: args\n    }), 1);\n  }\n\n  // all jobs done ? emit end event\n  if (this.jobsList.length == 0 && this.jobsRunning == 0) {\n    self.emit('end');\n  }\n};\n\n/*\n * a task has been terminated,\n * so 'next()' has been called\n */\nqjob.prototype.next = function (args) {\n  var self = this;\n\n  // update counters\n  this.jobsRunning--;\n  this.jobsDone++;\n\n  // emit 'jobEnd' event\n  self.emit('jobEnd', args);\n\n  // if queue has been set to pause\n  // then do nothing\n  if (this.paused) return;\n\n  // else, execute run() function\n  self.run();\n};\n\n/*\n * You can 'pause' jobs.\n * it will not pause running jobs, but\n * it will stop launching pending jobs\n * until paused = false\n */\nqjob.prototype.pause = function (status) {\n  var self = this;\n  this.paused = status;\n  if (!this.paused && this.pausedId) {\n    clearInterval(this.pausedId);\n    self.emit('unpause');\n    this.run();\n  }\n  if (this.paused && !this.pausedId) {\n    self.lastPause = Date.now();\n    this.pausedId = setInterval(function () {\n      var since = Date.now() - self.lastPause;\n      self.emit('pause', since);\n    }, 1000);\n    return;\n  }\n};\nqjob.prototype.stats = function () {\n  var now = Date.now();\n  var o = {};\n  o._timeStart = this.timeStart || 'N/A';\n  o._timeElapsed = now - this.timeStart || 'N/A';\n  o._jobsTotal = this.jobsTotal;\n  o._jobsRunning = this.jobsRunning;\n  o._jobsDone = this.jobsDone;\n  o._progress = Math.floor(this.jobsDone / this.jobsTotal * 100);\n  o._concurrency = this.maxConcurrency;\n  if (this.paused) {\n    o._status = 'Paused';\n    return o;\n  }\n  if (o._timeElapsed == 'N/A') {\n    o._status = 'Starting';\n    return o;\n  }\n  if (this.jobsTotal == this.jobsDone) {\n    o._status = 'Finished';\n    return o;\n  }\n  o._status = 'Running';\n  return o;\n};\nqjob.prototype.abort = function () {\n  this.aborting = true;\n};\nmodule.exports = qjob;","map":{"version":3,"names":["util","require","events","EventEmitter","qjob","options","maxConcurrency","jobsRunning","jobsDone","jobsTotal","timeStart","jobId","jobsList","paused","pausedId","lastPause","interval","stopAdding","sleeping","aborting","call","inherits","prototype","setConcurrency","max","setInterval","delay","add","job","args","self","push","sleepDueToInterval","emit","setTimeout","run","bind","Date","now","length","shift","_jobId","j","next","pause","status","clearInterval","since","stats","o","_timeStart","_timeElapsed","_jobsTotal","_jobsRunning","_jobsDone","_progress","Math","floor","_concurrency","_status","abort","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/qjobs/qjobs.js"],"sourcesContent":["var util = require('util');\nvarÂ events = require('events').EventEmitter;\n\nvar qjob = function(options) {\n\n    if(false === (this instanceof qjob)) {\n        return new qjob(options);\n    }\n\n    this.maxConcurrency  = 10;\n    this.jobsRunning = 0;\n    this.jobsDone = 0;\n    this.jobsTotal = 0;\n    this.timeStart;\n    this.jobId = 0;\n    this.jobsList = [];\n    this.paused = false;\n    this.pausedId = null;\n    this.lastPause = 0;\n\n    this.interval = null;\n    this.stopAdding = false;\n    this.sleeping = false;\n\n    this.aborting = false;\n\n    if (options) {\n        this.maxConcurrency = options.maxConcurrency || this.maxConcurrency;\n        this.interval = options.interval || this.interval;\n    }\n    events.call(this);\n};\n\nutil.inherits(qjob, events);\n\n/*\n * helper to set max concurrency\n */\nqjob.prototype.setConcurrency = function(max) {\n    this.maxConcurrency = max;\n}\n\n/*\n * helper to set delay between rafales\n */\nqjob.prototype.setInterval = function(delay) {\n    this.interval = delay;\n}\n\n/*\n * add some jobs in the queue\n */\nqjob.prototype.add = function(job,args) {\n    var self = this;\n    self.jobsList.push([job,args]);\n    self.jobsTotal++;\n}\n\n/*\n *\n */\nqjob.prototype.sleepDueToInterval = function() {\n    var self = this;\n\n    if (this.interval === null) {\n        return;\n    }\n\n    if (this.sleeping) {\n        return true;\n    }\n\n    if (this.stopAdding) {\n\n        if (this.jobsRunning > 0) {\n            //console.log('waiting for '+jobsRunning+' jobs to finish');\n            return true;\n        }\n\n        //console.log('waiting for '+rafaleDelay+' ms');\n        this.sleeping = true;\n        self.emit('sleep');\n\n        setTimeout(function() {\n            this.stopAdding = false;\n            this.sleeping = false;\n            self.emit('continu');\n            self.run();\n        }.bind(self),this.interval);\n\n        return true;\n    }\n\n    if (this.jobsRunning + 1 == this.maxConcurrency) {\n        //console.log('max concurrent jobs reached');\n        this.stopAdding = true;\n        return true;\n    }\n}\n\n/*\n * run the queue\n */\nqjob.prototype.run = function() {\n\n    var self = this;\n\n    // first launch, let's emit start event\n    if (this.jobsDone == 0) {\n        self.emit('start');\n        this.timeStart = Date.now();\n    }\n\n    if (self.sleepDueToInterval()) return;\n\n    if (self.aborting) {\n        this.jobsList = [];\n    }\n\n    // while queue is empty and number of job running\n    // concurrently are less than max job running,\n    // then launch the next job\n\n    while (this.jobsList.length && this.jobsRunning < this.maxConcurrency) {\n        // get the next job and\n        // remove it from the queue\n        var job = self.jobsList.shift();\n\n        // increment number of job running\n        self.jobsRunning++;\n\n        // fetch args for the job\n        var args = job[1];\n\n        // add jobId in args\n        args._jobId = this.jobId++;\n\n        // emit jobStart event\n        self.emit('jobStart',args);\n\n        // run the job\n        setTimeout(function() {\n            this.j(this.args,self.next.bind(self,this.args));\n        }.bind({j:job[0],args:args}),1);\n    }\n\n    // all jobs done ? emit end event\n    if (this.jobsList.length == 0 && this.jobsRunning == 0) {\n        self.emit('end');\n    }\n}\n\n/*\n * a task has been terminated,\n * so 'next()' has been called\n */\nqjob.prototype.next = function(args) {\n\n    var self = this;\n\n    // update counters\n    this.jobsRunning--;\n    this.jobsDone++;\n\n    // emit 'jobEnd' event\n    self.emit('jobEnd',args);\n\n    // if queue has been set to pause\n    // then do nothing\n    if (this.paused) return;\n\n    // else, execute run() function\n    self.run();\n}\n\n/*\n * You can 'pause' jobs.\n * it will not pause running jobs, but\n * it will stop launching pending jobs\n * until paused = false\n */\nqjob.prototype.pause = function(status) {\n    var self = this;\n    this.paused = status;\n    if (!this.paused && this.pausedId) {\n        clearInterval(this.pausedId);\n        self.emit('unpause');\n        this.run();\n    }\n    if (this.paused && !this.pausedId) {\n        self.lastPause = Date.now();\n        this.pausedId = setInterval(function() {\n            var since = Date.now() - self.lastPause;\n            self.emit('pause',since);\n        },1000);\n        return;\n    }\n}\n\nqjob.prototype.stats = function() {\n\n    var now =  Date.now();\n\n    var o = {};\n    o._timeStart = this.timeStart || 'N/A';\n    o._timeElapsed = (now - this.timeStart) || 'N/A';\n    o._jobsTotal = this.jobsTotal;\n    o._jobsRunning = this.jobsRunning;\n    o._jobsDone = this.jobsDone;\n    o._progress = Math.floor((this.jobsDone/this.jobsTotal)*100);\n    o._concurrency = this.maxConcurrency;\n\n    if (this.paused) {\n        o._status = 'Paused';\n        return o;\n    }\n\n    if (o._timeElapsed == 'N/A') {\n        o._status = 'Starting';\n        return o;\n    }\n\n    if (this.jobsTotal == this.jobsDone) {\n        o._status = 'Finished';\n        return o;\n    }\n\n    o._status = 'Running';\n    return o;\n}\n\nqjob.prototype.abort = function() {\n    this.aborting = true;\n}\n\nmodule.exports = qjob;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}