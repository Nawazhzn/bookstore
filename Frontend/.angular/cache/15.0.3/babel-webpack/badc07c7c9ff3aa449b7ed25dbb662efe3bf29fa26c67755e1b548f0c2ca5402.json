{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2015-present, Waysact Pty Ltd\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getChunkToManifestMap = exports.buildTopologicallySortedChunkGraph = exports.generateSriHashPlaceholders = exports.notNil = exports.findChunks = exports.makePlaceholder = exports.computeIntegrity = exports.placeholderPrefix = exports.normalizePath = exports.getTagSrc = exports.assert = exports.sriHashVariableReference = void 0;\nconst crypto_1 = require(\"crypto\");\nconst path_1 = require(\"path\");\nexports.sriHashVariableReference = \"__webpack_require__.sriHashes\";\nfunction assert(value, message) {\n  if (!value) {\n    throw new Error(message);\n  }\n}\nexports.assert = assert;\nfunction getTagSrc(tag) {\n  if (![\"script\", \"link\"].includes(tag.tagName) || !tag.attributes) {\n    return undefined;\n  }\n  if (typeof tag.attributes.href === \"string\") {\n    return tag.attributes.href;\n  }\n  if (typeof tag.attributes.src === \"string\") {\n    return tag.attributes.src;\n  }\n  return undefined;\n}\nexports.getTagSrc = getTagSrc;\nconst normalizePath = p => p.replace(/\\?.*$/, \"\").split(path_1.sep).join(\"/\");\nexports.normalizePath = normalizePath;\nexports.placeholderPrefix = \"*-*-*-CHUNK-SRI-HASH-\";\nconst computeIntegrity = (hashFuncNames, source) => {\n  const result = hashFuncNames.map(hashFuncName => hashFuncName + \"-\" + crypto_1.createHash(hashFuncName).update(typeof source === \"string\" ? Buffer.from(source, \"utf-8\") : source).digest(\"base64\")).join(\" \");\n  return result;\n};\nexports.computeIntegrity = computeIntegrity;\nconst makePlaceholder = (hashFuncNames, id) => {\n  const placeholder = `${exports.placeholderPrefix}${id}`;\n  const filler = exports.computeIntegrity(hashFuncNames, placeholder);\n  return exports.placeholderPrefix + filler.substring(exports.placeholderPrefix.length);\n};\nexports.makePlaceholder = makePlaceholder;\nfunction findChunks(chunk) {\n  const allChunks = new Set();\n  const groupsVisited = new Set();\n  function addIfNotExist(set, item) {\n    if (set.has(item)) return true;\n    set.add(item);\n    return false;\n  }\n  (function recurseChunk(childChunk) {\n    function recurseGroup(group) {\n      if (addIfNotExist(groupsVisited, group.id)) return;\n      group.chunks.forEach(recurseChunk);\n      group.childrenIterable.forEach(recurseGroup);\n    }\n    if (addIfNotExist(allChunks, childChunk)) return;\n    Array.from(childChunk.groupsIterable).forEach(recurseGroup);\n  })(chunk);\n  return allChunks;\n}\nexports.findChunks = findChunks;\nfunction notNil(value) {\n  return value !== null && value !== undefined;\n}\nexports.notNil = notNil;\nfunction generateSriHashPlaceholders(chunks, hashFuncNames) {\n  return Array.from(chunks).reduce((sriHashes, depChunk) => {\n    if (depChunk.id) {\n      sriHashes[depChunk.id] = exports.makePlaceholder(hashFuncNames, depChunk.id);\n    }\n    return sriHashes;\n  }, {});\n}\nexports.generateSriHashPlaceholders = generateSriHashPlaceholders;\nfunction* intersect(sets) {\n  const {\n    value: initialSet\n  } = sets[Symbol.iterator]().next();\n  if (!initialSet) {\n    return;\n  }\n  initialSetLoop: for (const item of initialSet) {\n    for (const set of sets) {\n      if (!set.has(item)) {\n        continue initialSetLoop;\n      }\n    }\n    yield item;\n  }\n}\nfunction* map(items, fn) {\n  for (const item of items) {\n    yield fn(item);\n  }\n}\nfunction* flatMap(collections, fn) {\n  for (const item of collections) {\n    for (const result of fn(item)) {\n      yield result;\n    }\n  }\n}\n/**\n * Tarjan's strongly connected components algorithm\n * https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n */\nfunction createDAGfromGraph({\n  vertices,\n  edges\n}) {\n  var _a;\n  let index = 0;\n  const stack = [];\n  const vertexMetadata = new Map(map(vertices, vertex => [vertex, {}]));\n  const stronglyConnectedComponents = new Set();\n  function strongConnect(vertex) {\n    var _a, _b;\n    // Set the depth index for v to the smallest unused index\n    const vertexData = vertexMetadata.get(vertex);\n    assert(vertexData, \"Vertex metadata missing\");\n    vertexData.index = index;\n    vertexData.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertexData.onstack = true;\n    for (const child of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n      const childData = vertexMetadata.get(child);\n      assert(childData, \"Child vertex metadata missing\");\n      if (childData.index === undefined) {\n        // Child has not yet been visited; recurse on it\n        strongConnect(child);\n        vertexData.lowlink = Math.min(vertexData.lowlink, (_b = childData.lowlink) !== null && _b !== void 0 ? _b : Infinity);\n      } else if (childData.onstack) {\n        // Child is in stack and hence in the current SCC\n        // If child is not on stack, then (vertex, child) is an edge pointing to an SCC already found and must be ignored\n        // Note: The next line may look odd - but is correct.\n        // It says childData.index not childData.lowlink; that is deliberate and from the original paper\n        vertexData.lowlink = Math.min(vertexData.lowlink, childData.index);\n      }\n    }\n    // If vertex is a root node, pop the stack and generate an SCC\n    if (vertexData.index === vertexData.lowlink) {\n      const newStronglyConnectedComponent = {\n        nodes: new Set()\n      };\n      let currentNode;\n      do {\n        currentNode = stack.pop();\n        assert(currentNode, \"Working stack was empty\");\n        const metadata = vertexMetadata.get(currentNode);\n        assert(metadata, \"All nodes on stack should have metadata\");\n        metadata.onstack = false;\n        newStronglyConnectedComponent.nodes.add(currentNode);\n      } while (currentNode !== vertex);\n      stronglyConnectedComponents.add(newStronglyConnectedComponent);\n    }\n  }\n  for (const vertex of vertices) {\n    const data = vertexMetadata.get(vertex);\n    assert(data, \"Vertex metadata not found\");\n    if (data.index === undefined) {\n      strongConnect(vertex);\n    }\n  }\n  // Now that all SCCs have been identified, rebuild the graph\n  const vertexToSCCMap = new Map();\n  const sccEdges = new Map();\n  for (const scc of stronglyConnectedComponents) {\n    for (const vertex of scc.nodes) {\n      vertexToSCCMap.set(vertex, scc);\n    }\n  }\n  for (const scc of stronglyConnectedComponents) {\n    const childSCCNodes = new Set();\n    for (const vertex of scc.nodes) {\n      for (const childVertex of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n        const childScc = vertexToSCCMap.get(childVertex);\n        if (childScc && childScc !== scc) {\n          childSCCNodes.add(childScc);\n        }\n      }\n    }\n    sccEdges.set(scc, childSCCNodes);\n  }\n  return {\n    vertices: stronglyConnectedComponents,\n    edges: sccEdges\n  };\n}\n// This implementation assumes a directed acyclic graph (such as one produced by createDAGfromGraph),\n// and does not attempt to detect cycles\nfunction topologicalSort({\n  vertices,\n  edges\n}) {\n  const sortedItems = [];\n  const seenNodes = new Set();\n  function visit(node) {\n    var _a;\n    if (seenNodes.has(node)) {\n      return;\n    }\n    seenNodes.add(node);\n    for (const child of (_a = edges.get(node)) !== null && _a !== void 0 ? _a : []) {\n      visit(child);\n    }\n    sortedItems.push(node);\n  }\n  for (const vertex of vertices) {\n    visit(vertex);\n  }\n  return sortedItems;\n}\nfunction buildTopologicallySortedChunkGraph(chunks) {\n  var _a;\n  const vertices = new Set();\n  const edges = new Map();\n  // Chunks should have *all* chunks, not simply entry chunks\n  for (const vertex of chunks) {\n    if (vertices.has(vertex)) {\n      continue;\n    }\n    vertices.add(vertex);\n    edges.set(vertex, new Set());\n    for (const vertexGroup of vertex.groupsIterable) {\n      for (const childGroup of vertexGroup.childrenIterable) {\n        for (const childChunk of childGroup.chunks) {\n          (_a = edges.get(vertex)) === null || _a === void 0 ? void 0 : _a.add(childChunk);\n        }\n      }\n    }\n  }\n  const dag = createDAGfromGraph({\n    vertices,\n    edges\n  });\n  const sortedVertices = topologicalSort(dag);\n  const chunkToSccMap = new Map(flatMap(dag.vertices, scc => map(scc.nodes, chunk => [chunk, scc])));\n  return [sortedVertices, dag, chunkToSccMap];\n}\nexports.buildTopologicallySortedChunkGraph = buildTopologicallySortedChunkGraph;\nfunction getChunkToManifestMap(chunks) {\n  var _a;\n  const [sortedVertices,, chunkToSccMap] = buildTopologicallySortedChunkGraph(chunks);\n  // This map tracks which hashes a chunk group has in its manifest and the intersection\n  // of all its parents (and intersection of all their parents, etc.)\n  // This is meant as a guarantee that the hash for a given chunk is handled by a chunk group\n  // or its parents regardless of the tree traversal used from the roots\n  const hashesByChunkGroupAndParents = new Map();\n  // A map of what child chunks a given chunk should contain hashes for\n  const chunkManifest = new Map();\n  function intersectSets(setsToIntersect) {\n    return new Set(intersect(setsToIntersect));\n  }\n  function findIntersectionOfParentSets(chunk) {\n    var _a;\n    const setsToIntersect = [];\n    for (const group of chunk.groupsIterable) {\n      for (const parent of group.parentsIterable) {\n        setsToIntersect.push((_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set());\n      }\n    }\n    return intersectSets(setsToIntersect);\n  }\n  function getChildChunksToAddToChunkManifest(chunk) {\n    var _a;\n    const childChunks = new Set();\n    const chunkSCC = chunkToSccMap.get(chunk);\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup.chunks[chunkGroup.chunks.length - 1] !== chunk) {\n        // Only add sri hashes for one chunk per chunk group,\n        // where the last chunk in the group is the primary chunk\n        continue;\n      }\n      for (const childGroup of chunkGroup.childrenIterable) {\n        for (const childChunk of childGroup.chunks) {\n          const childChunkSCC = chunkToSccMap.get(childChunk);\n          if (childChunkSCC === chunkSCC) {\n            // Don't include your own SCC.\n            // Your parent will have the hashes for your SCC siblings\n            continue;\n          }\n          for (const childChunkSccNode of (_a = childChunkSCC === null || childChunkSCC === void 0 ? void 0 : childChunkSCC.nodes) !== null && _a !== void 0 ? _a : []) {\n            childChunks.add(childChunkSccNode);\n          }\n        }\n      }\n    }\n    const parentManifest = findIntersectionOfParentSets(chunk);\n    for (const manifestEntry of parentManifest) {\n      childChunks.delete(manifestEntry);\n    }\n    return childChunks;\n  }\n  // We want to walk from the root nodes down to the leaves\n  for (let i = sortedVertices.length - 1; i >= 0; i--) {\n    const scc = sortedVertices[i];\n    for (const chunk of scc.nodes) {\n      const manifest = getChildChunksToAddToChunkManifest(chunk);\n      const combinedParentManifest = findIntersectionOfParentSets(chunk);\n      for (const chunk of manifest) {\n        if (combinedParentManifest.has(chunk)) {\n          manifest.delete(chunk);\n        } else {\n          combinedParentManifest.add(chunk);\n        }\n      }\n      chunkManifest.set(chunk, manifest);\n      for (const group of chunk.groupsIterable) {\n        // Get intersection of all parent manifests\n        const groupCombinedManifest = intersectSets(map(group.parentsIterable, parent => {\n          var _a;\n          return (_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set();\n        }));\n        // Add this chunk's manifest\n        for (const chunk of manifest) {\n          groupCombinedManifest.add(chunk);\n        }\n        // Add any existing manifests part of the group\n        for (const chunk of (_a = hashesByChunkGroupAndParents.get(group)) !== null && _a !== void 0 ? _a : new Set()) {\n          groupCombinedManifest.add(chunk);\n        }\n        hashesByChunkGroupAndParents.set(group, groupCombinedManifest);\n      }\n    }\n  }\n  return [sortedVertices, chunkManifest];\n}\nexports.getChunkToManifestMap = getChunkToManifestMap;","map":{"version":3,"names":["Object","defineProperty","exports","value","getChunkToManifestMap","buildTopologicallySortedChunkGraph","generateSriHashPlaceholders","notNil","findChunks","makePlaceholder","computeIntegrity","placeholderPrefix","normalizePath","getTagSrc","assert","sriHashVariableReference","crypto_1","require","path_1","message","Error","tag","includes","tagName","attributes","undefined","href","src","p","replace","split","sep","join","hashFuncNames","source","result","map","hashFuncName","createHash","update","Buffer","from","digest","id","placeholder","filler","substring","length","chunk","allChunks","Set","groupsVisited","addIfNotExist","set","item","has","add","recurseChunk","childChunk","recurseGroup","group","chunks","forEach","childrenIterable","Array","groupsIterable","reduce","sriHashes","depChunk","intersect","sets","initialSet","Symbol","iterator","next","initialSetLoop","items","fn","flatMap","collections","createDAGfromGraph","vertices","edges","_a","index","stack","vertexMetadata","Map","vertex","stronglyConnectedComponents","strongConnect","_b","vertexData","get","lowlink","push","onstack","child","childData","Math","min","Infinity","newStronglyConnectedComponent","nodes","currentNode","pop","metadata","data","vertexToSCCMap","sccEdges","scc","childSCCNodes","childVertex","childScc","topologicalSort","sortedItems","seenNodes","visit","node","vertexGroup","childGroup","dag","sortedVertices","chunkToSccMap","hashesByChunkGroupAndParents","chunkManifest","intersectSets","setsToIntersect","findIntersectionOfParentSets","parent","parentsIterable","getChildChunksToAddToChunkManifest","childChunks","chunkSCC","chunkGroup","childChunkSCC","childChunkSccNode","parentManifest","manifestEntry","delete","i","manifest","combinedParentManifest","groupCombinedManifest"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/webpack-subresource-integrity/util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2015-present, Waysact Pty Ltd\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getChunkToManifestMap = exports.buildTopologicallySortedChunkGraph = exports.generateSriHashPlaceholders = exports.notNil = exports.findChunks = exports.makePlaceholder = exports.computeIntegrity = exports.placeholderPrefix = exports.normalizePath = exports.getTagSrc = exports.assert = exports.sriHashVariableReference = void 0;\nconst crypto_1 = require(\"crypto\");\nconst path_1 = require(\"path\");\nexports.sriHashVariableReference = \"__webpack_require__.sriHashes\";\nfunction assert(value, message) {\n    if (!value) {\n        throw new Error(message);\n    }\n}\nexports.assert = assert;\nfunction getTagSrc(tag) {\n    if (![\"script\", \"link\"].includes(tag.tagName) || !tag.attributes) {\n        return undefined;\n    }\n    if (typeof tag.attributes.href === \"string\") {\n        return tag.attributes.href;\n    }\n    if (typeof tag.attributes.src === \"string\") {\n        return tag.attributes.src;\n    }\n    return undefined;\n}\nexports.getTagSrc = getTagSrc;\nconst normalizePath = (p) => p.replace(/\\?.*$/, \"\").split(path_1.sep).join(\"/\");\nexports.normalizePath = normalizePath;\nexports.placeholderPrefix = \"*-*-*-CHUNK-SRI-HASH-\";\nconst computeIntegrity = (hashFuncNames, source) => {\n    const result = hashFuncNames\n        .map((hashFuncName) => hashFuncName +\n        \"-\" +\n        crypto_1.createHash(hashFuncName)\n            .update(typeof source === \"string\" ? Buffer.from(source, \"utf-8\") : source)\n            .digest(\"base64\"))\n        .join(\" \");\n    return result;\n};\nexports.computeIntegrity = computeIntegrity;\nconst makePlaceholder = (hashFuncNames, id) => {\n    const placeholder = `${exports.placeholderPrefix}${id}`;\n    const filler = exports.computeIntegrity(hashFuncNames, placeholder);\n    return exports.placeholderPrefix + filler.substring(exports.placeholderPrefix.length);\n};\nexports.makePlaceholder = makePlaceholder;\nfunction findChunks(chunk) {\n    const allChunks = new Set();\n    const groupsVisited = new Set();\n    function addIfNotExist(set, item) {\n        if (set.has(item))\n            return true;\n        set.add(item);\n        return false;\n    }\n    (function recurseChunk(childChunk) {\n        function recurseGroup(group) {\n            if (addIfNotExist(groupsVisited, group.id))\n                return;\n            group.chunks.forEach(recurseChunk);\n            group.childrenIterable.forEach(recurseGroup);\n        }\n        if (addIfNotExist(allChunks, childChunk))\n            return;\n        Array.from(childChunk.groupsIterable).forEach(recurseGroup);\n    })(chunk);\n    return allChunks;\n}\nexports.findChunks = findChunks;\nfunction notNil(value) {\n    return value !== null && value !== undefined;\n}\nexports.notNil = notNil;\nfunction generateSriHashPlaceholders(chunks, hashFuncNames) {\n    return Array.from(chunks).reduce((sriHashes, depChunk) => {\n        if (depChunk.id) {\n            sriHashes[depChunk.id] = exports.makePlaceholder(hashFuncNames, depChunk.id);\n        }\n        return sriHashes;\n    }, {});\n}\nexports.generateSriHashPlaceholders = generateSriHashPlaceholders;\nfunction* intersect(sets) {\n    const { value: initialSet } = sets[Symbol.iterator]().next();\n    if (!initialSet) {\n        return;\n    }\n    initialSetLoop: for (const item of initialSet) {\n        for (const set of sets) {\n            if (!set.has(item)) {\n                continue initialSetLoop;\n            }\n        }\n        yield item;\n    }\n}\nfunction* map(items, fn) {\n    for (const item of items) {\n        yield fn(item);\n    }\n}\nfunction* flatMap(collections, fn) {\n    for (const item of collections) {\n        for (const result of fn(item)) {\n            yield result;\n        }\n    }\n}\n/**\n * Tarjan's strongly connected components algorithm\n * https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n */\nfunction createDAGfromGraph({ vertices, edges, }) {\n    var _a;\n    let index = 0;\n    const stack = [];\n    const vertexMetadata = new Map(map(vertices, (vertex) => [vertex, {}]));\n    const stronglyConnectedComponents = new Set();\n    function strongConnect(vertex) {\n        var _a, _b;\n        // Set the depth index for v to the smallest unused index\n        const vertexData = vertexMetadata.get(vertex);\n        assert(vertexData, \"Vertex metadata missing\");\n        vertexData.index = index;\n        vertexData.lowlink = index;\n        index++;\n        stack.push(vertex);\n        vertexData.onstack = true;\n        for (const child of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n            const childData = vertexMetadata.get(child);\n            assert(childData, \"Child vertex metadata missing\");\n            if (childData.index === undefined) {\n                // Child has not yet been visited; recurse on it\n                strongConnect(child);\n                vertexData.lowlink = Math.min(vertexData.lowlink, (_b = childData.lowlink) !== null && _b !== void 0 ? _b : Infinity);\n            }\n            else if (childData.onstack) {\n                // Child is in stack and hence in the current SCC\n                // If child is not on stack, then (vertex, child) is an edge pointing to an SCC already found and must be ignored\n                // Note: The next line may look odd - but is correct.\n                // It says childData.index not childData.lowlink; that is deliberate and from the original paper\n                vertexData.lowlink = Math.min(vertexData.lowlink, childData.index);\n            }\n        }\n        // If vertex is a root node, pop the stack and generate an SCC\n        if (vertexData.index === vertexData.lowlink) {\n            const newStronglyConnectedComponent = { nodes: new Set() };\n            let currentNode;\n            do {\n                currentNode = stack.pop();\n                assert(currentNode, \"Working stack was empty\");\n                const metadata = vertexMetadata.get(currentNode);\n                assert(metadata, \"All nodes on stack should have metadata\");\n                metadata.onstack = false;\n                newStronglyConnectedComponent.nodes.add(currentNode);\n            } while (currentNode !== vertex);\n            stronglyConnectedComponents.add(newStronglyConnectedComponent);\n        }\n    }\n    for (const vertex of vertices) {\n        const data = vertexMetadata.get(vertex);\n        assert(data, \"Vertex metadata not found\");\n        if (data.index === undefined) {\n            strongConnect(vertex);\n        }\n    }\n    // Now that all SCCs have been identified, rebuild the graph\n    const vertexToSCCMap = new Map();\n    const sccEdges = new Map();\n    for (const scc of stronglyConnectedComponents) {\n        for (const vertex of scc.nodes) {\n            vertexToSCCMap.set(vertex, scc);\n        }\n    }\n    for (const scc of stronglyConnectedComponents) {\n        const childSCCNodes = new Set();\n        for (const vertex of scc.nodes) {\n            for (const childVertex of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n                const childScc = vertexToSCCMap.get(childVertex);\n                if (childScc && childScc !== scc) {\n                    childSCCNodes.add(childScc);\n                }\n            }\n        }\n        sccEdges.set(scc, childSCCNodes);\n    }\n    return { vertices: stronglyConnectedComponents, edges: sccEdges };\n}\n// This implementation assumes a directed acyclic graph (such as one produced by createDAGfromGraph),\n// and does not attempt to detect cycles\nfunction topologicalSort({ vertices, edges }) {\n    const sortedItems = [];\n    const seenNodes = new Set();\n    function visit(node) {\n        var _a;\n        if (seenNodes.has(node)) {\n            return;\n        }\n        seenNodes.add(node);\n        for (const child of (_a = edges.get(node)) !== null && _a !== void 0 ? _a : []) {\n            visit(child);\n        }\n        sortedItems.push(node);\n    }\n    for (const vertex of vertices) {\n        visit(vertex);\n    }\n    return sortedItems;\n}\nfunction buildTopologicallySortedChunkGraph(chunks) {\n    var _a;\n    const vertices = new Set();\n    const edges = new Map();\n    // Chunks should have *all* chunks, not simply entry chunks\n    for (const vertex of chunks) {\n        if (vertices.has(vertex)) {\n            continue;\n        }\n        vertices.add(vertex);\n        edges.set(vertex, new Set());\n        for (const vertexGroup of vertex.groupsIterable) {\n            for (const childGroup of vertexGroup.childrenIterable) {\n                for (const childChunk of childGroup.chunks) {\n                    (_a = edges.get(vertex)) === null || _a === void 0 ? void 0 : _a.add(childChunk);\n                }\n            }\n        }\n    }\n    const dag = createDAGfromGraph({ vertices, edges });\n    const sortedVertices = topologicalSort(dag);\n    const chunkToSccMap = new Map(flatMap(dag.vertices, (scc) => map(scc.nodes, (chunk) => [chunk, scc])));\n    return [sortedVertices, dag, chunkToSccMap];\n}\nexports.buildTopologicallySortedChunkGraph = buildTopologicallySortedChunkGraph;\nfunction getChunkToManifestMap(chunks) {\n    var _a;\n    const [sortedVertices, , chunkToSccMap] = buildTopologicallySortedChunkGraph(chunks);\n    // This map tracks which hashes a chunk group has in its manifest and the intersection\n    // of all its parents (and intersection of all their parents, etc.)\n    // This is meant as a guarantee that the hash for a given chunk is handled by a chunk group\n    // or its parents regardless of the tree traversal used from the roots\n    const hashesByChunkGroupAndParents = new Map();\n    // A map of what child chunks a given chunk should contain hashes for\n    const chunkManifest = new Map();\n    function intersectSets(setsToIntersect) {\n        return new Set(intersect(setsToIntersect));\n    }\n    function findIntersectionOfParentSets(chunk) {\n        var _a;\n        const setsToIntersect = [];\n        for (const group of chunk.groupsIterable) {\n            for (const parent of group.parentsIterable) {\n                setsToIntersect.push((_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set());\n            }\n        }\n        return intersectSets(setsToIntersect);\n    }\n    function getChildChunksToAddToChunkManifest(chunk) {\n        var _a;\n        const childChunks = new Set();\n        const chunkSCC = chunkToSccMap.get(chunk);\n        for (const chunkGroup of chunk.groupsIterable) {\n            if (chunkGroup.chunks[chunkGroup.chunks.length - 1] !== chunk) {\n                // Only add sri hashes for one chunk per chunk group,\n                // where the last chunk in the group is the primary chunk\n                continue;\n            }\n            for (const childGroup of chunkGroup.childrenIterable) {\n                for (const childChunk of childGroup.chunks) {\n                    const childChunkSCC = chunkToSccMap.get(childChunk);\n                    if (childChunkSCC === chunkSCC) {\n                        // Don't include your own SCC.\n                        // Your parent will have the hashes for your SCC siblings\n                        continue;\n                    }\n                    for (const childChunkSccNode of (_a = childChunkSCC === null || childChunkSCC === void 0 ? void 0 : childChunkSCC.nodes) !== null && _a !== void 0 ? _a : []) {\n                        childChunks.add(childChunkSccNode);\n                    }\n                }\n            }\n        }\n        const parentManifest = findIntersectionOfParentSets(chunk);\n        for (const manifestEntry of parentManifest) {\n            childChunks.delete(manifestEntry);\n        }\n        return childChunks;\n    }\n    // We want to walk from the root nodes down to the leaves\n    for (let i = sortedVertices.length - 1; i >= 0; i--) {\n        const scc = sortedVertices[i];\n        for (const chunk of scc.nodes) {\n            const manifest = getChildChunksToAddToChunkManifest(chunk);\n            const combinedParentManifest = findIntersectionOfParentSets(chunk);\n            for (const chunk of manifest) {\n                if (combinedParentManifest.has(chunk)) {\n                    manifest.delete(chunk);\n                }\n                else {\n                    combinedParentManifest.add(chunk);\n                }\n            }\n            chunkManifest.set(chunk, manifest);\n            for (const group of chunk.groupsIterable) {\n                // Get intersection of all parent manifests\n                const groupCombinedManifest = intersectSets(map(group.parentsIterable, (parent) => { var _a; return (_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set(); }));\n                // Add this chunk's manifest\n                for (const chunk of manifest) {\n                    groupCombinedManifest.add(chunk);\n                }\n                // Add any existing manifests part of the group\n                for (const chunk of (_a = hashesByChunkGroupAndParents.get(group)) !== null && _a !== void 0 ? _a : new Set()) {\n                    groupCombinedManifest.add(chunk);\n                }\n                hashesByChunkGroupAndParents.set(group, groupCombinedManifest);\n            }\n        }\n    }\n    return [sortedVertices, chunkManifest];\n}\nexports.getChunkToManifestMap = getChunkToManifestMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}