{"ast":null,"code":"'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\nfunction flatMap(array, callback) {\n  const result = [];\n  array.forEach(item => {\n    const res = callback(item);\n    if (Array.isArray(res)) {\n      result.push.apply(result, res);\n    } else {\n      result.push(res);\n    }\n  });\n  return result;\n}\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g;\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove(\n// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A,\n// Line Feed <LF>\n0x000D,\n// Carriage Return <CR>\n0x2028,\n// Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n  return ESCAPE_SETS.REGULAR.get(character);\n};\nconst getUnicodeDotSet = dotAll => {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\nconst getUnicodePropertyValueSet = (property, value) => {\n  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;\n  try {\n    return require(`regenerate-unicode-properties/${path}.js`);\n  } catch (exception) {\n    throw new Error(`Failed to recognize value \\`${value}\\` for property ` + `\\`${property}\\`.`);\n  }\n};\nconst handleLoneUnicodePropertyNameOrValue = value => {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    const property = 'General_Category';\n    const category = unicodeMatchPropertyValue(property, value);\n    return getUnicodePropertyValueSet(property, category);\n  } catch (exception) {}\n  // It’s not a `General_Category` value, so check if it’s a property\n  // of strings.\n  try {\n    return getUnicodePropertyValueSet('Property_of_Strings', value);\n  } catch (exception) {}\n  // Lastly, check if it’s a binary property of single code points.\n  // Note: `unicodeMatchProperty` throws on invalid properties.\n  const property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n  const parts = value.split('=');\n  const firstPart = parts[0];\n  let set;\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    const property = unicodeMatchProperty(firstPart);\n    const value = unicodeMatchPropertyValue(property, parts[1]);\n    set = getUnicodePropertyValueSet(property, value);\n  }\n  if (isNegative) {\n    if (set.strings) {\n      throw new Error('Cannot negate Unicode property of strings');\n    }\n    return {\n      characters: UNICODE_SET.clone().remove(set.characters),\n      strings: new Set()\n    };\n  }\n  return {\n    characters: set.characters.clone(),\n    strings: set.strings\n    // We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n    ? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1'))) : new Set()\n  };\n};\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n  const set = getUnicodePropertyEscapeSet(property, isNegative);\n  const data = getCharacterClassEmptyData();\n  data.singleChars = set.characters;\n  if (set.strings.size > 0) {\n    data.longStrings = set.strings;\n    data.maybeIncludesStrings = true;\n  }\n  return data;\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function (min, max) {\n  const $this = this;\n  do {\n    const folded = caseFold(min);\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n  return $this;\n};\nregenerate.prototype.iuRemoveRange = function (min, max) {\n  const $this = this;\n  do {\n    const folded = caseFold(min);\n    if (folded) {\n      $this.remove(folded);\n    }\n  } while (++min <= max);\n  return $this;\n};\nconst update = (item, pattern) => {\n  let tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n  Object.assign(item, tree);\n};\nconst wrap = (tree, pattern) => {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': `(?:${pattern})`\n  };\n};\nconst caseFold = codePoint => {\n  return iuMappings.get(codePoint) || false;\n};\nconst buildHandler = action => {\n  switch (action) {\n    case 'union':\n      return {\n        single: (data, cp) => {\n          data.singleChars.add(cp);\n        },\n        regSet: (data, set2) => {\n          data.singleChars.add(set2);\n        },\n        range: (data, start, end) => {\n          data.singleChars.addRange(start, end);\n        },\n        iuRange: (data, start, end) => {\n          data.singleChars.iuAddRange(start, end);\n        },\n        nested: (data, nestedData) => {\n          data.singleChars.add(nestedData.singleChars);\n          for (const str of nestedData.longStrings) data.longStrings.add(str);\n          if (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n        }\n      };\n    case 'union-negative':\n      {\n        const regSet = (data, set2) => {\n          data.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n        };\n        return {\n          single: (data, cp) => {\n            const unicode = UNICODE_SET.clone();\n            data.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n          },\n          regSet: regSet,\n          range: (data, start, end) => {\n            data.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n          },\n          iuRange: (data, start, end) => {\n            data.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n          }\n        };\n      }\n    case 'intersection':\n      {\n        const regSet = (data, set2) => {\n          if (data.first) data.singleChars = set2;else data.singleChars.intersection(set2);\n        };\n        return {\n          single: (data, cp) => {\n            data.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          regSet: (data, set) => {\n            regSet(data, set);\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          range: (data, start, end) => {\n            if (data.first) data.singleChars.addRange(start, end);else data.singleChars.intersection(regenerate().addRange(start, end));\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          iuRange: (data, start, end) => {\n            if (data.first) data.singleChars.iuAddRange(start, end);else data.singleChars.intersection(regenerate().iuAddRange(start, end));\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (data.first) {\n              data.longStrings = nestedData.longStrings;\n              data.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n            } else {\n              for (const str of data.longStrings) {\n                if (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n              }\n              if (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n            }\n          }\n        };\n      }\n    case 'subtraction':\n      {\n        const regSet = (data, set2) => {\n          if (data.first) data.singleChars.add(set2);else data.singleChars.remove(set2);\n        };\n        return {\n          single: (data, cp) => {\n            if (data.first) data.singleChars.add(cp);else data.singleChars.remove(cp);\n          },\n          regSet: regSet,\n          range: (data, start, end) => {\n            if (data.first) data.singleChars.addRange(start, end);else data.singleChars.removeRange(start, end);\n          },\n          iuRange: (data, start, end) => {\n            if (data.first) data.singleChars.iuAddRange(start, end);else data.singleChars.iuRemoveRange(start, end);\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (data.first) {\n              data.longStrings = nestedData.longStrings;\n              data.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n            } else {\n              for (const str of data.longStrings) {\n                if (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n              }\n            }\n          }\n        };\n      }\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown set action: ${characterClassItem.kind}`);\n  }\n};\nconst getCharacterClassEmptyData = () => ({\n  transformed: config.transform.unicodeFlag,\n  singleChars: regenerate(),\n  longStrings: new Set(),\n  hasEmptyString: false,\n  first: true,\n  maybeIncludesStrings: false\n});\nconst maybeFold = codePoint => {\n  if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n    const folded = caseFold(codePoint);\n    if (folded) {\n      return [codePoint, folded];\n    }\n  }\n  return [codePoint];\n};\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n  let data = getCharacterClassEmptyData();\n  for (const string of classStrings.strings) {\n    if (string.characters.length === 1) {\n      maybeFold(string.characters[0].codePoint).forEach(cp => {\n        data.singleChars.add(cp);\n      });\n    } else {\n      let stringifiedString;\n      if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n        stringifiedString = '';\n        for (const ch of string.characters) {\n          let set = regenerate(ch.codePoint);\n          const folded = caseFold(ch.codePoint);\n          if (folded) set.add(folded);\n          stringifiedString += set.toString(regenerateOptions);\n        }\n      } else {\n        stringifiedString = string.characters.map(ch => generate(ch)).join('');\n      }\n      data.longStrings.add(stringifiedString);\n      data.maybeIncludesStrings = true;\n    }\n  }\n  return data;\n};\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n  let data = getCharacterClassEmptyData();\n  let handlePositive;\n  let handleNegative;\n  switch (characterClassItem.kind) {\n    case 'union':\n      handlePositive = buildHandler('union');\n      handleNegative = buildHandler('union-negative');\n      break;\n    case 'intersection':\n      handlePositive = buildHandler('intersection');\n      handleNegative = buildHandler('subtraction');\n      break;\n    case 'subtraction':\n      handlePositive = buildHandler('subtraction');\n      handleNegative = buildHandler('intersection');\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown character class kind: ${characterClassItem.kind}`);\n  }\n  for (const item of characterClassItem.body) {\n    switch (item.type) {\n      case 'value':\n        maybeFold(item.codePoint).forEach(cp => {\n          handlePositive.single(data, cp);\n        });\n        break;\n      case 'characterClassRange':\n        const min = item.min.codePoint;\n        const max = item.max.codePoint;\n        handlePositive.range(data, min, max);\n        if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n          handlePositive.iuRange(data, min, max);\n        }\n        break;\n      case 'characterClassEscape':\n        handlePositive.regSet(data, getCharacterClassEscapeSet(item.value, config.flags.unicode, config.flags.ignoreCase));\n        break;\n      case 'unicodePropertyEscape':\n        const nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n        handlePositive.nested(data, nestedData);\n        data.transformed = data.transformed || config.transform.unicodePropertyEscapes || config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings;\n        break;\n      case 'characterClass':\n        const handler = item.negative ? handleNegative : handlePositive;\n        const res = computeCharacterClass(item, regenerateOptions);\n        handler.nested(data, res);\n        data.transformed = true;\n        break;\n      case 'classStrings':\n        handlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n        data.transformed = true;\n        break;\n      // The `default` clause is only here as a safeguard; it should never be\n      // reached. Code coverage tools should ignore it.\n      /* istanbul ignore next */\n      default:\n        throw new Error(`Unknown term type: ${item.type}`);\n    }\n    data.first = false;\n  }\n  if (characterClassItem.negative && data.maybeIncludesStrings) {\n    throw new SyntaxError('Cannot negate set containing strings');\n  }\n  return data;\n};\nconst processCharacterClass = (characterClassItem, regenerateOptions, computed = computeCharacterClass(characterClassItem, regenerateOptions)) => {\n  const negative = characterClassItem.negative;\n  const {\n    singleChars,\n    transformed,\n    longStrings\n  } = computed;\n  if (transformed) {\n    const setStr = singleChars.toString(regenerateOptions);\n    if (negative) {\n      if (config.useUnicodeFlag) {\n        update(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`);\n      } else {\n        update(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`);\n      }\n    } else {\n      const hasEmptyString = longStrings.has('');\n      const pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n      if (setStr !== '[]' || longStrings.size === 0) {\n        pieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n      }\n      update(characterClassItem, pieces.join('|'));\n    }\n  }\n  return characterClassItem;\n};\nconst assertNoUnmatchedReferences = groups => {\n  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n  }\n};\nconst processTerm = (item, regenerateOptions, groups) => {\n  switch (item.type) {\n    case 'dot':\n      if (config.transform.unicodeFlag) {\n        update(item, getUnicodeDotSet(config.flags.dotAll).toString(regenerateOptions));\n      } else if (config.transform.dotAllFlag) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n      break;\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n    case 'unicodePropertyEscape':\n      const data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n      if (data.maybeIncludesStrings) {\n        if (!config.flags.unicodeSets) {\n          throw new Error('Properties of strings are only supported when using the unicodeSets (v) flag.');\n        }\n        if (config.transform.unicodeSetsFlag) {\n          data.transformed = true;\n          item = processCharacterClass(item, regenerateOptions, data);\n        }\n      } else if (config.transform.unicodePropertyEscapes) {\n        update(item, data.singleChars.toString(regenerateOptions));\n      }\n      break;\n    case 'characterClassEscape':\n      if (config.transform.unicodeFlag) {\n        update(item, getCharacterClassEscapeSet(item.value, /* config.transform.unicodeFlag implies config.flags.unicode */true, config.flags.ignoreCase).toString(regenerateOptions));\n      }\n      break;\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n      if (item.name) {\n        const name = item.name.value;\n        if (groups.namesConflicts[name]) {\n          throw new Error(`Group '${name}' has already been defined in this context.`);\n        }\n        groups.namesConflicts[name] = true;\n        if (config.transform.namedGroups) {\n          delete item.name;\n        }\n        const index = groups.lastIndex;\n        if (!groups.names[name]) {\n          groups.names[name] = [];\n        }\n        groups.names[name].push(index);\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n        if (groups.unmatchedReferences[name]) {\n          delete groups.unmatchedReferences[name];\n        }\n      }\n    /* falls through */\n    case 'quantifier':\n      item.body = item.body.map(term => {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n    case 'disjunction':\n      const outerNamesConflicts = groups.namesConflicts;\n      item.body = item.body.map(term => {\n        groups.namesConflicts = Object.create(outerNamesConflicts);\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n    case 'alternative':\n      item.body = flatMap(item.body, term => {\n        const res = processTerm(term, regenerateOptions, groups);\n        // Alternatives cannot contain alternatives; flatten them.\n        return res.type === 'alternative' ? res.body : res;\n      });\n      break;\n    case 'value':\n      const codePoint = item.codePoint;\n      const set = regenerate(codePoint);\n      if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n        const folded = caseFold(codePoint);\n        if (folded) {\n          set.add(folded);\n        }\n      }\n      update(item, set.toString(regenerateOptions));\n      break;\n    case 'reference':\n      if (item.name) {\n        const name = item.name.value;\n        const indexes = groups.names[name];\n        if (!indexes) {\n          groups.unmatchedReferences[name] = true;\n        }\n        if (config.transform.namedGroups) {\n          if (indexes) {\n            const body = indexes.map(index => ({\n              'type': 'reference',\n              'matchIndex': index,\n              'raw': '\\\\' + index\n            }));\n            if (body.length === 1) {\n              return body[0];\n            }\n            return {\n              'type': 'alternative',\n              'body': body,\n              'raw': body.map(term => term.raw).join('')\n            };\n          }\n\n          // This named reference comes before the group where it’s defined,\n          // so it’s always an empty match.\n          return {\n            'type': 'group',\n            'behavior': 'ignore',\n            'body': [],\n            'raw': '(?:)'\n          };\n        }\n      }\n      break;\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown term type: ${item.type}`);\n  }\n  return item;\n};\nconst config = {\n  'flags': {\n    'ignoreCase': false,\n    'unicode': false,\n    'unicodeSets': false,\n    'dotAll': false\n  },\n  'transform': {\n    'dotAllFlag': false,\n    'unicodeFlag': false,\n    'unicodeSetsFlag': false,\n    'unicodePropertyEscapes': false,\n    'namedGroups': false\n  },\n  get useUnicodeFlag() {\n    return (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n  }\n};\nconst validateOptions = options => {\n  if (!options) return;\n  for (const key of Object.keys(options)) {\n    const value = options[key];\n    switch (key) {\n      case 'dotAllFlag':\n      case 'unicodeFlag':\n      case 'unicodePropertyEscapes':\n      case 'namedGroups':\n        if (value != null && value !== false && value !== 'transform') {\n          throw new Error(`.${key} must be false (default) or 'transform'.`);\n        }\n        break;\n      case 'unicodeSetsFlag':\n        if (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n          throw new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n        }\n        break;\n      case 'onNamedGroup':\n        if (value != null && typeof value !== 'function') {\n          throw new Error('.onNamedGroup must be a function.');\n        }\n        break;\n      default:\n        throw new Error(`.${key} is not a valid regexpu-core option.`);\n    }\n  }\n};\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\nconst rewritePattern = (pattern, flags, options) => {\n  validateOptions(options);\n  config.flags.unicode = hasFlag(flags, 'u');\n  config.flags.unicodeSets = hasFlag(flags, 'v');\n  config.flags.ignoreCase = hasFlag(flags, 'i');\n  config.flags.dotAll = hasFlag(flags, 's');\n  config.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n  config.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n  config.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag');\n\n  // unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n  config.transform.unicodePropertyEscapes = config.flags.unicode && (transform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes'));\n  config.transform.namedGroups = transform(options, 'namedGroups');\n  const regjsparserFeatures = {\n    'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n    // Enable every stable RegExp feature by default\n    'unicodePropertyEscape': true,\n    'namedGroups': true,\n    'lookbehind': true\n  };\n  const regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.flags.unicode\n  };\n  const groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: Array<index> }\n    'namesConflicts': Object.create(null),\n    // { [name]: true }\n    'unmatchedReferences': Object.create(null) // { [name]: true }\n  };\n\n  const tree = parse(pattern, flags, regjsparserFeatures);\n  // Note: `processTerm` mutates `tree` and `groups`.\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","flatMap","array","callback","result","forEach","item","res","Array","isArray","push","apply","SPECIAL_CHARS","UNICODE_SET","addRange","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","strings","characters","Set","map","str","replace","getUnicodePropertyEscapeCharacterClassData","data","getCharacterClassEmptyData","singleChars","size","longStrings","maybeIncludesStrings","prototype","iuAddRange","min","max","$this","folded","caseFold","add","iuRemoveRange","update","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","buildHandler","action","single","cp","regSet","set2","range","start","end","iuRange","nested","nestedData","contains","removeRange","first","intersection","clear","has","delete","characterClassItem","kind","transformed","transform","unicodeFlag","hasEmptyString","maybeFold","flags","computeClassStrings","classStrings","regenerateOptions","string","stringifiedString","ch","toString","join","computeCharacterClass","handlePositive","handleNegative","body","negative","unicodePropertyEscapes","unicodeSetsFlag","handler","SyntaxError","processCharacterClass","computed","setStr","slice","pieces","from","sort","a","b","splice","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","dotAllFlag","unicodeSets","behavior","lastIndex","name","namesConflicts","namedGroups","index","names","onNamedGroup","call","term","outerNamesConflicts","create","indexes","raw","validateOptions","options","key","hasFlag","flag","includes","rewritePattern","regjsparserFeatures","Boolean","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\nfunction flatMap(array, callback) {\n\tconst result = [];\n\tarray.forEach(item => {\n\t\tconst res = callback(item);\n\t\tif (Array.isArray(res)) {\n\t\t\tresult.push.apply(result, res);\n\t\t} else {\n\t\t\tresult.push(res);\n\t\t}\n\t});\n\treturn result;\n}\n\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g;\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a property\n\t// of strings.\n\ttry {\n\t\treturn getUnicodePropertyValueSet('Property_of_Strings', value);\n\t} catch (exception) {}\n\t// Lastly, check if it’s a binary property of single code points.\n\t// Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\tif (set.strings) {\n\t\t\tthrow new Error('Cannot negate Unicode property of strings');\n\t\t}\n\t\treturn {\n\t\t\tcharacters: UNICODE_SET.clone().remove(set.characters),\n\t\t\tstrings: new Set()\n\t\t};\n\t}\n\treturn {\n\t\tcharacters: set.characters.clone(),\n\t\tstrings: set.strings\n\t\t\t// We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n\t\t\t? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1')))\n\t\t\t: new Set()\n\t};\n};\n\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n\tconst set = getUnicodePropertyEscapeSet(property, isNegative);\n\tconst data = getCharacterClassEmptyData();\n\tdata.singleChars = set.characters;\n\tif (set.strings.size > 0) {\n\t\tdata.longStrings = set.strings;\n\t\tdata.maybeIncludesStrings = true;\n\t}\n\treturn data;\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\nregenerate.prototype.iuRemoveRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.remove(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst buildHandler = (action) => {\n\tswitch (action) {\n\t\tcase 'union':\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars.add(cp);\n\t\t\t\t},\n\t\t\t\tregSet: (data, set2) => {\n\t\t\t\t\tdata.singleChars.add(set2);\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.addRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.iuAddRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tdata.singleChars.add(nestedData.singleChars);\n\t\t\t\t\tfor (const str of nestedData.longStrings) data.longStrings.add(str);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n\t\t\t\t}\n\t\t\t};\n\t\tcase 'union-negative': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tdata.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tconst unicode = UNICODE_SET.clone();\n\t\t\t\t\tdata.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'intersection': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars = set2;\n\t\t\t\telse data.singleChars.intersection(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tregSet: (data, set) => {\n\t\t\t\t\tregSet(data, set);\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().addRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().iuAddRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'subtraction': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars.add(set2);\n\t\t\t\telse data.singleChars.remove(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tif (data.first) data.singleChars.add(cp);\n\t\t\t\t\telse data.singleChars.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.removeRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.iuRemoveRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown set action: ${ characterClassItem.kind }`);\n\t}\n};\n\nconst getCharacterClassEmptyData = () => ({\n\ttransformed: config.transform.unicodeFlag,\n\tsingleChars: regenerate(),\n\tlongStrings: new Set(),\n\thasEmptyString: false,\n\tfirst: true,\n\tmaybeIncludesStrings: false\n});\n\nconst maybeFold = (codePoint) => {\n\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\tconst folded = caseFold(codePoint);\n\t\tif (folded) {\n\t\t\treturn [codePoint, folded];\n\t\t}\n\t}\n\treturn [codePoint];\n};\n\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tfor (const string of classStrings.strings) {\n\t\tif (string.characters.length === 1) {\n\t\t\tmaybeFold(string.characters[0].codePoint).forEach((cp) => {\n\t\t\t\tdata.singleChars.add(cp);\n\t\t\t});\n\t\t} else {\n\t\t\tlet stringifiedString;\n\t\t\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\t\t\tstringifiedString = '';\n\t\t\t\tfor (const ch of string.characters) {\n\t\t\t\t\tlet set = regenerate(ch.codePoint);\n\t\t\t\t\tconst folded = caseFold(ch.codePoint);\n\t\t\t\t\tif (folded) set.add(folded);\n\t\t\t\t\tstringifiedString += set.toString(regenerateOptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstringifiedString = string.characters.map(ch => generate(ch)).join('')\n\t\t\t}\n\n\t\t\tdata.longStrings.add(stringifiedString);\n\t\t\tdata.maybeIncludesStrings = true;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tlet handlePositive;\n\tlet handleNegative;\n\n\tswitch (characterClassItem.kind) {\n\t\tcase 'union':\n\t\t\thandlePositive = buildHandler('union');\n\t\t\thandleNegative = buildHandler('union-negative');\n\t\t\tbreak;\n\t\tcase 'intersection':\n\t\t\thandlePositive = buildHandler('intersection');\n\t\t\thandleNegative = buildHandler('subtraction');\n\t\t\tbreak;\n\t\tcase 'subtraction':\n\t\t\thandlePositive = buildHandler('subtraction');\n\t\t\thandleNegative = buildHandler('intersection');\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown character class kind: ${ characterClassItem.kind }`);\n\t}\n\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tmaybeFold(item.codePoint).forEach((cp) => {\n\t\t\t\t\thandlePositive.single(data, cp);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\thandlePositive.range(data, min, max);\n\t\t\t\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\t\t\t\thandlePositive.iuRange(data, min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\thandlePositive.regSet(data, getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.flags.unicode,\n\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tconst nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\t\thandlePositive.nested(data, nestedData);\n\t\t\t\tdata.transformed =\n\t\t\t\t\tdata.transformed ||\n\t\t\t\t\tconfig.transform.unicodePropertyEscapes ||\n\t\t\t\t\t(config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings);\n\t\t\t\tbreak;\n\t\t\tcase 'characterClass':\n\t\t\t\tconst handler = item.negative ? handleNegative : handlePositive;\n\t\t\t\tconst res = computeCharacterClass(item, regenerateOptions);\n\t\t\t\thandler.nested(data, res);\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\tcase 'classStrings':\n\t\t\t\thandlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\n\t\tdata.first = false;\n\t}\n\n\tif (characterClassItem.negative && data.maybeIncludesStrings) {\n\t\tthrow new SyntaxError('Cannot negate set containing strings');\n\t}\n\n\treturn data;\n}\n\nconst processCharacterClass = (\n\tcharacterClassItem,\n\tregenerateOptions,\n\tcomputed = computeCharacterClass(characterClassItem, regenerateOptions)\n) => {\n\tconst negative = characterClassItem.negative;\n\tconst { singleChars, transformed, longStrings } = computed;\n\tif (transformed) {\n\t\tconst setStr = singleChars.toString(regenerateOptions);\n\n\t\tif (negative) {\n\t\t\tif (config.useUnicodeFlag) {\n\t\t\t\tupdate(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`)\n\t\t\t} else {\n\t\t\t\tupdate(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`)\n\t\t\t}\n\t\t} else {\n\t\t\tconst hasEmptyString = longStrings.has('');\n\t\t\tconst pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n\n\t\t\tif (setStr !== '[]' || longStrings.size === 0) {\n\t\t\t\tpieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n\t\t\t}\n\n\t\t\tupdate(characterClassItem, pieces.join('|'));\n\t\t}\n\t}\n\treturn characterClassItem;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.flags.dotAll).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.transform.dotAllFlag) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tconst data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\tif (data.maybeIncludesStrings) {\n\t\t\t\tif (!config.flags.unicodeSets) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Properties of strings are only supported when using the unicodeSets (v) flag.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (config.transform.unicodeSetsFlag) {\n\t\t\t\t\tdata.transformed = true;\n\t\t\t\t\titem = processCharacterClass(item, regenerateOptions, data);\n\t\t\t\t}\n\t\t\t} else if (config.transform.unicodePropertyEscapes) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tdata.singleChars.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t/* config.transform.unicodeFlag implies config.flags.unicode */ true,\n\t\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t\t).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.namesConflicts[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Group '${ name }' has already been defined in this context.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tgroups.namesConflicts[name] = true;\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tdelete item.name;\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tif (!groups.names[name]) {\n\t\t\t\t\tgroups.names[name] = [];\n\t\t\t\t}\n\t\t\t\tgroups.names[name].push(index);\n\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'disjunction':\n\t\t\tconst outerNamesConflicts = groups.namesConflicts;\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\tgroups.namesConflicts = Object.create(outerNamesConflicts);\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'alternative':\n\t\t\titem.body = flatMap(item.body, term => {\n\t\t\t\tconst res = processTerm(term, regenerateOptions, groups);\n\t\t\t\t// Alternatives cannot contain alternatives; flatten them.\n\t\t\t\treturn res.type === 'alternative' ? res.body : res;\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst indexes = groups.names[name];\n\t\t\t\tif (!indexes) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = true;\n\t\t\t\t}\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tif (indexes) {\n\t\t\t\t\t\tconst body = indexes.map(index => ({\n\t\t\t\t\t\t\t'type': 'reference',\n\t\t\t\t\t\t\t'matchIndex': index,\n\t\t\t\t\t\t\t'raw': '\\\\' + index,\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (body.length === 1) {\n\t\t\t\t\t\t\treturn body[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t'type': 'alternative',\n\t\t\t\t\t\t\t'body': body,\n\t\t\t\t\t\t\t'raw': body.map(term => term.raw).join(''),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// This named reference comes before the group where it’s defined,\n\t\t\t\t\t// so it’s always an empty match.\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'type': 'group',\n\t\t\t\t\t\t'behavior': 'ignore',\n\t\t\t\t\t\t'body': [],\n\t\t\t\t\t\t'raw': '(?:)',\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'flags': {\n\t\t'ignoreCase': false,\n\t\t'unicode': false,\n\t\t'unicodeSets': false,\n\t\t'dotAll': false,\n\t},\n\t'transform': {\n\t\t'dotAllFlag': false,\n\t\t'unicodeFlag': false,\n\t\t'unicodeSetsFlag': false,\n\t\t'unicodePropertyEscapes': false,\n\t\t'namedGroups': false,\n\t},\n\tget useUnicodeFlag() {\n\t\treturn (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n\t}\n};\n\nconst validateOptions = (options) => {\n\tif (!options) return;\n\n\tfor (const key of Object.keys(options)) {\n\t\tconst value = options[key];\n\t\tswitch (key) {\n\t\t\tcase 'dotAllFlag':\n\t\t\tcase 'unicodeFlag':\n\t\t\tcase 'unicodePropertyEscapes':\n\t\t\tcase 'namedGroups':\n\t\t\t\tif (value != null && value !== false && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default) or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'unicodeSetsFlag':\n\t\t\t\tif (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'onNamedGroup':\n\t\t\t\tif (value != null && typeof value !== 'function') {\n\t\t\t\t\tthrow new Error('.onNamedGroup must be a function.');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`.${key} is not a valid regexpu-core option.`);\n\t\t}\n\t}\n};\n\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\n\nconst rewritePattern = (pattern, flags, options) => {\n\tvalidateOptions(options);\n\n\tconfig.flags.unicode = hasFlag(flags, 'u');\n\tconfig.flags.unicodeSets = hasFlag(flags, 'v');\n\tconfig.flags.ignoreCase = hasFlag(flags, 'i');\n\tconfig.flags.dotAll = hasFlag(flags, 's');\n\n\tconfig.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n\tconfig.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n\tconfig.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag');\n\n\t// unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n\tconfig.transform.unicodePropertyEscapes = config.flags.unicode && (\n\t\ttransform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes')\n\t);\n\tconfig.transform.namedGroups = transform(options, 'namedGroups');\n\n\tconst regjsparserFeatures = {\n\t\t'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n\n\t\t// Enable every stable RegExp feature by default\n\t\t'unicodePropertyEscape': true,\n\t\t'namedGroups': true,\n\t\t'lookbehind': true,\n\t};\n\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.flags.unicode\n\t};\n\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: Array<index> }\n\t\t'namesConflicts': Object.create(null), // { [name]: true }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: true }\n\t};\n\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}