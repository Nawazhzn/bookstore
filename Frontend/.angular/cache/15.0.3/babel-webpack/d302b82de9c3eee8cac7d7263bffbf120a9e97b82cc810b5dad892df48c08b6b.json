{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst path = require(\"path\");\nconst {\n  validate\n} = require(\"schema-utils\");\nconst serialize = require(\"serialize-javascript\");\nconst normalizePath = require(\"normalize-path\");\nconst globParent = require(\"glob-parent\");\nconst fastGlob = require(\"fast-glob\"); // @ts-ignore\n\nconst {\n  version\n} = require(\"../package.json\");\nconst schema = require(\"./options.json\");\nconst {\n  readFile,\n  stat,\n  throttleAll\n} = require(\"./utils\");\nconst template = /\\[\\\\*([\\w:]+)\\\\*\\]/i;\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"globby\").Options} GlobbyOptions */\n\n/** @typedef {import(\"globby\").GlobEntry} GlobEntry */\n\n/** @typedef {ReturnType<Compilation[\"getLogger\"]>} WebpackLogger */\n\n/** @typedef {ReturnType<Compilation[\"getCache\"]>} CacheFacade */\n\n/** @typedef {ReturnType<ReturnType<Compilation[\"getCache\"]>[\"getLazyHashedEtag\"]>} Etag */\n\n/** @typedef {ReturnType<Compilation[\"fileSystemInfo\"][\"mergeSnapshots\"]>} Snapshot */\n\n/**\n * @typedef {boolean} Force\n */\n\n/**\n * @typedef {Object} CopiedResult\n * @property {string} sourceFilename\n * @property {string} absoluteFilename\n * @property {string} filename\n * @property {Asset[\"source\"]} source\n * @property {Force | undefined} force\n * @property {Record<string, any>} info\n */\n\n/**\n * @typedef {string} StringPattern\n */\n\n/**\n * @typedef {boolean} NoErrorOnMissing\n */\n\n/**\n * @typedef {string} Context\n */\n\n/**\n * @typedef {string} From\n */\n\n/**\n * @callback ToFunction\n * @param {{ context: string, absoluteFilename?: string }} pathData\n * @return {string | Promise<string>}\n */\n\n/**\n * @typedef {string | ToFunction} To\n */\n\n/**\n * @typedef {\"dir\" | \"file\" | \"template\"} ToType\n */\n\n/**\n * @callback TransformerFunction\n * @param {Buffer} input\n * @param {string} absoluteFilename\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject\n */\n\n/**\n * @typedef {Object} TransformerObject\n * @property {TransformerFunction} transformer\n * @property {boolean | TransformerCacheObject} [cache]\n */\n\n/**\n * @typedef {TransformerFunction | TransformerObject} Transform\n */\n\n/**\n * @callback Filter\n * @param {string} filepath\n * @returns {boolean | Promise<boolean>}\n */\n\n/**\n * @callback TransformAllFunction\n * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef { Record<string, any> | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => Record<string, any>) } Info\n */\n\n/**\n * @typedef {Object} ObjectPattern\n * @property {From} from\n * @property {GlobbyOptions} [globOptions]\n * @property {Context} [context]\n * @property {To} [to]\n * @property {ToType} [toType]\n * @property {Info} [info]\n * @property {Filter} [filter]\n * @property {Transform} [transform]\n * @property {TransformAllFunction} [transformAll]\n * @property {Force} [force]\n * @property {number} [priority]\n * @property {NoErrorOnMissing} [noErrorOnMissing]\n */\n\n/**\n * @typedef {StringPattern | ObjectPattern} Pattern\n */\n\n/**\n * @typedef {Object} AdditionalOptions\n * @property {number} [concurrency]\n */\n\n/**\n * @typedef {Object} PluginOptions\n * @property {Pattern[]} patterns\n * @property {AdditionalOptions} [options]\n */\n\nclass CopyPlugin {\n  /**\n   * @param {PluginOptions} [options]\n   */\n  constructor(options = {\n    patterns: []\n  }) {\n    validate( /** @type {Schema} */\n    schema, options, {\n      name: \"Copy Plugin\",\n      baseDataPath: \"options\"\n    });\n    /**\n     * @private\n     * @type {Pattern[]}\n     */\n\n    this.patterns = options.patterns;\n    /**\n     * @private\n     * @type {AdditionalOptions}\n     */\n\n    this.options = options.options || {};\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {number} startTime\n   * @param {string} dependency\n   * @returns {Promise<Snapshot | undefined>}\n   */\n\n  static createSnapshot(compilation, startTime, dependency) {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line consistent-return\n      return new Promise((resolve, reject) => {\n        compilation.fileSystemInfo.createSnapshot(startTime, [dependency],\n        // @ts-ignore\n        // eslint-disable-next-line no-undefined\n        undefined,\n        // eslint-disable-next-line no-undefined\n        undefined, null, (error, snapshot) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve( /** @type {Snapshot} */\n          snapshot);\n        });\n      });\n    })();\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {Snapshot} snapshot\n   * @returns {Promise<boolean | undefined>}\n   */\n\n  static checkSnapshotValid(compilation, snapshot) {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line consistent-return\n      return new Promise((resolve, reject) => {\n        compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(isValid);\n        });\n      });\n    })();\n  }\n  /**\n   * @private\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Buffer} source\n   * @returns {string}\n   */\n\n  static getContentHash(compiler, compilation, source) {\n    const {\n      outputOptions\n    } = compilation;\n    const {\n      hashDigest,\n      hashDigestLength,\n      hashFunction,\n      hashSalt\n    } = outputOptions;\n    const hash = compiler.webpack.util.createHash( /** @type {string} */\n    hashFunction);\n    if (hashSalt) {\n      hash.update(hashSalt);\n    }\n    hash.update(source);\n    const fullContentHash = hash.digest(hashDigest);\n    return fullContentHash.toString().slice(0, hashDigestLength);\n  }\n  /**\n   * @private\n   * @param {typeof import(\"globby\").globby} globby\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {WebpackLogger} logger\n   * @param {CacheFacade} cache\n   * @param {ObjectPattern & { context: string }} inputPattern\n   * @param {number} index\n   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}\n   */\n\n  static runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {\n    return _asyncToGenerator(function* () {\n      const {\n        RawSource\n      } = compiler.webpack.sources;\n      const pattern = {\n        ...inputPattern\n      };\n      const originalFrom = pattern.from;\n      const normalizedOriginalFrom = path.normalize(originalFrom);\n      logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);\n      let absoluteFrom;\n      if (path.isAbsolute(normalizedOriginalFrom)) {\n        absoluteFrom = normalizedOriginalFrom;\n      } else {\n        absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);\n      }\n      logger.debug(`getting stats for '${absoluteFrom}'...`);\n      const {\n        inputFileSystem\n      } = compiler;\n      let stats;\n      try {\n        stats = yield stat(inputFileSystem, absoluteFrom);\n      } catch (error) {// Nothing\n      }\n      /**\n       * @type {\"file\" | \"dir\" | \"glob\"}\n       */\n\n      let fromType;\n      if (stats) {\n        if (stats.isDirectory()) {\n          fromType = \"dir\";\n          logger.debug(`determined '${absoluteFrom}' is a directory`);\n        } else if (stats.isFile()) {\n          fromType = \"file\";\n          logger.debug(`determined '${absoluteFrom}' is a file`);\n        } else {\n          // Fallback\n          fromType = \"glob\";\n          logger.debug(`determined '${absoluteFrom}' is unknown`);\n        }\n      } else {\n        fromType = \"glob\";\n        logger.debug(`determined '${absoluteFrom}' is a glob`);\n      }\n      /** @type {GlobbyOptions & { objectMode: true }} */\n\n      const globOptions = {\n        ...{\n          followSymbolicLinks: true\n        },\n        ...(pattern.globOptions || {}),\n        ...{\n          cwd: pattern.context,\n          objectMode: true\n        }\n      }; // @ts-ignore\n\n      globOptions.fs = inputFileSystem;\n      let glob;\n      switch (fromType) {\n        case \"dir\":\n          compilation.contextDependencies.add(absoluteFrom);\n          logger.debug(`added '${absoluteFrom}' as a context dependency`);\n          pattern.context = absoluteFrom;\n          glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), \"**/*\");\n          absoluteFrom = path.join(absoluteFrom, \"**/*\");\n          if (typeof globOptions.dot === \"undefined\") {\n            globOptions.dot = true;\n          }\n          break;\n        case \"file\":\n          compilation.fileDependencies.add(absoluteFrom);\n          logger.debug(`added '${absoluteFrom}' as a file dependency`);\n          pattern.context = path.dirname(absoluteFrom);\n          glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));\n          if (typeof globOptions.dot === \"undefined\") {\n            globOptions.dot = true;\n          }\n          break;\n        case \"glob\":\n        default:\n          {\n            const contextDependencies = path.normalize(globParent(absoluteFrom));\n            compilation.contextDependencies.add(contextDependencies);\n            logger.debug(`added '${contextDependencies}' as a context dependency`);\n            glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);\n          }\n      }\n      logger.log(`begin globbing '${glob}'...`);\n      /**\n       * @type {GlobEntry[]}\n       */\n\n      let globEntries;\n      try {\n        globEntries = yield globby(glob, globOptions);\n      } catch (error) {\n        compilation.errors.push( /** @type {WebpackError} */\n        error);\n        return;\n      }\n      if (globEntries.length === 0) {\n        if (pattern.noErrorOnMissing) {\n          logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n          return;\n        }\n        const missingError = new Error(`unable to locate '${glob}' glob`);\n        compilation.errors.push( /** @type {WebpackError} */\n        missingError);\n        return;\n      }\n      /**\n       * @type {Array<CopiedResult | undefined>}\n       */\n\n      let copiedResult;\n      try {\n        copiedResult = yield Promise.all(globEntries.map(\n        /*#__PURE__*/\n        /**\n         * @param {GlobEntry} globEntry\n         * @returns {Promise<CopiedResult | undefined>}\n         */\n        function () {\n          var _ref = _asyncToGenerator(function* (globEntry) {\n            // Exclude directories\n            if (!globEntry.dirent.isFile()) {\n              return;\n            }\n            if (pattern.filter) {\n              let isFiltered;\n              try {\n                isFiltered = yield pattern.filter(globEntry.path);\n              } catch (error) {\n                compilation.errors.push( /** @type {WebpackError} */\n                error);\n                return;\n              }\n              if (!isFiltered) {\n                logger.log(`skip '${globEntry.path}', because it was filtered`);\n                return;\n              }\n            }\n            const from = globEntry.path;\n            logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows\n\n            const absoluteFilename = path.resolve(pattern.context, from);\n            const to = typeof pattern.to === \"function\" ? yield pattern.to({\n              context: pattern.context,\n              absoluteFilename\n            }) : path.normalize(typeof pattern.to !== \"undefined\" ? pattern.to : \"\");\n            const toType = pattern.toType ? pattern.toType : template.test(to) ? \"template\" : path.extname(to) === \"\" || to.slice(-1) === path.sep ? \"dir\" : \"file\";\n            logger.log(`'to' option '${to}' determinated as '${toType}'`);\n            const relativeFrom = path.relative(pattern.context, absoluteFilename);\n            let filename = toType === \"dir\" ? path.join(to, relativeFrom) : to;\n            if (path.isAbsolute(filename)) {\n              filename = path.relative( /** @type {string} */\n              compiler.options.output.path, filename);\n            }\n            logger.log(`determined that '${from}' should write to '${filename}'`);\n            const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies\n\n            if (fromType === \"dir\" || fromType === \"glob\") {\n              compilation.fileDependencies.add(absoluteFilename);\n              logger.debug(`added '${absoluteFilename}' as a file dependency`);\n            }\n            let cacheEntry;\n            logger.debug(`getting cache for '${absoluteFilename}'...`);\n            try {\n              cacheEntry = yield cache.getPromise(`${sourceFilename}|${index}`, null);\n            } catch (error) {\n              compilation.errors.push( /** @type {WebpackError} */\n              error);\n              return;\n            }\n            /**\n             * @type {Asset[\"source\"] | undefined}\n             */\n\n            let source;\n            if (cacheEntry) {\n              logger.debug(`found cache for '${absoluteFilename}'...`);\n              let isValidSnapshot;\n              logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);\n              try {\n                isValidSnapshot = yield CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);\n              } catch (error) {\n                compilation.errors.push( /** @type {WebpackError} */\n                error);\n                return;\n              }\n              if (isValidSnapshot) {\n                logger.debug(`snapshot for '${absoluteFilename}' is valid`);\n                ({\n                  source\n                } = cacheEntry);\n              } else {\n                logger.debug(`snapshot for '${absoluteFilename}' is invalid`);\n              }\n            } else {\n              logger.debug(`missed cache for '${absoluteFilename}'`);\n            }\n            if (!source) {\n              const startTime = Date.now();\n              logger.debug(`reading '${absoluteFilename}'...`);\n              let data;\n              try {\n                data = yield readFile(inputFileSystem, absoluteFilename);\n              } catch (error) {\n                compilation.errors.push( /** @type {WebpackError} */\n                error);\n                return;\n              }\n              logger.debug(`read '${absoluteFilename}'`);\n              source = new RawSource(data);\n              let snapshot;\n              logger.debug(`creating snapshot for '${absoluteFilename}'...`);\n              try {\n                snapshot = yield CopyPlugin.createSnapshot(compilation, startTime, absoluteFilename);\n              } catch (error) {\n                compilation.errors.push( /** @type {WebpackError} */\n                error);\n                return;\n              }\n              if (snapshot) {\n                logger.debug(`created snapshot for '${absoluteFilename}'`);\n                logger.debug(`storing cache for '${absoluteFilename}'...`);\n                try {\n                  yield cache.storePromise(`${sourceFilename}|${index}`, null, {\n                    source,\n                    snapshot\n                  });\n                } catch (error) {\n                  compilation.errors.push( /** @type {WebpackError} */\n                  error);\n                  return;\n                }\n                logger.debug(`stored cache for '${absoluteFilename}'`);\n              }\n            }\n            if (pattern.transform) {\n              /**\n               * @type {TransformerObject}\n               */\n              const transformObj = typeof pattern.transform === \"function\" ? {\n                transformer: pattern.transform\n              } : pattern.transform;\n              if (transformObj.transformer) {\n                logger.log(`transforming content for '${absoluteFilename}'...`);\n                const buffer = source.buffer();\n                if (transformObj.cache) {\n                  // TODO: remove in the next major release\n                  const hasher = compiler.webpack && compiler.webpack.util && compiler.webpack.util.createHash ? compiler.webpack.util.createHash(\"xxhash64\") :\n                  // eslint-disable-next-line global-require\n                  require(\"crypto\").createHash(\"md4\");\n                  const defaultCacheKeys = {\n                    version,\n                    sourceFilename,\n                    transform: transformObj.transformer,\n                    contentHash: hasher.update(buffer).digest(\"hex\"),\n                    index\n                  };\n                  const cacheKeys = `transform|${serialize(typeof transformObj.cache === \"boolean\" ? defaultCacheKeys : typeof transformObj.cache.keys === \"function\" ? yield transformObj.cache.keys(defaultCacheKeys, absoluteFilename) : {\n                    ...defaultCacheKeys,\n                    ...transformObj.cache.keys\n                  })}`;\n                  logger.debug(`getting transformation cache for '${absoluteFilename}'...`);\n                  const cacheItem = cache.getItemCache(cacheKeys, cache.getLazyHashedEtag(source));\n                  source = yield cacheItem.getPromise();\n                  logger.debug(source ? `found transformation cache for '${absoluteFilename}'` : `no transformation cache for '${absoluteFilename}'`);\n                  if (!source) {\n                    const transformed = yield transformObj.transformer(buffer, absoluteFilename);\n                    source = new RawSource(transformed);\n                    logger.debug(`caching transformation for '${absoluteFilename}'...`);\n                    yield cacheItem.storePromise(source);\n                    logger.debug(`cached transformation for '${absoluteFilename}'`);\n                  }\n                } else {\n                  source = new RawSource(yield transformObj.transformer(buffer, absoluteFilename));\n                }\n              }\n            }\n            let info = typeof pattern.info === \"undefined\" ? {} : typeof pattern.info === \"function\" ? pattern.info({\n              absoluteFilename,\n              sourceFilename,\n              filename,\n              toType\n            }) || {} : pattern.info || {};\n            if (toType === \"template\") {\n              logger.log(`interpolating template '${filename}' for '${sourceFilename}'...`);\n              const contentHash = CopyPlugin.getContentHash(compiler, compilation, source.buffer());\n              const ext = path.extname(sourceFilename);\n              const base = path.basename(sourceFilename);\n              const name = base.slice(0, base.length - ext.length);\n              const data = {\n                filename: normalizePath(path.relative(pattern.context, absoluteFilename)),\n                contentHash,\n                chunk: {\n                  name,\n                  id: /** @type {string} */\n                  sourceFilename,\n                  hash: contentHash\n                }\n              };\n              const {\n                path: interpolatedFilename,\n                info: assetInfo\n              } = compilation.getPathWithInfo(normalizePath(filename), data);\n              info = {\n                ...info,\n                ...assetInfo\n              };\n              filename = interpolatedFilename;\n              logger.log(`interpolated template '${filename}' for '${sourceFilename}'`);\n            } else {\n              filename = normalizePath(filename);\n            } // eslint-disable-next-line consistent-return\n\n            return {\n              sourceFilename,\n              absoluteFilename,\n              filename,\n              source,\n              info,\n              force: pattern.force\n            };\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } catch (error) {\n        compilation.errors.push( /** @type {WebpackError} */\n        error);\n        return;\n      }\n      if (copiedResult.length === 0) {\n        if (pattern.noErrorOnMissing) {\n          logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n          return;\n        }\n        const missingError = new Error(`unable to locate '${glob}' glob after filtering paths`);\n        compilation.errors.push( /** @type {WebpackError} */\n        missingError);\n        return;\n      }\n      logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`); // eslint-disable-next-line consistent-return\n\n      return copiedResult;\n    })();\n  }\n  /**\n   * @param {Compiler} compiler\n   */\n\n  apply(compiler) {\n    var _this = this;\n    const pluginName = this.constructor.name;\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      const logger = compilation.getLogger(\"copy-webpack-plugin\");\n      const cache = compilation.getCache(\"CopyWebpackPlugin\");\n      /**\n       * @type {typeof import(\"globby\").globby}\n       */\n\n      let globby;\n      compilation.hooks.processAssets.tapAsync({\n        name: \"copy-webpack-plugin\",\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (unusedAssets, callback) {\n          if (typeof globby === \"undefined\") {\n            try {\n              // @ts-ignore\n              ({\n                globby\n              } = yield import(\"globby\"));\n            } catch (error) {\n              callback( /** @type {Error} */\n              error);\n              return;\n            }\n          }\n          logger.log(\"starting to add additional assets...\");\n          const copiedResultMap = new Map();\n          /**\n           * @type {(() => Promise<void>)[]}\n           */\n\n          const scheduledTasks = [];\n          _this.patterns.map(\n          /**\n           * @param {Pattern} item\n           * @param {number} index\n           * @return {number}\n           */\n          (item, index) => scheduledTasks.push( /*#__PURE__*/_asyncToGenerator(function* () {\n            /**\n             * @type {ObjectPattern}\n             */\n            const normalizedPattern = typeof item === \"string\" ? {\n              from: item\n            } : {\n              ...item\n            };\n            const context = typeof normalizedPattern.context === \"undefined\" ? compiler.context : path.isAbsolute(normalizedPattern.context) ? normalizedPattern.context : path.join(compiler.context, normalizedPattern.context);\n            normalizedPattern.context = context;\n            /**\n             * @type {Array<CopiedResult | undefined> | undefined}\n             */\n\n            let copiedResult;\n            try {\n              copiedResult = yield CopyPlugin.runPattern(globby, compiler, compilation, logger, cache, /** @type {ObjectPattern & { context: string }} */\n              normalizedPattern, index);\n            } catch (error) {\n              compilation.errors.push( /** @type {WebpackError} */\n              error);\n              return;\n            }\n            if (!copiedResult) {\n              return;\n            }\n            /**\n             * @type {Array<CopiedResult>}\n             */\n\n            let filteredCopiedResult = copiedResult.filter(\n            /**\n             * @param {CopiedResult | undefined} result\n             * @returns {result is CopiedResult}\n             */\n            result => Boolean(result));\n            if (typeof normalizedPattern.transformAll !== \"undefined\") {\n              if (typeof normalizedPattern.to === \"undefined\") {\n                compilation.errors.push( /** @type {WebpackError} */\n                new Error(`Invalid \"pattern.to\" for the \"pattern.from\": \"${normalizedPattern.from}\" and \"pattern.transformAll\" function. The \"to\" option must be specified.`));\n                return;\n              }\n              filteredCopiedResult.sort((a, b) => a.absoluteFilename > b.absoluteFilename ? 1 : a.absoluteFilename < b.absoluteFilename ? -1 : 0);\n              const mergedEtag = filteredCopiedResult.length === 1 ? cache.getLazyHashedEtag(filteredCopiedResult[0].source) : filteredCopiedResult.reduce(\n              /**\n               * @param {Etag} accumulator\n               * @param {CopiedResult} asset\n               * @param {number} i\n               * @return {Etag}\n               */\n              // @ts-ignore\n              (accumulator, asset, i) => {\n                // eslint-disable-next-line no-param-reassign\n                accumulator = cache.mergeEtags(i === 1 ? cache.getLazyHashedEtag( /** @type {CopiedResult}*/\n                accumulator.source) : accumulator, cache.getLazyHashedEtag(asset.source));\n                return accumulator;\n              });\n              const cacheItem = cache.getItemCache(`transformAll|${serialize({\n                version,\n                from: normalizedPattern.from,\n                to: normalizedPattern.to,\n                transformAll: normalizedPattern.transformAll\n              })}`, mergedEtag);\n              let transformedAsset = yield cacheItem.getPromise();\n              if (!transformedAsset) {\n                transformedAsset = {\n                  filename: normalizedPattern.to\n                };\n                try {\n                  transformedAsset.data = yield normalizedPattern.transformAll(filteredCopiedResult.map(asset => {\n                    return {\n                      data: asset.source.buffer(),\n                      sourceFilename: asset.sourceFilename,\n                      absoluteFilename: asset.absoluteFilename\n                    };\n                  }));\n                } catch (error) {\n                  compilation.errors.push( /** @type {WebpackError} */\n                  error);\n                  return;\n                }\n                const filename = typeof normalizedPattern.to === \"function\" ? yield normalizedPattern.to({\n                  context\n                }) : normalizedPattern.to;\n                if (template.test(filename)) {\n                  const contentHash = CopyPlugin.getContentHash(compiler, compilation, transformedAsset.data);\n                  const {\n                    path: interpolatedFilename,\n                    info: assetInfo\n                  } = compilation.getPathWithInfo(normalizePath(filename), {\n                    contentHash,\n                    chunk: {\n                      id: \"unknown-copied-asset\",\n                      hash: contentHash\n                    }\n                  });\n                  transformedAsset.filename = interpolatedFilename;\n                  transformedAsset.info = assetInfo;\n                }\n                const {\n                  RawSource\n                } = compiler.webpack.sources;\n                transformedAsset.source = new RawSource(transformedAsset.data);\n                transformedAsset.force = normalizedPattern.force;\n                yield cacheItem.storePromise(transformedAsset);\n              }\n              filteredCopiedResult = [transformedAsset];\n            }\n            const priority = normalizedPattern.priority || 0;\n            if (!copiedResultMap.has(priority)) {\n              copiedResultMap.set(priority, []);\n            }\n            copiedResultMap.get(priority).push(...filteredCopiedResult);\n          })));\n          yield throttleAll(_this.options.concurrency || 100, scheduledTasks);\n          const copiedResult = [...copiedResultMap.entries()].sort((a, b) => a[0] - b[0]); // Avoid writing assets inside `p-limit`, because it creates concurrency.\n          // It could potentially lead to an error - 'Multiple assets emit different content to the same filename'\n\n          copiedResult.reduce((acc, val) => acc.concat(val[1]), []).filter(Boolean).forEach(\n          /**\n           * @param {CopiedResult} result\n           * @returns {void}\n           */\n          result => {\n            const {\n              absoluteFilename,\n              sourceFilename,\n              filename,\n              source,\n              force\n            } = result;\n            const existingAsset = compilation.getAsset(filename);\n            if (existingAsset) {\n              if (force) {\n                const info = {\n                  copied: true,\n                  sourceFilename\n                };\n                logger.log(`force updating '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists...`);\n                compilation.updateAsset(filename, source, {\n                  ...info,\n                  ...result.info\n                });\n                logger.log(`force updated '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n                return;\n              }\n              logger.log(`skip adding '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n              return;\n            }\n            const info = {\n              copied: true,\n              sourceFilename\n            };\n            logger.log(`writing '${filename}' from '${absoluteFilename}' to compilation assets...`);\n            compilation.emitAsset(filename, source, {\n              ...info,\n              ...result.info\n            });\n            logger.log(`written '${filename}' from '${absoluteFilename}' to compilation assets`);\n          });\n          logger.log(\"finished to adding additional assets\");\n          callback();\n        });\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      if (compilation.hooks.statsPrinter) {\n        compilation.hooks.statsPrinter.tap(pluginName, stats => {\n          stats.hooks.print.for(\"asset.info.copied\").tap(\"copy-webpack-plugin\", (copied, {\n            green,\n            formatFlag\n          }) => copied ? /** @type {Function} */\n          green( /** @type {Function} */\n          formatFlag(\"copied\")) : \"\");\n        });\n      }\n    });\n  }\n}\nmodule.exports = CopyPlugin;","map":{"version":3,"names":["path","require","validate","serialize","normalizePath","globParent","fastGlob","version","schema","readFile","stat","throttleAll","template","CopyPlugin","constructor","options","patterns","name","baseDataPath","createSnapshot","compilation","startTime","dependency","Promise","resolve","reject","fileSystemInfo","undefined","error","snapshot","checkSnapshotValid","isValid","getContentHash","compiler","source","outputOptions","hashDigest","hashDigestLength","hashFunction","hashSalt","hash","webpack","util","createHash","update","fullContentHash","digest","toString","slice","runPattern","globby","logger","cache","inputPattern","index","RawSource","sources","pattern","originalFrom","from","normalizedOriginalFrom","normalize","log","context","absoluteFrom","isAbsolute","debug","inputFileSystem","stats","fromType","isDirectory","isFile","globOptions","followSymbolicLinks","cwd","objectMode","fs","glob","contextDependencies","add","posix","join","escapePath","dot","fileDependencies","dirname","globEntries","errors","push","length","noErrorOnMissing","to","missingError","Error","copiedResult","all","map","globEntry","dirent","filter","isFiltered","absoluteFilename","toType","test","extname","sep","relativeFrom","relative","filename","output","sourceFilename","cacheEntry","getPromise","isValidSnapshot","Date","now","data","storePromise","transform","transformObj","transformer","buffer","hasher","defaultCacheKeys","contentHash","cacheKeys","keys","cacheItem","getItemCache","getLazyHashedEtag","transformed","info","ext","base","basename","chunk","id","interpolatedFilename","assetInfo","getPathWithInfo","force","apply","pluginName","hooks","thisCompilation","tap","getLogger","getCache","processAssets","tapAsync","stage","Compilation","PROCESS_ASSETS_STAGE_ADDITIONAL","unusedAssets","callback","copiedResultMap","Map","scheduledTasks","item","normalizedPattern","filteredCopiedResult","result","Boolean","transformAll","sort","a","b","mergedEtag","reduce","accumulator","asset","i","mergeEtags","transformedAsset","priority","has","set","get","concurrency","entries","acc","val","concat","forEach","existingAsset","getAsset","copied","updateAsset","emitAsset","statsPrinter","print","for","green","formatFlag","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/copy-webpack-plugin/dist/index.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst serialize = require(\"serialize-javascript\");\n\nconst normalizePath = require(\"normalize-path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst fastGlob = require(\"fast-glob\"); // @ts-ignore\n\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst schema = require(\"./options.json\");\n\nconst {\n  readFile,\n  stat,\n  throttleAll\n} = require(\"./utils\");\n\nconst template = /\\[\\\\*([\\w:]+)\\\\*\\]/i;\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"globby\").Options} GlobbyOptions */\n\n/** @typedef {import(\"globby\").GlobEntry} GlobEntry */\n\n/** @typedef {ReturnType<Compilation[\"getLogger\"]>} WebpackLogger */\n\n/** @typedef {ReturnType<Compilation[\"getCache\"]>} CacheFacade */\n\n/** @typedef {ReturnType<ReturnType<Compilation[\"getCache\"]>[\"getLazyHashedEtag\"]>} Etag */\n\n/** @typedef {ReturnType<Compilation[\"fileSystemInfo\"][\"mergeSnapshots\"]>} Snapshot */\n\n/**\n * @typedef {boolean} Force\n */\n\n/**\n * @typedef {Object} CopiedResult\n * @property {string} sourceFilename\n * @property {string} absoluteFilename\n * @property {string} filename\n * @property {Asset[\"source\"]} source\n * @property {Force | undefined} force\n * @property {Record<string, any>} info\n */\n\n/**\n * @typedef {string} StringPattern\n */\n\n/**\n * @typedef {boolean} NoErrorOnMissing\n */\n\n/**\n * @typedef {string} Context\n */\n\n/**\n * @typedef {string} From\n */\n\n/**\n * @callback ToFunction\n * @param {{ context: string, absoluteFilename?: string }} pathData\n * @return {string | Promise<string>}\n */\n\n/**\n * @typedef {string | ToFunction} To\n */\n\n/**\n * @typedef {\"dir\" | \"file\" | \"template\"} ToType\n */\n\n/**\n * @callback TransformerFunction\n * @param {Buffer} input\n * @param {string} absoluteFilename\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject\n */\n\n/**\n * @typedef {Object} TransformerObject\n * @property {TransformerFunction} transformer\n * @property {boolean | TransformerCacheObject} [cache]\n */\n\n/**\n * @typedef {TransformerFunction | TransformerObject} Transform\n */\n\n/**\n * @callback Filter\n * @param {string} filepath\n * @returns {boolean | Promise<boolean>}\n */\n\n/**\n * @callback TransformAllFunction\n * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef { Record<string, any> | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => Record<string, any>) } Info\n */\n\n/**\n * @typedef {Object} ObjectPattern\n * @property {From} from\n * @property {GlobbyOptions} [globOptions]\n * @property {Context} [context]\n * @property {To} [to]\n * @property {ToType} [toType]\n * @property {Info} [info]\n * @property {Filter} [filter]\n * @property {Transform} [transform]\n * @property {TransformAllFunction} [transformAll]\n * @property {Force} [force]\n * @property {number} [priority]\n * @property {NoErrorOnMissing} [noErrorOnMissing]\n */\n\n/**\n * @typedef {StringPattern | ObjectPattern} Pattern\n */\n\n/**\n * @typedef {Object} AdditionalOptions\n * @property {number} [concurrency]\n */\n\n/**\n * @typedef {Object} PluginOptions\n * @property {Pattern[]} patterns\n * @property {AdditionalOptions} [options]\n */\n\nclass CopyPlugin {\n  /**\n   * @param {PluginOptions} [options]\n   */\n  constructor(options = {\n    patterns: []\n  }) {\n    validate(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Copy Plugin\",\n      baseDataPath: \"options\"\n    });\n    /**\n     * @private\n     * @type {Pattern[]}\n     */\n\n    this.patterns = options.patterns;\n    /**\n     * @private\n     * @type {AdditionalOptions}\n     */\n\n    this.options = options.options || {};\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {number} startTime\n   * @param {string} dependency\n   * @returns {Promise<Snapshot | undefined>}\n   */\n\n\n  static async createSnapshot(compilation, startTime, dependency) {\n    // eslint-disable-next-line consistent-return\n    return new Promise((resolve, reject) => {\n      compilation.fileSystemInfo.createSnapshot(startTime, [dependency], // @ts-ignore\n      // eslint-disable-next-line no-undefined\n      undefined, // eslint-disable-next-line no-undefined\n      undefined, null, (error, snapshot) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(\n        /** @type {Snapshot} */\n        snapshot);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {Snapshot} snapshot\n   * @returns {Promise<boolean | undefined>}\n   */\n\n\n  static async checkSnapshotValid(compilation, snapshot) {\n    // eslint-disable-next-line consistent-return\n    return new Promise((resolve, reject) => {\n      compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(isValid);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Buffer} source\n   * @returns {string}\n   */\n\n\n  static getContentHash(compiler, compilation, source) {\n    const {\n      outputOptions\n    } = compilation;\n    const {\n      hashDigest,\n      hashDigestLength,\n      hashFunction,\n      hashSalt\n    } = outputOptions;\n    const hash = compiler.webpack.util.createHash(\n    /** @type {string} */\n    hashFunction);\n\n    if (hashSalt) {\n      hash.update(hashSalt);\n    }\n\n    hash.update(source);\n    const fullContentHash = hash.digest(hashDigest);\n    return fullContentHash.toString().slice(0, hashDigestLength);\n  }\n  /**\n   * @private\n   * @param {typeof import(\"globby\").globby} globby\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {WebpackLogger} logger\n   * @param {CacheFacade} cache\n   * @param {ObjectPattern & { context: string }} inputPattern\n   * @param {number} index\n   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}\n   */\n\n\n  static async runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {\n    const {\n      RawSource\n    } = compiler.webpack.sources;\n    const pattern = { ...inputPattern\n    };\n    const originalFrom = pattern.from;\n    const normalizedOriginalFrom = path.normalize(originalFrom);\n    logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);\n    let absoluteFrom;\n\n    if (path.isAbsolute(normalizedOriginalFrom)) {\n      absoluteFrom = normalizedOriginalFrom;\n    } else {\n      absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);\n    }\n\n    logger.debug(`getting stats for '${absoluteFrom}'...`);\n    const {\n      inputFileSystem\n    } = compiler;\n    let stats;\n\n    try {\n      stats = await stat(inputFileSystem, absoluteFrom);\n    } catch (error) {// Nothing\n    }\n    /**\n     * @type {\"file\" | \"dir\" | \"glob\"}\n     */\n\n\n    let fromType;\n\n    if (stats) {\n      if (stats.isDirectory()) {\n        fromType = \"dir\";\n        logger.debug(`determined '${absoluteFrom}' is a directory`);\n      } else if (stats.isFile()) {\n        fromType = \"file\";\n        logger.debug(`determined '${absoluteFrom}' is a file`);\n      } else {\n        // Fallback\n        fromType = \"glob\";\n        logger.debug(`determined '${absoluteFrom}' is unknown`);\n      }\n    } else {\n      fromType = \"glob\";\n      logger.debug(`determined '${absoluteFrom}' is a glob`);\n    }\n    /** @type {GlobbyOptions & { objectMode: true }} */\n\n\n    const globOptions = { ...{\n        followSymbolicLinks: true\n      },\n      ...(pattern.globOptions || {}),\n      ...{\n        cwd: pattern.context,\n        objectMode: true\n      }\n    }; // @ts-ignore\n\n    globOptions.fs = inputFileSystem;\n    let glob;\n\n    switch (fromType) {\n      case \"dir\":\n        compilation.contextDependencies.add(absoluteFrom);\n        logger.debug(`added '${absoluteFrom}' as a context dependency`);\n        pattern.context = absoluteFrom;\n        glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), \"**/*\");\n        absoluteFrom = path.join(absoluteFrom, \"**/*\");\n\n        if (typeof globOptions.dot === \"undefined\") {\n          globOptions.dot = true;\n        }\n\n        break;\n\n      case \"file\":\n        compilation.fileDependencies.add(absoluteFrom);\n        logger.debug(`added '${absoluteFrom}' as a file dependency`);\n        pattern.context = path.dirname(absoluteFrom);\n        glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));\n\n        if (typeof globOptions.dot === \"undefined\") {\n          globOptions.dot = true;\n        }\n\n        break;\n\n      case \"glob\":\n      default:\n        {\n          const contextDependencies = path.normalize(globParent(absoluteFrom));\n          compilation.contextDependencies.add(contextDependencies);\n          logger.debug(`added '${contextDependencies}' as a context dependency`);\n          glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);\n        }\n    }\n\n    logger.log(`begin globbing '${glob}'...`);\n    /**\n     * @type {GlobEntry[]}\n     */\n\n    let globEntries;\n\n    try {\n      globEntries = await globby(glob, globOptions);\n    } catch (error) {\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      error);\n      return;\n    }\n\n    if (globEntries.length === 0) {\n      if (pattern.noErrorOnMissing) {\n        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n        return;\n      }\n\n      const missingError = new Error(`unable to locate '${glob}' glob`);\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      missingError);\n      return;\n    }\n    /**\n     * @type {Array<CopiedResult | undefined>}\n     */\n\n\n    let copiedResult;\n\n    try {\n      copiedResult = await Promise.all(globEntries.map(\n      /**\n       * @param {GlobEntry} globEntry\n       * @returns {Promise<CopiedResult | undefined>}\n       */\n      async globEntry => {\n        // Exclude directories\n        if (!globEntry.dirent.isFile()) {\n          return;\n        }\n\n        if (pattern.filter) {\n          let isFiltered;\n\n          try {\n            isFiltered = await pattern.filter(globEntry.path);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (!isFiltered) {\n            logger.log(`skip '${globEntry.path}', because it was filtered`);\n            return;\n          }\n        }\n\n        const from = globEntry.path;\n        logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows\n\n        const absoluteFilename = path.resolve(pattern.context, from);\n        const to = typeof pattern.to === \"function\" ? await pattern.to({\n          context: pattern.context,\n          absoluteFilename\n        }) : path.normalize(typeof pattern.to !== \"undefined\" ? pattern.to : \"\");\n        const toType = pattern.toType ? pattern.toType : template.test(to) ? \"template\" : path.extname(to) === \"\" || to.slice(-1) === path.sep ? \"dir\" : \"file\";\n        logger.log(`'to' option '${to}' determinated as '${toType}'`);\n        const relativeFrom = path.relative(pattern.context, absoluteFilename);\n        let filename = toType === \"dir\" ? path.join(to, relativeFrom) : to;\n\n        if (path.isAbsolute(filename)) {\n          filename = path.relative(\n          /** @type {string} */\n          compiler.options.output.path, filename);\n        }\n\n        logger.log(`determined that '${from}' should write to '${filename}'`);\n        const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies\n\n        if (fromType === \"dir\" || fromType === \"glob\") {\n          compilation.fileDependencies.add(absoluteFilename);\n          logger.debug(`added '${absoluteFilename}' as a file dependency`);\n        }\n\n        let cacheEntry;\n        logger.debug(`getting cache for '${absoluteFilename}'...`);\n\n        try {\n          cacheEntry = await cache.getPromise(`${sourceFilename}|${index}`, null);\n        } catch (error) {\n          compilation.errors.push(\n          /** @type {WebpackError} */\n          error);\n          return;\n        }\n        /**\n         * @type {Asset[\"source\"] | undefined}\n         */\n\n\n        let source;\n\n        if (cacheEntry) {\n          logger.debug(`found cache for '${absoluteFilename}'...`);\n          let isValidSnapshot;\n          logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);\n\n          try {\n            isValidSnapshot = await CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (isValidSnapshot) {\n            logger.debug(`snapshot for '${absoluteFilename}' is valid`);\n            ({\n              source\n            } = cacheEntry);\n          } else {\n            logger.debug(`snapshot for '${absoluteFilename}' is invalid`);\n          }\n        } else {\n          logger.debug(`missed cache for '${absoluteFilename}'`);\n        }\n\n        if (!source) {\n          const startTime = Date.now();\n          logger.debug(`reading '${absoluteFilename}'...`);\n          let data;\n\n          try {\n            data = await readFile(inputFileSystem, absoluteFilename);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          logger.debug(`read '${absoluteFilename}'`);\n          source = new RawSource(data);\n          let snapshot;\n          logger.debug(`creating snapshot for '${absoluteFilename}'...`);\n\n          try {\n            snapshot = await CopyPlugin.createSnapshot(compilation, startTime, absoluteFilename);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (snapshot) {\n            logger.debug(`created snapshot for '${absoluteFilename}'`);\n            logger.debug(`storing cache for '${absoluteFilename}'...`);\n\n            try {\n              await cache.storePromise(`${sourceFilename}|${index}`, null, {\n                source,\n                snapshot\n              });\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n\n            logger.debug(`stored cache for '${absoluteFilename}'`);\n          }\n        }\n\n        if (pattern.transform) {\n          /**\n           * @type {TransformerObject}\n           */\n          const transformObj = typeof pattern.transform === \"function\" ? {\n            transformer: pattern.transform\n          } : pattern.transform;\n\n          if (transformObj.transformer) {\n            logger.log(`transforming content for '${absoluteFilename}'...`);\n            const buffer = source.buffer();\n\n            if (transformObj.cache) {\n              // TODO: remove in the next major release\n              const hasher = compiler.webpack && compiler.webpack.util && compiler.webpack.util.createHash ? compiler.webpack.util.createHash(\"xxhash64\") : // eslint-disable-next-line global-require\n              require(\"crypto\").createHash(\"md4\");\n              const defaultCacheKeys = {\n                version,\n                sourceFilename,\n                transform: transformObj.transformer,\n                contentHash: hasher.update(buffer).digest(\"hex\"),\n                index\n              };\n              const cacheKeys = `transform|${serialize(typeof transformObj.cache === \"boolean\" ? defaultCacheKeys : typeof transformObj.cache.keys === \"function\" ? await transformObj.cache.keys(defaultCacheKeys, absoluteFilename) : { ...defaultCacheKeys,\n                ...transformObj.cache.keys\n              })}`;\n              logger.debug(`getting transformation cache for '${absoluteFilename}'...`);\n              const cacheItem = cache.getItemCache(cacheKeys, cache.getLazyHashedEtag(source));\n              source = await cacheItem.getPromise();\n              logger.debug(source ? `found transformation cache for '${absoluteFilename}'` : `no transformation cache for '${absoluteFilename}'`);\n\n              if (!source) {\n                const transformed = await transformObj.transformer(buffer, absoluteFilename);\n                source = new RawSource(transformed);\n                logger.debug(`caching transformation for '${absoluteFilename}'...`);\n                await cacheItem.storePromise(source);\n                logger.debug(`cached transformation for '${absoluteFilename}'`);\n              }\n            } else {\n              source = new RawSource(await transformObj.transformer(buffer, absoluteFilename));\n            }\n          }\n        }\n\n        let info = typeof pattern.info === \"undefined\" ? {} : typeof pattern.info === \"function\" ? pattern.info({\n          absoluteFilename,\n          sourceFilename,\n          filename,\n          toType\n        }) || {} : pattern.info || {};\n\n        if (toType === \"template\") {\n          logger.log(`interpolating template '${filename}' for '${sourceFilename}'...`);\n          const contentHash = CopyPlugin.getContentHash(compiler, compilation, source.buffer());\n          const ext = path.extname(sourceFilename);\n          const base = path.basename(sourceFilename);\n          const name = base.slice(0, base.length - ext.length);\n          const data = {\n            filename: normalizePath(path.relative(pattern.context, absoluteFilename)),\n            contentHash,\n            chunk: {\n              name,\n              id:\n              /** @type {string} */\n              sourceFilename,\n              hash: contentHash\n            }\n          };\n          const {\n            path: interpolatedFilename,\n            info: assetInfo\n          } = compilation.getPathWithInfo(normalizePath(filename), data);\n          info = { ...info,\n            ...assetInfo\n          };\n          filename = interpolatedFilename;\n          logger.log(`interpolated template '${filename}' for '${sourceFilename}'`);\n        } else {\n          filename = normalizePath(filename);\n        } // eslint-disable-next-line consistent-return\n\n\n        return {\n          sourceFilename,\n          absoluteFilename,\n          filename,\n          source,\n          info,\n          force: pattern.force\n        };\n      }));\n    } catch (error) {\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      error);\n      return;\n    }\n\n    if (copiedResult.length === 0) {\n      if (pattern.noErrorOnMissing) {\n        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n        return;\n      }\n\n      const missingError = new Error(`unable to locate '${glob}' glob after filtering paths`);\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      missingError);\n      return;\n    }\n\n    logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`); // eslint-disable-next-line consistent-return\n\n    return copiedResult;\n  }\n  /**\n   * @param {Compiler} compiler\n   */\n\n\n  apply(compiler) {\n    const pluginName = this.constructor.name;\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      const logger = compilation.getLogger(\"copy-webpack-plugin\");\n      const cache = compilation.getCache(\"CopyWebpackPlugin\");\n      /**\n       * @type {typeof import(\"globby\").globby}\n       */\n\n      let globby;\n      compilation.hooks.processAssets.tapAsync({\n        name: \"copy-webpack-plugin\",\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, async (unusedAssets, callback) => {\n        if (typeof globby === \"undefined\") {\n          try {\n            // @ts-ignore\n            ({\n              globby\n            } = await import(\"globby\"));\n          } catch (error) {\n            callback(\n            /** @type {Error} */\n            error);\n            return;\n          }\n        }\n\n        logger.log(\"starting to add additional assets...\");\n        const copiedResultMap = new Map();\n        /**\n         * @type {(() => Promise<void>)[]}\n         */\n\n        const scheduledTasks = [];\n        this.patterns.map(\n        /**\n         * @param {Pattern} item\n         * @param {number} index\n         * @return {number}\n         */\n        (item, index) => scheduledTasks.push(async () => {\n          /**\n           * @type {ObjectPattern}\n           */\n          const normalizedPattern = typeof item === \"string\" ? {\n            from: item\n          } : { ...item\n          };\n          const context = typeof normalizedPattern.context === \"undefined\" ? compiler.context : path.isAbsolute(normalizedPattern.context) ? normalizedPattern.context : path.join(compiler.context, normalizedPattern.context);\n          normalizedPattern.context = context;\n          /**\n           * @type {Array<CopiedResult | undefined> | undefined}\n           */\n\n          let copiedResult;\n\n          try {\n            copiedResult = await CopyPlugin.runPattern(globby, compiler, compilation, logger, cache,\n            /** @type {ObjectPattern & { context: string }} */\n            normalizedPattern, index);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (!copiedResult) {\n            return;\n          }\n          /**\n           * @type {Array<CopiedResult>}\n           */\n\n\n          let filteredCopiedResult = copiedResult.filter(\n          /**\n           * @param {CopiedResult | undefined} result\n           * @returns {result is CopiedResult}\n           */\n          result => Boolean(result));\n\n          if (typeof normalizedPattern.transformAll !== \"undefined\") {\n            if (typeof normalizedPattern.to === \"undefined\") {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              new Error(`Invalid \"pattern.to\" for the \"pattern.from\": \"${normalizedPattern.from}\" and \"pattern.transformAll\" function. The \"to\" option must be specified.`));\n              return;\n            }\n\n            filteredCopiedResult.sort((a, b) => a.absoluteFilename > b.absoluteFilename ? 1 : a.absoluteFilename < b.absoluteFilename ? -1 : 0);\n            const mergedEtag = filteredCopiedResult.length === 1 ? cache.getLazyHashedEtag(filteredCopiedResult[0].source) : filteredCopiedResult.reduce(\n            /**\n             * @param {Etag} accumulator\n             * @param {CopiedResult} asset\n             * @param {number} i\n             * @return {Etag}\n             */\n            // @ts-ignore\n            (accumulator, asset, i) => {\n              // eslint-disable-next-line no-param-reassign\n              accumulator = cache.mergeEtags(i === 1 ? cache.getLazyHashedEtag(\n              /** @type {CopiedResult}*/\n              accumulator.source) : accumulator, cache.getLazyHashedEtag(asset.source));\n              return accumulator;\n            });\n            const cacheItem = cache.getItemCache(`transformAll|${serialize({\n              version,\n              from: normalizedPattern.from,\n              to: normalizedPattern.to,\n              transformAll: normalizedPattern.transformAll\n            })}`, mergedEtag);\n            let transformedAsset = await cacheItem.getPromise();\n\n            if (!transformedAsset) {\n              transformedAsset = {\n                filename: normalizedPattern.to\n              };\n\n              try {\n                transformedAsset.data = await normalizedPattern.transformAll(filteredCopiedResult.map(asset => {\n                  return {\n                    data: asset.source.buffer(),\n                    sourceFilename: asset.sourceFilename,\n                    absoluteFilename: asset.absoluteFilename\n                  };\n                }));\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              const filename = typeof normalizedPattern.to === \"function\" ? await normalizedPattern.to({\n                context\n              }) : normalizedPattern.to;\n\n              if (template.test(filename)) {\n                const contentHash = CopyPlugin.getContentHash(compiler, compilation, transformedAsset.data);\n                const {\n                  path: interpolatedFilename,\n                  info: assetInfo\n                } = compilation.getPathWithInfo(normalizePath(filename), {\n                  contentHash,\n                  chunk: {\n                    id: \"unknown-copied-asset\",\n                    hash: contentHash\n                  }\n                });\n                transformedAsset.filename = interpolatedFilename;\n                transformedAsset.info = assetInfo;\n              }\n\n              const {\n                RawSource\n              } = compiler.webpack.sources;\n              transformedAsset.source = new RawSource(transformedAsset.data);\n              transformedAsset.force = normalizedPattern.force;\n              await cacheItem.storePromise(transformedAsset);\n            }\n\n            filteredCopiedResult = [transformedAsset];\n          }\n\n          const priority = normalizedPattern.priority || 0;\n\n          if (!copiedResultMap.has(priority)) {\n            copiedResultMap.set(priority, []);\n          }\n\n          copiedResultMap.get(priority).push(...filteredCopiedResult);\n        }));\n        await throttleAll(this.options.concurrency || 100, scheduledTasks);\n        const copiedResult = [...copiedResultMap.entries()].sort((a, b) => a[0] - b[0]); // Avoid writing assets inside `p-limit`, because it creates concurrency.\n        // It could potentially lead to an error - 'Multiple assets emit different content to the same filename'\n\n        copiedResult.reduce((acc, val) => acc.concat(val[1]), []).filter(Boolean).forEach(\n        /**\n         * @param {CopiedResult} result\n         * @returns {void}\n         */\n        result => {\n          const {\n            absoluteFilename,\n            sourceFilename,\n            filename,\n            source,\n            force\n          } = result;\n          const existingAsset = compilation.getAsset(filename);\n\n          if (existingAsset) {\n            if (force) {\n              const info = {\n                copied: true,\n                sourceFilename\n              };\n              logger.log(`force updating '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists...`);\n              compilation.updateAsset(filename, source, { ...info,\n                ...result.info\n              });\n              logger.log(`force updated '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n              return;\n            }\n\n            logger.log(`skip adding '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n            return;\n          }\n\n          const info = {\n            copied: true,\n            sourceFilename\n          };\n          logger.log(`writing '${filename}' from '${absoluteFilename}' to compilation assets...`);\n          compilation.emitAsset(filename, source, { ...info,\n            ...result.info\n          });\n          logger.log(`written '${filename}' from '${absoluteFilename}' to compilation assets`);\n        });\n        logger.log(\"finished to adding additional assets\");\n        callback();\n      });\n\n      if (compilation.hooks.statsPrinter) {\n        compilation.hooks.statsPrinter.tap(pluginName, stats => {\n          stats.hooks.print.for(\"asset.info.copied\").tap(\"copy-webpack-plugin\", (copied, {\n            green,\n            formatFlag\n          }) => copied ?\n          /** @type {Function} */\n          green(\n          /** @type {Function} */\n          formatFlag(\"copied\")) : \"\");\n        });\n      }\n    });\n  }\n\n}\n\nmodule.exports = CopyPlugin;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}