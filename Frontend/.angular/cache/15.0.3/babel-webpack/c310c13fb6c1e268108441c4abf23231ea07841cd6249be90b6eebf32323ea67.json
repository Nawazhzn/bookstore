{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst isStream = require('is-stream');\nconst getStream = require('get-stream');\nconst mergeStream = require('merge-stream');\n\n// `input` option\nconst handleInput = (spawned, input) => {\n  // Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n  // @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n  if (input === undefined || spawned.stdin === undefined) {\n    return;\n  }\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n};\n\n// `all` interleaves `stdout` and `stderr`\nconst makeAllStream = (spawned, {\n  all\n}) => {\n  if (!all || !spawned.stdout && !spawned.stderr) {\n    return;\n  }\n  const mixed = mergeStream();\n  if (spawned.stdout) {\n    mixed.add(spawned.stdout);\n  }\n  if (spawned.stderr) {\n    mixed.add(spawned.stderr);\n  }\n  return mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (stream, streamPromise) {\n    if (!stream) {\n      return;\n    }\n    stream.destroy();\n    try {\n      return yield streamPromise;\n    } catch (error) {\n      return error.bufferedData;\n    }\n  });\n  return function getBufferedData(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst getStreamPromise = (stream, {\n  encoding,\n  buffer,\n  maxBuffer\n}) => {\n  if (!stream || !buffer) {\n    return;\n  }\n  if (encoding) {\n    return getStream(stream, {\n      encoding,\n      maxBuffer\n    });\n  }\n  return getStream.buffer(stream, {\n    maxBuffer\n  });\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nconst getSpawnedResult = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* ({\n    stdout,\n    stderr,\n    all\n  }, {\n    encoding,\n    buffer,\n    maxBuffer\n  }, processDone) {\n    const stdoutPromise = getStreamPromise(stdout, {\n      encoding,\n      buffer,\n      maxBuffer\n    });\n    const stderrPromise = getStreamPromise(stderr, {\n      encoding,\n      buffer,\n      maxBuffer\n    });\n    const allPromise = getStreamPromise(all, {\n      encoding,\n      buffer,\n      maxBuffer: maxBuffer * 2\n    });\n    try {\n      return yield Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n    } catch (error) {\n      return Promise.all([{\n        error,\n        signal: error.signal,\n        timedOut: error.timedOut\n      }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]);\n    }\n  });\n  return function getSpawnedResult(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nconst validateInputSync = ({\n  input\n}) => {\n  if (isStream(input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n};\nmodule.exports = {\n  handleInput,\n  makeAllStream,\n  getSpawnedResult,\n  validateInputSync\n};","map":{"version":3,"names":["isStream","require","getStream","mergeStream","handleInput","spawned","input","undefined","stdin","pipe","end","makeAllStream","all","stdout","stderr","mixed","add","getBufferedData","stream","streamPromise","destroy","error","bufferedData","getStreamPromise","encoding","buffer","maxBuffer","getSpawnedResult","processDone","stdoutPromise","stderrPromise","allPromise","Promise","signal","timedOut","validateInputSync","TypeError","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/execa/lib/stream.js"],"sourcesContent":["'use strict';\nconst isStream = require('is-stream');\nconst getStream = require('get-stream');\nconst mergeStream = require('merge-stream');\n\n// `input` option\nconst handleInput = (spawned, input) => {\n\t// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n\t// @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n\tif (input === undefined || spawned.stdin === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nconst makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nconst getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise)\n\t\t]);\n\t}\n};\n\nconst validateInputSync = ({input}) => {\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n};\n\nmodule.exports = {\n\thandleInput,\n\tmakeAllStream,\n\tgetSpawnedResult,\n\tvalidateInputSync\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}