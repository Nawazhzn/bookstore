{"ast":null,"code":"(module => {\n  \"use strict\";\n\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n        get: () => from[key],\n        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n      });\n    }\n    return to;\n  };\n  var __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod);\n  var __async = (__this, __arguments, generator) => {\n    return new Promise((resolve, reject) => {\n      var fulfilled = value => {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n      var rejected = value => {\n        try {\n          step(generator.throw(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n      var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n      step((generator = generator.apply(__this, __arguments)).next());\n    });\n  };\n\n  // lib/npm/browser.ts\n  var browser_exports = {};\n  __export(browser_exports, {\n    analyzeMetafile: () => analyzeMetafile,\n    analyzeMetafileSync: () => analyzeMetafileSync,\n    build: () => build,\n    buildSync: () => buildSync,\n    default: () => browser_default,\n    formatMessages: () => formatMessages,\n    formatMessagesSync: () => formatMessagesSync,\n    initialize: () => initialize,\n    serve: () => serve,\n    transform: () => transform,\n    transformSync: () => transformSync,\n    version: () => version\n  });\n  module.exports = __toCommonJS(browser_exports);\n\n  // lib/shared/stdio_protocol.ts\n  function encodePacket(packet) {\n    let visit = value => {\n      if (value === null) {\n        bb.write8(0);\n      } else if (typeof value === \"boolean\") {\n        bb.write8(1);\n        bb.write8(+value);\n      } else if (typeof value === \"number\") {\n        bb.write8(2);\n        bb.write32(value | 0);\n      } else if (typeof value === \"string\") {\n        bb.write8(3);\n        bb.write(encodeUTF8(value));\n      } else if (value instanceof Uint8Array) {\n        bb.write8(4);\n        bb.write(value);\n      } else if (value instanceof Array) {\n        bb.write8(5);\n        bb.write32(value.length);\n        for (let item of value) {\n          visit(item);\n        }\n      } else {\n        let keys = Object.keys(value);\n        bb.write8(6);\n        bb.write32(keys.length);\n        for (let key of keys) {\n          bb.write(encodeUTF8(key));\n          visit(value[key]);\n        }\n      }\n    };\n    let bb = new ByteBuffer();\n    bb.write32(0);\n    bb.write32(packet.id << 1 | +!packet.isRequest);\n    visit(packet.value);\n    writeUInt32LE(bb.buf, bb.len - 4, 0);\n    return bb.buf.subarray(0, bb.len);\n  }\n  function decodePacket(bytes) {\n    let visit = () => {\n      switch (bb.read8()) {\n        case 0:\n          return null;\n        case 1:\n          return !!bb.read8();\n        case 2:\n          return bb.read32();\n        case 3:\n          return decodeUTF8(bb.read());\n        case 4:\n          return bb.read();\n        case 5:\n          {\n            let count = bb.read32();\n            let value2 = [];\n            for (let i = 0; i < count; i++) {\n              value2.push(visit());\n            }\n            return value2;\n          }\n        case 6:\n          {\n            let count = bb.read32();\n            let value2 = {};\n            for (let i = 0; i < count; i++) {\n              value2[decodeUTF8(bb.read())] = visit();\n            }\n            return value2;\n          }\n        default:\n          throw new Error(\"Invalid packet\");\n      }\n    };\n    let bb = new ByteBuffer(bytes);\n    let id = bb.read32();\n    let isRequest = (id & 1) === 0;\n    id >>>= 1;\n    let value = visit();\n    if (bb.ptr !== bytes.length) {\n      throw new Error(\"Invalid packet\");\n    }\n    return {\n      id,\n      isRequest,\n      value\n    };\n  }\n  var ByteBuffer = class {\n    constructor(buf = new Uint8Array(1024)) {\n      this.buf = buf;\n      this.len = 0;\n      this.ptr = 0;\n    }\n    _write(delta) {\n      if (this.len + delta > this.buf.length) {\n        let clone = new Uint8Array((this.len + delta) * 2);\n        clone.set(this.buf);\n        this.buf = clone;\n      }\n      this.len += delta;\n      return this.len - delta;\n    }\n    write8(value) {\n      let offset = this._write(1);\n      this.buf[offset] = value;\n    }\n    write32(value) {\n      let offset = this._write(4);\n      writeUInt32LE(this.buf, value, offset);\n    }\n    write(bytes) {\n      let offset = this._write(4 + bytes.length);\n      writeUInt32LE(this.buf, bytes.length, offset);\n      this.buf.set(bytes, offset + 4);\n    }\n    _read(delta) {\n      if (this.ptr + delta > this.buf.length) {\n        throw new Error(\"Invalid packet\");\n      }\n      this.ptr += delta;\n      return this.ptr - delta;\n    }\n    read8() {\n      return this.buf[this._read(1)];\n    }\n    read32() {\n      return readUInt32LE(this.buf, this._read(4));\n    }\n    read() {\n      let length = this.read32();\n      let bytes = new Uint8Array(length);\n      let ptr = this._read(bytes.length);\n      bytes.set(this.buf.subarray(ptr, ptr + length));\n      return bytes;\n    }\n  };\n  var encodeUTF8;\n  var decodeUTF8;\n  if (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n    let encoder = new TextEncoder();\n    let decoder = new TextDecoder();\n    encodeUTF8 = text => encoder.encode(text);\n    decodeUTF8 = bytes => decoder.decode(bytes);\n  } else if (typeof Buffer !== \"undefined\") {\n    encodeUTF8 = text => {\n      let buffer = Buffer.from(text);\n      if (!(buffer instanceof Uint8Array)) {\n        buffer = new Uint8Array(buffer);\n      }\n      return buffer;\n    };\n    decodeUTF8 = bytes => {\n      let {\n        buffer,\n        byteOffset,\n        byteLength\n      } = bytes;\n      return Buffer.from(buffer, byteOffset, byteLength).toString();\n    };\n  } else {\n    throw new Error(\"No UTF-8 codec found\");\n  }\n  function readUInt32LE(buffer, offset) {\n    return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n  }\n  function writeUInt32LE(buffer, value, offset) {\n    buffer[offset++] = value;\n    buffer[offset++] = value >> 8;\n    buffer[offset++] = value >> 16;\n    buffer[offset++] = value >> 24;\n  }\n\n  // lib/shared/common.ts\n  var buildLogLevelDefault = \"warning\";\n  var transformLogLevelDefault = \"silent\";\n  function validateTarget(target) {\n    target += \"\";\n    if (target.indexOf(\",\") >= 0) throw new Error(`Invalid target: ${target}`);\n    return target;\n  }\n  var canBeAnything = () => null;\n  var mustBeBoolean = value => typeof value === \"boolean\" ? null : \"a boolean\";\n  var mustBeBooleanOrObject = value => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\n  var mustBeString = value => typeof value === \"string\" ? null : \"a string\";\n  var mustBeRegExp = value => value instanceof RegExp ? null : \"a RegExp object\";\n  var mustBeInteger = value => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\n  var mustBeFunction = value => typeof value === \"function\" ? null : \"a function\";\n  var mustBeArray = value => Array.isArray(value) ? null : \"an array\";\n  var mustBeObject = value => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\n  var mustBeWebAssemblyModule = value => value instanceof WebAssembly.Module ? null : \"a WebAssembly.Module\";\n  var mustBeArrayOrRecord = value => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\n  var mustBeObjectOrNull = value => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\n  var mustBeStringOrBoolean = value => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\n  var mustBeStringOrObject = value => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\n  var mustBeStringOrArray = value => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\n  var mustBeStringOrUint8Array = value => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\n  function getFlag(object, keys, key, mustBeFn) {\n    let value = object[key];\n    keys[key + \"\"] = true;\n    if (value === void 0) return void 0;\n    let mustBe = mustBeFn(value);\n    if (mustBe !== null) throw new Error(`\"${key}\" must be ${mustBe}`);\n    return value;\n  }\n  function checkForInvalidFlags(object, keys, where) {\n    for (let key in object) {\n      if (!(key in keys)) {\n        throw new Error(`Invalid option ${where}: \"${key}\"`);\n      }\n    }\n  }\n  function validateInitializeOptions(options) {\n    let keys = /* @__PURE__ */Object.create(null);\n    let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n    let wasmModule = getFlag(options, keys, \"wasmModule\", mustBeWebAssemblyModule);\n    let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, \"in initialize() call\");\n    return {\n      wasmURL,\n      wasmModule,\n      worker\n    };\n  }\n  function validateMangleCache(mangleCache) {\n    let validated;\n    if (mangleCache !== void 0) {\n      validated = /* @__PURE__ */Object.create(null);\n      for (let key of Object.keys(mangleCache)) {\n        let value = mangleCache[key];\n        if (typeof value === \"string\" || value === false) {\n          validated[key] = value;\n        } else {\n          throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);\n        }\n      }\n    }\n    return validated;\n  }\n  function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n    let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n    if (color !== void 0) flags.push(`--color=${color}`);else if (isTTY) flags.push(`--color=true`);\n    flags.push(`--log-level=${logLevel || logLevelDefault}`);\n    flags.push(`--log-limit=${logLimit || 0}`);\n  }\n  function pushCommonFlags(flags, options, keys) {\n    let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n    let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n    let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n    let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n    let format = getFlag(options, keys, \"format\", mustBeString);\n    let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n    let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n    let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n    let mangleQuoted = getFlag(options, keys, \"mangleQuoted\", mustBeBoolean);\n    let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n    let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n    let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n    let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n    let drop = getFlag(options, keys, \"drop\", mustBeArray);\n    let charset = getFlag(options, keys, \"charset\", mustBeString);\n    let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n    let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n    let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n    let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n    let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n    let jsxImportSource = getFlag(options, keys, \"jsxImportSource\", mustBeString);\n    let jsxDev = getFlag(options, keys, \"jsxDev\", mustBeBoolean);\n    let jsxSideEffects = getFlag(options, keys, \"jsxSideEffects\", mustBeBoolean);\n    let define = getFlag(options, keys, \"define\", mustBeObject);\n    let logOverride = getFlag(options, keys, \"logOverride\", mustBeObject);\n    let supported = getFlag(options, keys, \"supported\", mustBeObject);\n    let pure = getFlag(options, keys, \"pure\", mustBeArray);\n    let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n    let platform = getFlag(options, keys, \"platform\", mustBeString);\n    if (legalComments) flags.push(`--legal-comments=${legalComments}`);\n    if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);\n    if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);\n    if (target) {\n      if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);else flags.push(`--target=${validateTarget(target)}`);\n    }\n    if (format) flags.push(`--format=${format}`);\n    if (globalName) flags.push(`--global-name=${globalName}`);\n    if (platform) flags.push(`--platform=${platform}`);\n    if (minify) flags.push(\"--minify\");\n    if (minifySyntax) flags.push(\"--minify-syntax\");\n    if (minifyWhitespace) flags.push(\"--minify-whitespace\");\n    if (minifyIdentifiers) flags.push(\"--minify-identifiers\");\n    if (charset) flags.push(`--charset=${charset}`);\n    if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);\n    if (ignoreAnnotations) flags.push(`--ignore-annotations`);\n    if (drop) for (let what of drop) flags.push(`--drop:${what}`);\n    if (mangleProps) flags.push(`--mangle-props=${mangleProps.source}`);\n    if (reserveProps) flags.push(`--reserve-props=${reserveProps.source}`);\n    if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);\n    if (jsx) flags.push(`--jsx=${jsx}`);\n    if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);\n    if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);\n    if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);\n    if (jsxDev) flags.push(`--jsx-dev`);\n    if (jsxSideEffects) flags.push(`--jsx-side-effects`);\n    if (define) {\n      for (let key in define) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid define: ${key}`);\n        flags.push(`--define:${key}=${define[key]}`);\n      }\n    }\n    if (logOverride) {\n      for (let key in logOverride) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid log override: ${key}`);\n        flags.push(`--log-override:${key}=${logOverride[key]}`);\n      }\n    }\n    if (supported) {\n      for (let key in supported) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid supported: ${key}`);\n        flags.push(`--supported:${key}=${supported[key]}`);\n      }\n    }\n    if (pure) for (let fn of pure) flags.push(`--pure:${fn}`);\n    if (keepNames) flags.push(`--keep-names`);\n  }\n  function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n    var _a;\n    let flags = [];\n    let entries = [];\n    let keys = /* @__PURE__ */Object.create(null);\n    let stdinContents = null;\n    let stdinResolveDir = null;\n    let watchMode = null;\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n    let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n    let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n    let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n    let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n    let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n    let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n    let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n    let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n    let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n    let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n    let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n    let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n    let external = getFlag(options, keys, \"external\", mustBeArray);\n    let loader = getFlag(options, keys, \"loader\", mustBeObject);\n    let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n    let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n    let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n    let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n    let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n    let inject = getFlag(options, keys, \"inject\", mustBeArray);\n    let banner = getFlag(options, keys, \"banner\", mustBeObject);\n    let footer = getFlag(options, keys, \"footer\", mustBeObject);\n    let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n    let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n    let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n    let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n    let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n    let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n    let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n    keys.plugins = true;\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n    if (bundle) flags.push(\"--bundle\");\n    if (allowOverwrite) flags.push(\"--allow-overwrite\");\n    if (watch) {\n      flags.push(\"--watch\");\n      if (typeof watch === \"boolean\") {\n        watchMode = {};\n      } else {\n        let watchKeys = /* @__PURE__ */Object.create(null);\n        let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n        checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n        watchMode = {\n          onRebuild\n        };\n      }\n    }\n    if (splitting) flags.push(\"--splitting\");\n    if (preserveSymlinks) flags.push(\"--preserve-symlinks\");\n    if (metafile) flags.push(`--metafile`);\n    if (outfile) flags.push(`--outfile=${outfile}`);\n    if (outdir) flags.push(`--outdir=${outdir}`);\n    if (outbase) flags.push(`--outbase=${outbase}`);\n    if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);\n    if (resolveExtensions) {\n      let values = [];\n      for (let value of resolveExtensions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid resolve extension: ${value}`);\n        values.push(value);\n      }\n      flags.push(`--resolve-extensions=${values.join(\",\")}`);\n    }\n    if (publicPath) flags.push(`--public-path=${publicPath}`);\n    if (entryNames) flags.push(`--entry-names=${entryNames}`);\n    if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);\n    if (assetNames) flags.push(`--asset-names=${assetNames}`);\n    if (mainFields) {\n      let values = [];\n      for (let value of mainFields) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid main field: ${value}`);\n        values.push(value);\n      }\n      flags.push(`--main-fields=${values.join(\",\")}`);\n    }\n    if (conditions) {\n      let values = [];\n      for (let value of conditions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid condition: ${value}`);\n        values.push(value);\n      }\n      flags.push(`--conditions=${values.join(\",\")}`);\n    }\n    if (external) for (let name of external) flags.push(`--external:${name}`);\n    if (banner) {\n      for (let type in banner) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid banner file type: ${type}`);\n        flags.push(`--banner:${type}=${banner[type]}`);\n      }\n    }\n    if (footer) {\n      for (let type in footer) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid footer file type: ${type}`);\n        flags.push(`--footer:${type}=${footer[type]}`);\n      }\n    }\n    if (inject) for (let path of inject) flags.push(`--inject:${path}`);\n    if (loader) {\n      for (let ext in loader) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid loader extension: ${ext}`);\n        flags.push(`--loader:${ext}=${loader[ext]}`);\n      }\n    }\n    if (outExtension) {\n      for (let ext in outExtension) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid out extension: ${ext}`);\n        flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n      }\n    }\n    if (entryPoints) {\n      if (Array.isArray(entryPoints)) {\n        for (let entryPoint of entryPoints) {\n          entries.push([\"\", entryPoint + \"\"]);\n        }\n      } else {\n        for (let [key, value] of Object.entries(entryPoints)) {\n          entries.push([key + \"\", value + \"\"]);\n        }\n      }\n    }\n    if (stdin) {\n      let stdinKeys = /* @__PURE__ */Object.create(null);\n      let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeStringOrUint8Array);\n      let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n      let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n      let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n      checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n      if (loader2) flags.push(`--loader=${loader2}`);\n      if (resolveDir) stdinResolveDir = resolveDir + \"\";\n      if (typeof contents === \"string\") stdinContents = encodeUTF8(contents);else if (contents instanceof Uint8Array) stdinContents = contents;\n    }\n    let nodePaths = [];\n    if (nodePathsInput) {\n      for (let value of nodePathsInput) {\n        value += \"\";\n        nodePaths.push(value);\n      }\n    }\n    return {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch: watchMode,\n      mangleCache: validateMangleCache(mangleCache)\n    };\n  }\n  function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n    let flags = [];\n    let keys = /* @__PURE__ */Object.create(null);\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n    let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n    let loader = getFlag(options, keys, \"loader\", mustBeString);\n    let banner = getFlag(options, keys, \"banner\", mustBeString);\n    let footer = getFlag(options, keys, \"footer\", mustBeString);\n    let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n    if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n    if (loader) flags.push(`--loader=${loader}`);\n    if (banner) flags.push(`--banner=${banner}`);\n    if (footer) flags.push(`--footer=${footer}`);\n    return {\n      flags,\n      mangleCache: validateMangleCache(mangleCache)\n    };\n  }\n  function createChannel(streamIn) {\n    const requestCallbacksByKey = {};\n    const closeData = {\n      didClose: false,\n      reason: \"\"\n    };\n    let responseCallbacks = {};\n    let nextRequestID = 0;\n    let nextBuildKey = 0;\n    let stdout = new Uint8Array(16 * 1024);\n    let stdoutUsed = 0;\n    let readFromStdout = chunk => {\n      let limit = stdoutUsed + chunk.length;\n      if (limit > stdout.length) {\n        let swap = new Uint8Array(limit * 2);\n        swap.set(stdout);\n        stdout = swap;\n      }\n      stdout.set(chunk, stdoutUsed);\n      stdoutUsed += chunk.length;\n      let offset = 0;\n      while (offset + 4 <= stdoutUsed) {\n        let length = readUInt32LE(stdout, offset);\n        if (offset + 4 + length > stdoutUsed) {\n          break;\n        }\n        offset += 4;\n        handleIncomingPacket(stdout.subarray(offset, offset + length));\n        offset += length;\n      }\n      if (offset > 0) {\n        stdout.copyWithin(0, offset, stdoutUsed);\n        stdoutUsed -= offset;\n      }\n    };\n    let afterClose = error => {\n      closeData.didClose = true;\n      if (error) closeData.reason = \": \" + (error.message || error);\n      const text = \"The service was stopped\" + closeData.reason;\n      for (let id in responseCallbacks) {\n        responseCallbacks[id](text, null);\n      }\n      responseCallbacks = {};\n    };\n    let sendRequest = (refs, value, callback) => {\n      if (closeData.didClose) return callback(\"The service is no longer running\" + closeData.reason, null);\n      let id = nextRequestID++;\n      responseCallbacks[id] = (error, response) => {\n        try {\n          callback(error, response);\n        } finally {\n          if (refs) refs.unref();\n        }\n      };\n      if (refs) refs.ref();\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: true,\n        value\n      }));\n    };\n    let sendResponse = (id, value) => {\n      if (closeData.didClose) throw new Error(\"The service is no longer running\" + closeData.reason);\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: false,\n        value\n      }));\n    };\n    let handleRequest = (id, request) => __async(this, null, function* () {\n      try {\n        if (request.command === \"ping\") {\n          sendResponse(id, {});\n          return;\n        }\n        if (typeof request.key === \"number\") {\n          const requestCallbacks = requestCallbacksByKey[request.key];\n          if (requestCallbacks) {\n            const callback = requestCallbacks[request.command];\n            if (callback) {\n              yield callback(id, request);\n              return;\n            }\n          }\n        }\n        throw new Error(`Invalid command: ` + request.command);\n      } catch (e) {\n        sendResponse(id, {\n          errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")]\n        });\n      }\n    });\n    let isFirstPacket = true;\n    let handleIncomingPacket = bytes => {\n      if (isFirstPacket) {\n        isFirstPacket = false;\n        let binaryVersion = String.fromCharCode(...bytes);\n        if (binaryVersion !== \"0.15.13\") {\n          throw new Error(`Cannot start service: Host version \"${\"0.15.13\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n        }\n        return;\n      }\n      let packet = decodePacket(bytes);\n      if (packet.isRequest) {\n        handleRequest(packet.id, packet.value);\n      } else {\n        let callback = responseCallbacks[packet.id];\n        delete responseCallbacks[packet.id];\n        if (packet.value.error) callback(packet.value.error, {});else callback(null, packet.value);\n      }\n    };\n    let buildOrServe = ({\n      callName,\n      refs,\n      serveOptions,\n      options,\n      isTTY,\n      defaultWD,\n      callback\n    }) => {\n      let refCount = 0;\n      const buildKey = nextBuildKey++;\n      const requestCallbacks = {};\n      const buildRefs = {\n        ref() {\n          if (++refCount === 1) {\n            if (refs) refs.ref();\n          }\n        },\n        unref() {\n          if (--refCount === 0) {\n            delete requestCallbacksByKey[buildKey];\n            if (refs) refs.unref();\n          }\n        }\n      };\n      requestCallbacksByKey[buildKey] = requestCallbacks;\n      buildRefs.ref();\n      buildOrServeImpl(callName, buildKey, sendRequest, sendResponse, buildRefs, streamIn, requestCallbacks, options, serveOptions, isTTY, defaultWD, closeData, (err, res) => {\n        try {\n          callback(err, res);\n        } finally {\n          buildRefs.unref();\n        }\n      });\n    };\n    let transform2 = ({\n      callName,\n      refs,\n      input,\n      options,\n      isTTY,\n      fs,\n      callback\n    }) => {\n      const details = createObjectStash();\n      let start = inputPath => {\n        try {\n          if (typeof input !== \"string\" && !(input instanceof Uint8Array)) throw new Error('The input to \"transform\" must be a string or a Uint8Array');\n          let {\n            flags,\n            mangleCache\n          } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n          let request = {\n            command: \"transform\",\n            flags,\n            inputFS: inputPath !== null,\n            input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === \"string\" ? encodeUTF8(input) : input\n          };\n          if (mangleCache) request.mangleCache = mangleCache;\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            let errors = replaceDetailsInMessages(response.errors, details);\n            let warnings = replaceDetailsInMessages(response.warnings, details);\n            let outstanding = 1;\n            let next = () => {\n              if (--outstanding === 0) {\n                let result = {\n                  warnings,\n                  code: response.code,\n                  map: response.map\n                };\n                if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;\n                callback(null, result);\n              }\n            };\n            if (errors.length > 0) return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n            if (response.codeFS) {\n              outstanding++;\n              fs.readFile(response.code, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.code = contents;\n                  next();\n                }\n              });\n            }\n            if (response.mapFS) {\n              outstanding++;\n              fs.readFile(response.map, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.map = contents;\n                  next();\n                }\n              });\n            }\n            next();\n          });\n        } catch (e) {\n          let flags = [];\n          try {\n            pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n          } catch (e2) {}\n          const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n          sendRequest(refs, {\n            command: \"error\",\n            flags,\n            error\n          }, () => {\n            error.detail = details.load(error.detail);\n            callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n          });\n        }\n      };\n      if ((typeof input === \"string\" || input instanceof Uint8Array) && input.length > 1024 * 1024) {\n        let next = start;\n        start = () => fs.writeFile(input, next);\n      }\n      start(null);\n    };\n    let formatMessages2 = ({\n      callName,\n      refs,\n      messages,\n      options,\n      callback\n    }) => {\n      let result = sanitizeMessages(messages, \"messages\", null, \"\");\n      if (!options) throw new Error(`Missing second argument in ${callName}() call`);\n      let keys = {};\n      let kind = getFlag(options, keys, \"kind\", mustBeString);\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      if (kind === void 0) throw new Error(`Missing \"kind\" in ${callName}() call`);\n      if (kind !== \"error\" && kind !== \"warning\") throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n      let request = {\n        command: \"format-msgs\",\n        messages: result,\n        isWarning: kind === \"warning\"\n      };\n      if (color !== void 0) request.color = color;\n      if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.messages);\n      });\n    };\n    let analyzeMetafile2 = ({\n      callName,\n      refs,\n      metafile,\n      options,\n      callback\n    }) => {\n      if (options === void 0) options = {};\n      let keys = {};\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      let request = {\n        command: \"analyze-metafile\",\n        metafile\n      };\n      if (color !== void 0) request.color = color;\n      if (verbose !== void 0) request.verbose = verbose;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.result);\n      });\n    };\n    return {\n      readFromStdout,\n      afterClose,\n      service: {\n        buildOrServe,\n        transform: transform2,\n        formatMessages: formatMessages2,\n        analyzeMetafile: analyzeMetafile2\n      }\n    };\n  }\n  function buildOrServeImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, serveOptions, isTTY, defaultWD, closeData, callback) {\n    const details = createObjectStash();\n    const logPluginError = (e, pluginName, note, done) => {\n      const flags = [];\n      try {\n        pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n      } catch (e2) {}\n      const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n      sendRequest(refs, {\n        command: \"error\",\n        flags,\n        error: message\n      }, () => {\n        message.detail = details.load(message.detail);\n        done(message);\n      });\n    };\n    const handleError = (e, pluginName) => {\n      logPluginError(e, pluginName, void 0, error => {\n        callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n      });\n    };\n    let plugins;\n    if (typeof options === \"object\") {\n      const value = options.plugins;\n      if (value !== void 0) {\n        if (!Array.isArray(value)) throw new Error(`\"plugins\" must be an array`);\n        plugins = value;\n      }\n    }\n    if (plugins && plugins.length > 0) {\n      if (streamIn.isSync) {\n        handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n        return;\n      }\n      handlePlugins(buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, plugins, details).then(result => {\n        if (!result.ok) {\n          handleError(result.error, result.pluginName);\n          return;\n        }\n        try {\n          buildOrServeContinue(result.requestPlugins, result.runOnEndCallbacks);\n        } catch (e) {\n          handleError(e, \"\");\n        }\n      }, e => handleError(e, \"\"));\n      return;\n    }\n    try {\n      buildOrServeContinue(null, (result, logPluginError2, done) => done());\n    } catch (e) {\n      handleError(e, \"\");\n    }\n    function buildOrServeContinue(requestPlugins, runOnEndCallbacks) {\n      let writeDefault = !streamIn.isWriteUnavailable;\n      let {\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir,\n        incremental,\n        nodePaths,\n        watch,\n        mangleCache\n      } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n      let request = {\n        command: \"build\",\n        key: buildKey,\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir: absWorkingDir || defaultWD,\n        incremental,\n        nodePaths\n      };\n      if (requestPlugins) request.plugins = requestPlugins;\n      if (mangleCache) request.mangleCache = mangleCache;\n      let serve2 = serveOptions && buildServeData(buildKey, sendRequest, sendResponse, refs, requestCallbacks, serveOptions, request);\n      let rebuild;\n      let stop;\n      let copyResponseToResult = (response, result) => {\n        if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);\n        if (response.metafile) result.metafile = JSON.parse(response.metafile);\n        if (response.mangleCache) result.mangleCache = response.mangleCache;\n        if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n      };\n      let buildResponseToResult = (response, callback2) => {\n        let result = {\n          errors: replaceDetailsInMessages(response.errors, details),\n          warnings: replaceDetailsInMessages(response.warnings, details)\n        };\n        copyResponseToResult(response, result);\n        runOnEndCallbacks(result, logPluginError, () => {\n          if (result.errors.length > 0) {\n            return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n          }\n          if (response.rebuild) {\n            if (!rebuild) {\n              let isDisposed = false;\n              rebuild = () => new Promise((resolve, reject) => {\n                if (isDisposed || closeData.didClose) throw new Error(\"Cannot rebuild\");\n                sendRequest(refs, {\n                  command: \"rebuild\",\n                  key: buildKey\n                }, (error2, response2) => {\n                  if (error2) {\n                    const message = {\n                      id: \"\",\n                      pluginName: \"\",\n                      text: error2,\n                      location: null,\n                      notes: [],\n                      detail: void 0\n                    };\n                    return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                  }\n                  buildResponseToResult(response2, (error3, result3) => {\n                    if (error3) reject(error3);else resolve(result3);\n                  });\n                });\n              });\n              refs.ref();\n              rebuild.dispose = () => {\n                if (isDisposed) return;\n                isDisposed = true;\n                sendRequest(refs, {\n                  command: \"rebuild-dispose\",\n                  key: buildKey\n                }, () => {});\n                refs.unref();\n              };\n            }\n            result.rebuild = rebuild;\n          }\n          if (response.watch) {\n            if (!stop) {\n              let isStopped = false;\n              refs.ref();\n              stop = () => {\n                if (isStopped) return;\n                isStopped = true;\n                delete requestCallbacks[\"watch-rebuild\"];\n                sendRequest(refs, {\n                  command: \"watch-stop\",\n                  key: buildKey\n                }, () => {});\n                refs.unref();\n              };\n              if (watch) {\n                requestCallbacks[\"watch-rebuild\"] = (id, request2) => {\n                  try {\n                    let watchResponse = request2.args;\n                    let result2 = {\n                      errors: replaceDetailsInMessages(watchResponse.errors, details),\n                      warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                    };\n                    copyResponseToResult(watchResponse, result2);\n                    runOnEndCallbacks(result2, logPluginError, () => {\n                      if (result2.errors.length > 0) {\n                        if (watch.onRebuild) watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                        return;\n                      }\n                      result2.stop = stop;\n                      if (watch.onRebuild) watch.onRebuild(null, result2);\n                    });\n                  } catch (err) {\n                    console.error(err);\n                  }\n                  sendResponse(id, {});\n                };\n              }\n            }\n            result.stop = stop;\n          }\n          callback2(null, result);\n        });\n      };\n      if (write && streamIn.isWriteUnavailable) throw new Error(`The \"write\" option is unavailable in this environment`);\n      if (incremental && streamIn.isSync) throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n      if (watch && streamIn.isSync) throw new Error(`Cannot use \"watch\" with a synchronous build`);\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        if (serve2) {\n          let serveResponse = response;\n          let isStopped = false;\n          refs.ref();\n          let result = {\n            port: serveResponse.port,\n            host: serveResponse.host,\n            wait: serve2.wait,\n            stop() {\n              if (isStopped) return;\n              isStopped = true;\n              serve2.stop();\n              refs.unref();\n            }\n          };\n          refs.ref();\n          serve2.wait.then(refs.unref, refs.unref);\n          return callback(null, result);\n        }\n        return buildResponseToResult(response, callback);\n      });\n    }\n  }\n  var buildServeData = (buildKey, sendRequest, sendResponse, refs, requestCallbacks, options, request) => {\n    let keys = {};\n    let port = getFlag(options, keys, \"port\", mustBeInteger);\n    let host = getFlag(options, keys, \"host\", mustBeString);\n    let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n    let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n    let wait = new Promise((resolve, reject) => {\n      requestCallbacks[\"serve-wait\"] = (id, request2) => {\n        if (request2.error !== null) reject(new Error(request2.error));else resolve();\n        sendResponse(id, {});\n      };\n    });\n    request.serve = {};\n    checkForInvalidFlags(options, keys, `in serve() call`);\n    if (port !== void 0) request.serve.port = port;\n    if (host !== void 0) request.serve.host = host;\n    if (servedir !== void 0) request.serve.servedir = servedir;\n    requestCallbacks[\"serve-request\"] = (id, request2) => {\n      if (onRequest) onRequest(request2.args);\n      sendResponse(id, {});\n    };\n    return {\n      wait,\n      stop() {\n        sendRequest(refs, {\n          command: \"serve-stop\",\n          key: buildKey\n        }, () => {});\n      }\n    };\n  };\n  var handlePlugins = (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => __async(void 0, null, function* () {\n    let onStartCallbacks = [];\n    let onEndCallbacks = [];\n    let onResolveCallbacks = {};\n    let onLoadCallbacks = {};\n    let nextCallbackID = 0;\n    let i = 0;\n    let requestPlugins = [];\n    let isSetupDone = false;\n    plugins = [...plugins];\n    for (let item of plugins) {\n      let keys = {};\n      if (typeof item !== \"object\") throw new Error(`Plugin at index ${i} must be an object`);\n      const name = getFlag(item, keys, \"name\", mustBeString);\n      if (typeof name !== \"string\" || name === \"\") throw new Error(`Plugin at index ${i} is missing a name`);\n      try {\n        let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n        if (typeof setup !== \"function\") throw new Error(`Plugin is missing a setup function`);\n        checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n        let plugin = {\n          name,\n          onResolve: [],\n          onLoad: []\n        };\n        i++;\n        let resolve = (path, options = {}) => {\n          if (!isSetupDone) throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n          if (typeof path !== \"string\") throw new Error(`The path to resolve must be a string`);\n          let keys2 = /* @__PURE__ */Object.create(null);\n          let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n          let importer = getFlag(options, keys2, \"importer\", mustBeString);\n          let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n          let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n          let kind = getFlag(options, keys2, \"kind\", mustBeString);\n          let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n          checkForInvalidFlags(options, keys2, \"in resolve() call\");\n          return new Promise((resolve2, reject) => {\n            const request = {\n              command: \"resolve\",\n              path,\n              key: buildKey,\n              pluginName: name\n            };\n            if (pluginName != null) request.pluginName = pluginName;\n            if (importer != null) request.importer = importer;\n            if (namespace != null) request.namespace = namespace;\n            if (resolveDir != null) request.resolveDir = resolveDir;\n            if (kind != null) request.kind = kind;\n            if (pluginData != null) request.pluginData = details.store(pluginData);\n            sendRequest(refs, request, (error, response) => {\n              if (error !== null) reject(new Error(error));else resolve2({\n                errors: replaceDetailsInMessages(response.errors, details),\n                warnings: replaceDetailsInMessages(response.warnings, details),\n                path: response.path,\n                external: response.external,\n                sideEffects: response.sideEffects,\n                namespace: response.namespace,\n                suffix: response.suffix,\n                pluginData: details.load(response.pluginData)\n              });\n            });\n          });\n        };\n        let promise = setup({\n          initialOptions,\n          resolve,\n          onStart(callback) {\n            let registeredText = `This error came from the \"onStart\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n            onStartCallbacks.push({\n              name,\n              callback,\n              note: registeredNote\n            });\n          },\n          onEnd(callback) {\n            let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n            onEndCallbacks.push({\n              name,\n              callback,\n              note: registeredNote\n            });\n          },\n          onResolve(options, callback) {\n            let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null) throw new Error(`onResolve() call is missing a filter`);\n            let id = nextCallbackID++;\n            onResolveCallbacks[id] = {\n              name,\n              callback,\n              note: registeredNote\n            };\n            plugin.onResolve.push({\n              id,\n              filter: filter.source,\n              namespace: namespace || \"\"\n            });\n          },\n          onLoad(options, callback) {\n            let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null) throw new Error(`onLoad() call is missing a filter`);\n            let id = nextCallbackID++;\n            onLoadCallbacks[id] = {\n              name,\n              callback,\n              note: registeredNote\n            };\n            plugin.onLoad.push({\n              id,\n              filter: filter.source,\n              namespace: namespace || \"\"\n            });\n          },\n          esbuild: streamIn.esbuild\n        });\n        if (promise) yield promise;\n        requestPlugins.push(plugin);\n      } catch (e) {\n        return {\n          ok: false,\n          error: e,\n          pluginName: name\n        };\n      }\n    }\n    requestCallbacks[\"on-start\"] = (id, request) => __async(void 0, null, function* () {\n      let response = {\n        errors: [],\n        warnings: []\n      };\n      yield Promise.all(onStartCallbacks.map(_0 => __async(void 0, [_0], function* ({\n        name,\n        callback,\n        note\n      }) {\n        try {\n          let result = yield callback();\n          if (result != null) {\n            if (typeof result !== \"object\") throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n            let keys = {};\n            let errors = getFlag(result, keys, \"errors\", mustBeArray);\n            let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n            checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n            if (errors != null) response.errors.push(...sanitizeMessages(errors, \"errors\", details, name));\n            if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, \"warnings\", details, name));\n          }\n        } catch (e) {\n          response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));\n        }\n      })));\n      sendResponse(id, response);\n    });\n    requestCallbacks[\"on-resolve\"] = (id, request) => __async(void 0, null, function* () {\n      let response = {},\n        name = \"\",\n        callback,\n        note;\n      for (let id2 of request.ids) {\n        try {\n          ({\n            name,\n            callback,\n            note\n          } = onResolveCallbacks[id2]);\n          let result = yield callback({\n            path: request.path,\n            importer: request.importer,\n            namespace: request.namespace,\n            resolveDir: request.resolveDir,\n            kind: request.kind,\n            pluginData: details.load(request.pluginData)\n          });\n          if (result != null) {\n            if (typeof result !== \"object\") throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n            let keys = {};\n            let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n            let path = getFlag(result, keys, \"path\", mustBeString);\n            let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n            let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n            let external = getFlag(result, keys, \"external\", mustBeBoolean);\n            let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n            let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n            let errors = getFlag(result, keys, \"errors\", mustBeArray);\n            let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n            let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n            let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n            checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n            response.id = id2;\n            if (pluginName != null) response.pluginName = pluginName;\n            if (path != null) response.path = path;\n            if (namespace != null) response.namespace = namespace;\n            if (suffix != null) response.suffix = suffix;\n            if (external != null) response.external = external;\n            if (sideEffects != null) response.sideEffects = sideEffects;\n            if (pluginData != null) response.pluginData = details.store(pluginData);\n            if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", details, name);\n            if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", details, name);\n            if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n            if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n            break;\n          }\n        } catch (e) {\n          response = {\n            id: id2,\n            errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)]\n          };\n          break;\n        }\n      }\n      sendResponse(id, response);\n    });\n    requestCallbacks[\"on-load\"] = (id, request) => __async(void 0, null, function* () {\n      let response = {},\n        name = \"\",\n        callback,\n        note;\n      for (let id2 of request.ids) {\n        try {\n          ({\n            name,\n            callback,\n            note\n          } = onLoadCallbacks[id2]);\n          let result = yield callback({\n            path: request.path,\n            namespace: request.namespace,\n            suffix: request.suffix,\n            pluginData: details.load(request.pluginData)\n          });\n          if (result != null) {\n            if (typeof result !== \"object\") throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n            let keys = {};\n            let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n            let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n            let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n            let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n            let loader = getFlag(result, keys, \"loader\", mustBeString);\n            let errors = getFlag(result, keys, \"errors\", mustBeArray);\n            let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n            let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n            let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n            checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n            response.id = id2;\n            if (pluginName != null) response.pluginName = pluginName;\n            if (contents instanceof Uint8Array) response.contents = contents;else if (contents != null) response.contents = encodeUTF8(contents);\n            if (resolveDir != null) response.resolveDir = resolveDir;\n            if (pluginData != null) response.pluginData = details.store(pluginData);\n            if (loader != null) response.loader = loader;\n            if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", details, name);\n            if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", details, name);\n            if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n            if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n            break;\n          }\n        } catch (e) {\n          response = {\n            id: id2,\n            errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)]\n          };\n          break;\n        }\n      }\n      sendResponse(id, response);\n    });\n    let runOnEndCallbacks = (result, logPluginError, done) => done();\n    if (onEndCallbacks.length > 0) {\n      runOnEndCallbacks = (result, logPluginError, done) => {\n        (() => __async(void 0, null, function* () {\n          for (const {\n            name,\n            callback,\n            note\n          } of onEndCallbacks) {\n            try {\n              yield callback(result);\n            } catch (e) {\n              result.errors.push(yield new Promise(resolve => logPluginError(e, name, note && note(), resolve)));\n            }\n          }\n        }))().then(done);\n      };\n    }\n    isSetupDone = true;\n    return {\n      ok: true,\n      requestPlugins,\n      runOnEndCallbacks\n    };\n  });\n  function createObjectStash() {\n    const map = /* @__PURE__ */new Map();\n    let nextID = 0;\n    return {\n      load(id) {\n        return map.get(id);\n      },\n      store(value) {\n        if (value === void 0) return -1;\n        const id = nextID++;\n        map.set(id, value);\n        return id;\n      }\n    };\n  }\n  function extractCallerV8(e, streamIn, ident) {\n    let note;\n    let tried = false;\n    return () => {\n      if (tried) return note;\n      tried = true;\n      try {\n        let lines = (e.stack + \"\").split(\"\\n\");\n        lines.splice(1, 1);\n        let location = parseStackLinesV8(streamIn, lines, ident);\n        if (location) {\n          note = {\n            text: e.message,\n            location\n          };\n          return note;\n        }\n      } catch (e2) {}\n    };\n  }\n  function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n    let text = \"Internal error\";\n    let location = null;\n    try {\n      text = (e && e.message || e) + \"\";\n    } catch (e2) {}\n    try {\n      location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n    } catch (e2) {}\n    return {\n      id: \"\",\n      pluginName,\n      text,\n      location,\n      notes: note ? [note] : [],\n      detail: stash ? stash.store(e) : -1\n    };\n  }\n  function parseStackLinesV8(streamIn, lines, ident) {\n    let at = \"    at \";\n    if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n      for (let i = 1; i < lines.length; i++) {\n        let line = lines[i];\n        if (!line.startsWith(at)) continue;\n        line = line.slice(at.length);\n        while (true) {\n          let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n          if (match) {\n            line = match[1];\n            continue;\n          }\n          match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n          if (match) {\n            line = match[1];\n            continue;\n          }\n          match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n          if (match) {\n            let contents;\n            try {\n              contents = streamIn.readFileSync(match[1], \"utf8\");\n            } catch (e) {\n              break;\n            }\n            let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n            let column = +match[3] - 1;\n            let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n            return {\n              file: match[1],\n              namespace: \"file\",\n              line: +match[2],\n              column: encodeUTF8(lineText.slice(0, column)).length,\n              length: encodeUTF8(lineText.slice(column, column + length)).length,\n              lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n              suggestion: \"\"\n            };\n          }\n          break;\n        }\n      }\n    }\n    return null;\n  }\n  function failureErrorWithLog(text, errors, warnings) {\n    let limit = 5;\n    let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n      if (i === limit) return \"\\n...\";\n      if (!e.location) return `\nerror: ${e.text}`;\n      let {\n        file,\n        line,\n        column\n      } = e.location;\n      let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n      return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n    }).join(\"\");\n    let error = new Error(`${text}${summary}`);\n    error.errors = errors;\n    error.warnings = warnings;\n    return error;\n  }\n  function replaceDetailsInMessages(messages, stash) {\n    for (const message of messages) {\n      message.detail = stash.load(message.detail);\n    }\n    return messages;\n  }\n  function sanitizeLocation(location, where) {\n    if (location == null) return null;\n    let keys = {};\n    let file = getFlag(location, keys, \"file\", mustBeString);\n    let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n    let line = getFlag(location, keys, \"line\", mustBeInteger);\n    let column = getFlag(location, keys, \"column\", mustBeInteger);\n    let length = getFlag(location, keys, \"length\", mustBeInteger);\n    let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n    let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n    checkForInvalidFlags(location, keys, where);\n    return {\n      file: file || \"\",\n      namespace: namespace || \"\",\n      line: line || 0,\n      column: column || 0,\n      length: length || 0,\n      lineText: lineText || \"\",\n      suggestion: suggestion || \"\"\n    };\n  }\n  function sanitizeMessages(messages, property, stash, fallbackPluginName) {\n    let messagesClone = [];\n    let index = 0;\n    for (const message of messages) {\n      let keys = {};\n      let id = getFlag(message, keys, \"id\", mustBeString);\n      let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n      let text = getFlag(message, keys, \"text\", mustBeString);\n      let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n      let notes = getFlag(message, keys, \"notes\", mustBeArray);\n      let detail = getFlag(message, keys, \"detail\", canBeAnything);\n      let where = `in element ${index} of \"${property}\"`;\n      checkForInvalidFlags(message, keys, where);\n      let notesClone = [];\n      if (notes) {\n        for (const note of notes) {\n          let noteKeys = {};\n          let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n          let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n          checkForInvalidFlags(note, noteKeys, where);\n          notesClone.push({\n            text: noteText || \"\",\n            location: sanitizeLocation(noteLocation, where)\n          });\n        }\n      }\n      messagesClone.push({\n        id: id || \"\",\n        pluginName: pluginName || fallbackPluginName,\n        text: text || \"\",\n        location: sanitizeLocation(location, where),\n        notes: notesClone,\n        detail: stash ? stash.store(detail) : -1\n      });\n      index++;\n    }\n    return messagesClone;\n  }\n  function sanitizeStringArray(values, property) {\n    const result = [];\n    for (const value of values) {\n      if (typeof value !== \"string\") throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n      result.push(value);\n    }\n    return result;\n  }\n  function convertOutputFiles({\n    path,\n    contents\n  }) {\n    let text = null;\n    return {\n      path,\n      contents,\n      get text() {\n        const binary = this.contents;\n        if (text === null || binary !== contents) {\n          contents = binary;\n          text = decodeUTF8(binary);\n        }\n        return text;\n      }\n    };\n  }\n\n  // lib/npm/browser.ts\n  var version = \"0.15.13\";\n  var build = options => ensureServiceIsRunning().build(options);\n  var serve = () => {\n    throw new Error(`The \"serve\" API only works in node`);\n  };\n  var transform = (input, options) => ensureServiceIsRunning().transform(input, options);\n  var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\n  var analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\n  var buildSync = () => {\n    throw new Error(`The \"buildSync\" API only works in node`);\n  };\n  var transformSync = () => {\n    throw new Error(`The \"transformSync\" API only works in node`);\n  };\n  var formatMessagesSync = () => {\n    throw new Error(`The \"formatMessagesSync\" API only works in node`);\n  };\n  var analyzeMetafileSync = () => {\n    throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n  };\n  var initializePromise;\n  var longLivedService;\n  var ensureServiceIsRunning = () => {\n    if (longLivedService) return longLivedService;\n    if (initializePromise) throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n    throw new Error('You need to call \"initialize\" before calling this');\n  };\n  var initialize = options => {\n    options = validateInitializeOptions(options || {});\n    let wasmURL = options.wasmURL;\n    let wasmModule = options.wasmModule;\n    let useWorker = options.worker !== false;\n    if (!wasmURL && !wasmModule) throw new Error('Must provide either the \"wasmURL\" option or the \"wasmModule\" option');\n    if (initializePromise) throw new Error('Cannot call \"initialize\" more than once');\n    initializePromise = startRunningService(wasmURL || \"\", wasmModule, useWorker);\n    initializePromise.catch(() => {\n      initializePromise = void 0;\n    });\n    return initializePromise;\n  };\n  var startRunningService = (wasmURL, wasmModule, useWorker) => __async(void 0, null, function* () {\n    let wasm;\n    if (wasmModule) {\n      wasm = wasmModule;\n    } else {\n      let res = yield fetch(wasmURL);\n      if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n      wasm = yield res.arrayBuffer();\n    }\n    let worker;\n    if (useWorker) {\n      let blob = new Blob([`onmessage=${'((postMessage) => {\\n      // Copyright 2018 The Go Authors. All rights reserved.\\n      // Use of this source code is governed by a BSD-style\\n      // license that can be found in the LICENSE file.\\n      var __async = (__this, __arguments, generator) => {\\n        return new Promise((resolve, reject) => {\\n          var fulfilled = (value) => {\\n            try {\\n              step(generator.next(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var rejected = (value) => {\\n            try {\\n              step(generator.throw(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\\n          step((generator = generator.apply(__this, __arguments)).next());\\n        });\\n      };\\n      let onmessage;\\n      let globalThis = {};\\n      for (let o = self; o; o = Object.getPrototypeOf(o))\\n        for (let k of Object.getOwnPropertyNames(o))\\n          if (!(k in globalThis))\\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\\n      \"use strict\";\\n      (() => {\\n        const enosys = () => {\\n          const err = new Error(\"not implemented\");\\n          err.code = \"ENOSYS\";\\n          return err;\\n        };\\n        if (!globalThis.fs) {\\n          let outputBuf = \"\";\\n          globalThis.fs = {\\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\\n            writeSync(fd, buf) {\\n              outputBuf += decoder.decode(buf);\\n              const nl = outputBuf.lastIndexOf(\"\\\\n\");\\n              if (nl != -1) {\\n                console.log(outputBuf.substr(0, nl));\\n                outputBuf = outputBuf.substr(nl + 1);\\n              }\\n              return buf.length;\\n            },\\n            write(fd, buf, offset, length, position, callback) {\\n              if (offset !== 0 || length !== buf.length || position !== null) {\\n                callback(enosys());\\n                return;\\n              }\\n              const n = this.writeSync(fd, buf);\\n              callback(null, n);\\n            },\\n            chmod(path, mode, callback) {\\n              callback(enosys());\\n            },\\n            chown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            close(fd, callback) {\\n              callback(enosys());\\n            },\\n            fchmod(fd, mode, callback) {\\n              callback(enosys());\\n            },\\n            fchown(fd, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            fstat(fd, callback) {\\n              callback(enosys());\\n            },\\n            fsync(fd, callback) {\\n              callback(null);\\n            },\\n            ftruncate(fd, length, callback) {\\n              callback(enosys());\\n            },\\n            lchown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            link(path, link, callback) {\\n              callback(enosys());\\n            },\\n            lstat(path, callback) {\\n              callback(enosys());\\n            },\\n            mkdir(path, perm, callback) {\\n              callback(enosys());\\n            },\\n            open(path, flags, mode, callback) {\\n              callback(enosys());\\n            },\\n            read(fd, buffer, offset, length, position, callback) {\\n              callback(enosys());\\n            },\\n            readdir(path, callback) {\\n              callback(enosys());\\n            },\\n            readlink(path, callback) {\\n              callback(enosys());\\n            },\\n            rename(from, to, callback) {\\n              callback(enosys());\\n            },\\n            rmdir(path, callback) {\\n              callback(enosys());\\n            },\\n            stat(path, callback) {\\n              callback(enosys());\\n            },\\n            symlink(path, link, callback) {\\n              callback(enosys());\\n            },\\n            truncate(path, length, callback) {\\n              callback(enosys());\\n            },\\n            unlink(path, callback) {\\n              callback(enosys());\\n            },\\n            utimes(path, atime, mtime, callback) {\\n              callback(enosys());\\n            }\\n          };\\n        }\\n        if (!globalThis.process) {\\n          globalThis.process = {\\n            getuid() {\\n              return -1;\\n            },\\n            getgid() {\\n              return -1;\\n            },\\n            geteuid() {\\n              return -1;\\n            },\\n            getegid() {\\n              return -1;\\n            },\\n            getgroups() {\\n              throw enosys();\\n            },\\n            pid: -1,\\n            ppid: -1,\\n            umask() {\\n              throw enosys();\\n            },\\n            cwd() {\\n              throw enosys();\\n            },\\n            chdir() {\\n              throw enosys();\\n            }\\n          };\\n        }\\n        if (!globalThis.crypto) {\\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\\n        }\\n        if (!globalThis.performance) {\\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\\n        }\\n        if (!globalThis.TextEncoder) {\\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\\n        }\\n        if (!globalThis.TextDecoder) {\\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\\n        }\\n        const encoder = new TextEncoder(\"utf-8\");\\n        const decoder = new TextDecoder(\"utf-8\");\\n        globalThis.Go = class {\\n          constructor() {\\n            this.argv = [\"js\"];\\n            this.env = {};\\n            this.exit = (code) => {\\n              if (code !== 0) {\\n                console.warn(\"exit code:\", code);\\n              }\\n            };\\n            this._exitPromise = new Promise((resolve) => {\\n              this._resolveExitPromise = resolve;\\n            });\\n            this._pendingEvent = null;\\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\\n            this._nextCallbackTimeoutID = 1;\\n            const setInt64 = (addr, v) => {\\n              this.mem.setUint32(addr + 0, v, true);\\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\\n            };\\n            const getInt64 = (addr) => {\\n              const low = this.mem.getUint32(addr + 0, true);\\n              const high = this.mem.getInt32(addr + 4, true);\\n              return low + high * 4294967296;\\n            };\\n            const loadValue = (addr) => {\\n              const f = this.mem.getFloat64(addr, true);\\n              if (f === 0) {\\n                return void 0;\\n              }\\n              if (!isNaN(f)) {\\n                return f;\\n              }\\n              const id = this.mem.getUint32(addr, true);\\n              return this._values[id];\\n            };\\n            const storeValue = (addr, v) => {\\n              const nanHead = 2146959360;\\n              if (typeof v === \"number\" && v !== 0) {\\n                if (isNaN(v)) {\\n                  this.mem.setUint32(addr + 4, nanHead, true);\\n                  this.mem.setUint32(addr, 0, true);\\n                  return;\\n                }\\n                this.mem.setFloat64(addr, v, true);\\n                return;\\n              }\\n              if (v === void 0) {\\n                this.mem.setFloat64(addr, 0, true);\\n                return;\\n              }\\n              let id = this._ids.get(v);\\n              if (id === void 0) {\\n                id = this._idPool.pop();\\n                if (id === void 0) {\\n                  id = this._values.length;\\n                }\\n                this._values[id] = v;\\n                this._goRefCounts[id] = 0;\\n                this._ids.set(v, id);\\n              }\\n              this._goRefCounts[id]++;\\n              let typeFlag = 0;\\n              switch (typeof v) {\\n                case \"object\":\\n                  if (v !== null) {\\n                    typeFlag = 1;\\n                  }\\n                  break;\\n                case \"string\":\\n                  typeFlag = 2;\\n                  break;\\n                case \"symbol\":\\n                  typeFlag = 3;\\n                  break;\\n                case \"function\":\\n                  typeFlag = 4;\\n                  break;\\n              }\\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\\n              this.mem.setUint32(addr, id, true);\\n            };\\n            const loadSlice = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\\n            };\\n            const loadSliceOfValues = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              const a = new Array(len);\\n              for (let i = 0; i < len; i++) {\\n                a[i] = loadValue(array + i * 8);\\n              }\\n              return a;\\n            };\\n            const loadString = (addr) => {\\n              const saddr = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\\n            };\\n            const timeOrigin = Date.now() - performance.now();\\n            this.importObject = {\\n              go: {\\n                \"runtime.wasmExit\": (sp) => {\\n                  sp >>>= 0;\\n                  const code = this.mem.getInt32(sp + 8, true);\\n                  this.exited = true;\\n                  delete this._inst;\\n                  delete this._values;\\n                  delete this._goRefCounts;\\n                  delete this._ids;\\n                  delete this._idPool;\\n                  this.exit(code);\\n                },\\n                \"runtime.wasmWrite\": (sp) => {\\n                  sp >>>= 0;\\n                  const fd = getInt64(sp + 8);\\n                  const p = getInt64(sp + 16);\\n                  const n = this.mem.getInt32(sp + 24, true);\\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\\n                },\\n                \"runtime.resetMemoryDataView\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\\n                },\\n                \"runtime.nanotime1\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\\n                },\\n                \"runtime.walltime\": (sp) => {\\n                  sp >>>= 0;\\n                  const msec = new Date().getTime();\\n                  setInt64(sp + 8, msec / 1e3);\\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\\n                },\\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this._nextCallbackTimeoutID;\\n                  this._nextCallbackTimeoutID++;\\n                  this._scheduledTimeouts.set(id, setTimeout(\\n                    () => {\\n                      this._resume();\\n                      while (this._scheduledTimeouts.has(id)) {\\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\\n                        this._resume();\\n                      }\\n                    },\\n                    getInt64(sp + 8) + 1\\n                  ));\\n                  this.mem.setInt32(sp + 16, id, true);\\n                },\\n                \"runtime.clearTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getInt32(sp + 8, true);\\n                  clearTimeout(this._scheduledTimeouts.get(id));\\n                  this._scheduledTimeouts.delete(id);\\n                },\\n                \"runtime.getRandomData\": (sp) => {\\n                  sp >>>= 0;\\n                  crypto.getRandomValues(loadSlice(sp + 8));\\n                },\\n                \"syscall/js.finalizeRef\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getUint32(sp + 8, true);\\n                  this._goRefCounts[id]--;\\n                  if (this._goRefCounts[id] === 0) {\\n                    const v = this._values[id];\\n                    this._values[id] = null;\\n                    this._ids.delete(v);\\n                    this._idPool.push(id);\\n                  }\\n                },\\n                \"syscall/js.stringVal\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, loadString(sp + 8));\\n                },\\n                \"syscall/js.valueGet\": (sp) => {\\n                  sp >>>= 0;\\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\\n                  sp = this._inst.exports.getsp() >>> 0;\\n                  storeValue(sp + 32, result);\\n                },\\n                \"syscall/js.valueSet\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\\n                },\\n                \"syscall/js.valueDelete\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\\n                },\\n                \"syscall/js.valueIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\\n                },\\n                \"syscall/js.valueSetIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\\n                },\\n                \"syscall/js.valueCall\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const m = Reflect.get(v, loadString(sp + 16));\\n                    const args = loadSliceOfValues(sp + 32);\\n                    const result = Reflect.apply(m, v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, result);\\n                    this.mem.setUint8(sp + 64, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, err);\\n                    this.mem.setUint8(sp + 64, 0);\\n                  }\\n                },\\n                \"syscall/js.valueInvoke\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.apply(v, void 0, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueNew\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.construct(v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueLength\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\\n                },\\n                \"syscall/js.valuePrepareString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = encoder.encode(String(loadValue(sp + 8)));\\n                  storeValue(sp + 16, str);\\n                  setInt64(sp + 24, str.length);\\n                },\\n                \"syscall/js.valueLoadString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = loadValue(sp + 8);\\n                  loadSlice(sp + 16).set(str);\\n                },\\n                \"syscall/js.valueInstanceOf\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\\n                },\\n                \"syscall/js.copyBytesToGo\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadSlice(sp + 8);\\n                  const src = loadValue(sp + 32);\\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"syscall/js.copyBytesToJS\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadValue(sp + 8);\\n                  const src = loadSlice(sp + 16);\\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"debug\": (value) => {\\n                  console.log(value);\\n                }\\n              }\\n            };\\n          }\\n          run(instance) {\\n            return __async(this, null, function* () {\\n              if (!(instance instanceof WebAssembly.Instance)) {\\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\\n              }\\n              this._inst = instance;\\n              this.mem = new DataView(this._inst.exports.mem.buffer);\\n              this._values = [\\n                NaN,\\n                0,\\n                null,\\n                true,\\n                false,\\n                globalThis,\\n                this\\n              ];\\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\\n              this._ids = /* @__PURE__ */ new Map([\\n                [0, 1],\\n                [null, 2],\\n                [true, 3],\\n                [false, 4],\\n                [globalThis, 5],\\n                [this, 6]\\n              ]);\\n              this._idPool = [];\\n              this.exited = false;\\n              let offset = 4096;\\n              const strPtr = (str) => {\\n                const ptr = offset;\\n                const bytes = encoder.encode(str + \"\\\\0\");\\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\\n                offset += bytes.length;\\n                if (offset % 8 !== 0) {\\n                  offset += 8 - offset % 8;\\n                }\\n                return ptr;\\n              };\\n              const argc = this.argv.length;\\n              const argvPtrs = [];\\n              this.argv.forEach((arg) => {\\n                argvPtrs.push(strPtr(arg));\\n              });\\n              argvPtrs.push(0);\\n              const keys = Object.keys(this.env).sort();\\n              keys.forEach((key) => {\\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\\n              });\\n              argvPtrs.push(0);\\n              const argv = offset;\\n              argvPtrs.forEach((ptr) => {\\n                this.mem.setUint32(offset, ptr, true);\\n                this.mem.setUint32(offset + 4, 0, true);\\n                offset += 8;\\n              });\\n              const wasmMinDataAddr = 4096 + 8192;\\n              if (offset >= wasmMinDataAddr) {\\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\\n              }\\n              this._inst.exports.run(argc, argv);\\n              if (this.exited) {\\n                this._resolveExitPromise();\\n              }\\n              yield this._exitPromise;\\n            });\\n          }\\n          _resume() {\\n            if (this.exited) {\\n              throw new Error(\"Go program has already exited\");\\n            }\\n            this._inst.exports.resume();\\n            if (this.exited) {\\n              this._resolveExitPromise();\\n            }\\n          }\\n          _makeFuncWrapper(id) {\\n            const go = this;\\n            return function() {\\n              const event = { id, this: this, args: arguments };\\n              go._pendingEvent = event;\\n              go._resume();\\n              return event.result;\\n            };\\n          }\\n        };\\n      })();\\n      onmessage = ({ data: wasm }) => {\\n        let decoder = new TextDecoder();\\n        let fs = globalThis.fs;\\n        let stderr = \"\";\\n        fs.writeSync = (fd, buffer) => {\\n          if (fd === 1) {\\n            postMessage(buffer);\\n          } else if (fd === 2) {\\n            stderr += decoder.decode(buffer);\\n            let parts = stderr.split(\"\\\\n\");\\n            if (parts.length > 1)\\n              console.log(parts.slice(0, -1).join(\"\\\\n\"));\\n            stderr = parts[parts.length - 1];\\n          } else {\\n            throw new Error(\"Bad write\");\\n          }\\n          return buffer.length;\\n        };\\n        let stdin = [];\\n        let resumeStdin;\\n        let stdinPos = 0;\\n        onmessage = ({ data }) => {\\n          if (data.length > 0) {\\n            stdin.push(data);\\n            if (resumeStdin)\\n              resumeStdin();\\n          }\\n        };\\n        fs.read = (fd, buffer, offset, length, position, callback) => {\\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\\n            throw new Error(\"Bad read\");\\n          }\\n          if (stdin.length === 0) {\\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\\n            return;\\n          }\\n          let first = stdin[0];\\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\\n          stdinPos += count;\\n          if (stdinPos === first.length) {\\n            stdin.shift();\\n            stdinPos = 0;\\n          }\\n          callback(null, count);\\n        };\\n        let go = new globalThis.Go();\\n        go.argv = [\"\", `--service=${\"0.15.13\"}`];\\n        if (wasm instanceof WebAssembly.Module) {\\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\\n        } else {\\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\\n        }\\n      };\\n      return (m) => onmessage(m);\\n    })'}(postMessage)`], {\n        type: \"text/javascript\"\n      });\n      worker = new Worker(URL.createObjectURL(blob));\n    } else {\n      let onmessage = (postMessage => {\n        // Copyright 2018 The Go Authors. All rights reserved.\n        // Use of this source code is governed by a BSD-style\n        // license that can be found in the LICENSE file.\n        var __async = (__this, __arguments, generator) => {\n          return new Promise((resolve, reject) => {\n            var fulfilled = value => {\n              try {\n                step(generator.next(value));\n              } catch (e) {\n                reject(e);\n              }\n            };\n            var rejected = value => {\n              try {\n                step(generator.throw(value));\n              } catch (e) {\n                reject(e);\n              }\n            };\n            var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n            step((generator = generator.apply(__this, __arguments)).next());\n          });\n        };\n        let onmessage;\n        let globalThis = {};\n        for (let o = self; o; o = Object.getPrototypeOf(o)) for (let k of Object.getOwnPropertyNames(o)) if (!(k in globalThis)) Object.defineProperty(globalThis, k, {\n          get: () => self[k]\n        });\n        \"use strict\";\n        (() => {\n          const enosys = () => {\n            const err = new Error(\"not implemented\");\n            err.code = \"ENOSYS\";\n            return err;\n          };\n          if (!globalThis.fs) {\n            let outputBuf = \"\";\n            globalThis.fs = {\n              constants: {\n                O_WRONLY: -1,\n                O_RDWR: -1,\n                O_CREAT: -1,\n                O_TRUNC: -1,\n                O_APPEND: -1,\n                O_EXCL: -1\n              },\n              writeSync(fd, buf) {\n                outputBuf += decoder.decode(buf);\n                const nl = outputBuf.lastIndexOf(\"\\n\");\n                if (nl != -1) {\n                  console.log(outputBuf.substr(0, nl));\n                  outputBuf = outputBuf.substr(nl + 1);\n                }\n                return buf.length;\n              },\n              write(fd, buf, offset, length, position, callback) {\n                if (offset !== 0 || length !== buf.length || position !== null) {\n                  callback(enosys());\n                  return;\n                }\n                const n = this.writeSync(fd, buf);\n                callback(null, n);\n              },\n              chmod(path, mode, callback) {\n                callback(enosys());\n              },\n              chown(path, uid, gid, callback) {\n                callback(enosys());\n              },\n              close(fd, callback) {\n                callback(enosys());\n              },\n              fchmod(fd, mode, callback) {\n                callback(enosys());\n              },\n              fchown(fd, uid, gid, callback) {\n                callback(enosys());\n              },\n              fstat(fd, callback) {\n                callback(enosys());\n              },\n              fsync(fd, callback) {\n                callback(null);\n              },\n              ftruncate(fd, length, callback) {\n                callback(enosys());\n              },\n              lchown(path, uid, gid, callback) {\n                callback(enosys());\n              },\n              link(path, link, callback) {\n                callback(enosys());\n              },\n              lstat(path, callback) {\n                callback(enosys());\n              },\n              mkdir(path, perm, callback) {\n                callback(enosys());\n              },\n              open(path, flags, mode, callback) {\n                callback(enosys());\n              },\n              read(fd, buffer, offset, length, position, callback) {\n                callback(enosys());\n              },\n              readdir(path, callback) {\n                callback(enosys());\n              },\n              readlink(path, callback) {\n                callback(enosys());\n              },\n              rename(from, to, callback) {\n                callback(enosys());\n              },\n              rmdir(path, callback) {\n                callback(enosys());\n              },\n              stat(path, callback) {\n                callback(enosys());\n              },\n              symlink(path, link, callback) {\n                callback(enosys());\n              },\n              truncate(path, length, callback) {\n                callback(enosys());\n              },\n              unlink(path, callback) {\n                callback(enosys());\n              },\n              utimes(path, atime, mtime, callback) {\n                callback(enosys());\n              }\n            };\n          }\n          if (!globalThis.process) {\n            globalThis.process = {\n              getuid() {\n                return -1;\n              },\n              getgid() {\n                return -1;\n              },\n              geteuid() {\n                return -1;\n              },\n              getegid() {\n                return -1;\n              },\n              getgroups() {\n                throw enosys();\n              },\n              pid: -1,\n              ppid: -1,\n              umask() {\n                throw enosys();\n              },\n              cwd() {\n                throw enosys();\n              },\n              chdir() {\n                throw enosys();\n              }\n            };\n          }\n          if (!globalThis.crypto) {\n            throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n          }\n          if (!globalThis.performance) {\n            throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n          }\n          if (!globalThis.TextEncoder) {\n            throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n          }\n          if (!globalThis.TextDecoder) {\n            throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n          }\n          const encoder = new TextEncoder(\"utf-8\");\n          const decoder = new TextDecoder(\"utf-8\");\n          globalThis.Go = class {\n            constructor() {\n              this.argv = [\"js\"];\n              this.env = {};\n              this.exit = code => {\n                if (code !== 0) {\n                  console.warn(\"exit code:\", code);\n                }\n              };\n              this._exitPromise = new Promise(resolve => {\n                this._resolveExitPromise = resolve;\n              });\n              this._pendingEvent = null;\n              this._scheduledTimeouts = /* @__PURE__ */new Map();\n              this._nextCallbackTimeoutID = 1;\n              const setInt64 = (addr, v) => {\n                this.mem.setUint32(addr + 0, v, true);\n                this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n              };\n              const getInt64 = addr => {\n                const low = this.mem.getUint32(addr + 0, true);\n                const high = this.mem.getInt32(addr + 4, true);\n                return low + high * 4294967296;\n              };\n              const loadValue = addr => {\n                const f = this.mem.getFloat64(addr, true);\n                if (f === 0) {\n                  return void 0;\n                }\n                if (!isNaN(f)) {\n                  return f;\n                }\n                const id = this.mem.getUint32(addr, true);\n                return this._values[id];\n              };\n              const storeValue = (addr, v) => {\n                const nanHead = 2146959360;\n                if (typeof v === \"number\" && v !== 0) {\n                  if (isNaN(v)) {\n                    this.mem.setUint32(addr + 4, nanHead, true);\n                    this.mem.setUint32(addr, 0, true);\n                    return;\n                  }\n                  this.mem.setFloat64(addr, v, true);\n                  return;\n                }\n                if (v === void 0) {\n                  this.mem.setFloat64(addr, 0, true);\n                  return;\n                }\n                let id = this._ids.get(v);\n                if (id === void 0) {\n                  id = this._idPool.pop();\n                  if (id === void 0) {\n                    id = this._values.length;\n                  }\n                  this._values[id] = v;\n                  this._goRefCounts[id] = 0;\n                  this._ids.set(v, id);\n                }\n                this._goRefCounts[id]++;\n                let typeFlag = 0;\n                switch (typeof v) {\n                  case \"object\":\n                    if (v !== null) {\n                      typeFlag = 1;\n                    }\n                    break;\n                  case \"string\":\n                    typeFlag = 2;\n                    break;\n                  case \"symbol\":\n                    typeFlag = 3;\n                    break;\n                  case \"function\":\n                    typeFlag = 4;\n                    break;\n                }\n                this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                this.mem.setUint32(addr, id, true);\n              };\n              const loadSlice = addr => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n              };\n              const loadSliceOfValues = addr => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                const a = new Array(len);\n                for (let i = 0; i < len; i++) {\n                  a[i] = loadValue(array + i * 8);\n                }\n                return a;\n              };\n              const loadString = addr => {\n                const saddr = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n              };\n              const timeOrigin = Date.now() - performance.now();\n              this.importObject = {\n                go: {\n                  \"runtime.wasmExit\": sp => {\n                    sp >>>= 0;\n                    const code = this.mem.getInt32(sp + 8, true);\n                    this.exited = true;\n                    delete this._inst;\n                    delete this._values;\n                    delete this._goRefCounts;\n                    delete this._ids;\n                    delete this._idPool;\n                    this.exit(code);\n                  },\n                  \"runtime.wasmWrite\": sp => {\n                    sp >>>= 0;\n                    const fd = getInt64(sp + 8);\n                    const p = getInt64(sp + 16);\n                    const n = this.mem.getInt32(sp + 24, true);\n                    globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                  },\n                  \"runtime.resetMemoryDataView\": sp => {\n                    sp >>>= 0;\n                    this.mem = new DataView(this._inst.exports.mem.buffer);\n                  },\n                  \"runtime.nanotime1\": sp => {\n                    sp >>>= 0;\n                    setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                  },\n                  \"runtime.walltime\": sp => {\n                    sp >>>= 0;\n                    const msec = new Date().getTime();\n                    setInt64(sp + 8, msec / 1e3);\n                    this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                  },\n                  \"runtime.scheduleTimeoutEvent\": sp => {\n                    sp >>>= 0;\n                    const id = this._nextCallbackTimeoutID;\n                    this._nextCallbackTimeoutID++;\n                    this._scheduledTimeouts.set(id, setTimeout(() => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n                        this._resume();\n                      }\n                    }, getInt64(sp + 8) + 1));\n                    this.mem.setInt32(sp + 16, id, true);\n                  },\n                  \"runtime.clearTimeoutEvent\": sp => {\n                    sp >>>= 0;\n                    const id = this.mem.getInt32(sp + 8, true);\n                    clearTimeout(this._scheduledTimeouts.get(id));\n                    this._scheduledTimeouts.delete(id);\n                  },\n                  \"runtime.getRandomData\": sp => {\n                    sp >>>= 0;\n                    crypto.getRandomValues(loadSlice(sp + 8));\n                  },\n                  \"syscall/js.finalizeRef\": sp => {\n                    sp >>>= 0;\n                    const id = this.mem.getUint32(sp + 8, true);\n                    this._goRefCounts[id]--;\n                    if (this._goRefCounts[id] === 0) {\n                      const v = this._values[id];\n                      this._values[id] = null;\n                      this._ids.delete(v);\n                      this._idPool.push(id);\n                    }\n                  },\n                  \"syscall/js.stringVal\": sp => {\n                    sp >>>= 0;\n                    storeValue(sp + 24, loadString(sp + 8));\n                  },\n                  \"syscall/js.valueGet\": sp => {\n                    sp >>>= 0;\n                    const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 32, result);\n                  },\n                  \"syscall/js.valueSet\": sp => {\n                    sp >>>= 0;\n                    Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                  },\n                  \"syscall/js.valueDelete\": sp => {\n                    sp >>>= 0;\n                    Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                  },\n                  \"syscall/js.valueIndex\": sp => {\n                    sp >>>= 0;\n                    storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                  },\n                  \"syscall/js.valueSetIndex\": sp => {\n                    sp >>>= 0;\n                    Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                  },\n                  \"syscall/js.valueCall\": sp => {\n                    sp >>>= 0;\n                    try {\n                      const v = loadValue(sp + 8);\n                      const m = Reflect.get(v, loadString(sp + 16));\n                      const args = loadSliceOfValues(sp + 32);\n                      const result = Reflect.apply(m, v, args);\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 56, result);\n                      this.mem.setUint8(sp + 64, 1);\n                    } catch (err) {\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 56, err);\n                      this.mem.setUint8(sp + 64, 0);\n                    }\n                  },\n                  \"syscall/js.valueInvoke\": sp => {\n                    sp >>>= 0;\n                    try {\n                      const v = loadValue(sp + 8);\n                      const args = loadSliceOfValues(sp + 16);\n                      const result = Reflect.apply(v, void 0, args);\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, result);\n                      this.mem.setUint8(sp + 48, 1);\n                    } catch (err) {\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, err);\n                      this.mem.setUint8(sp + 48, 0);\n                    }\n                  },\n                  \"syscall/js.valueNew\": sp => {\n                    sp >>>= 0;\n                    try {\n                      const v = loadValue(sp + 8);\n                      const args = loadSliceOfValues(sp + 16);\n                      const result = Reflect.construct(v, args);\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, result);\n                      this.mem.setUint8(sp + 48, 1);\n                    } catch (err) {\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, err);\n                      this.mem.setUint8(sp + 48, 0);\n                    }\n                  },\n                  \"syscall/js.valueLength\": sp => {\n                    sp >>>= 0;\n                    setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                  },\n                  \"syscall/js.valuePrepareString\": sp => {\n                    sp >>>= 0;\n                    const str = encoder.encode(String(loadValue(sp + 8)));\n                    storeValue(sp + 16, str);\n                    setInt64(sp + 24, str.length);\n                  },\n                  \"syscall/js.valueLoadString\": sp => {\n                    sp >>>= 0;\n                    const str = loadValue(sp + 8);\n                    loadSlice(sp + 16).set(str);\n                  },\n                  \"syscall/js.valueInstanceOf\": sp => {\n                    sp >>>= 0;\n                    this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                  },\n                  \"syscall/js.copyBytesToGo\": sp => {\n                    sp >>>= 0;\n                    const dst = loadSlice(sp + 8);\n                    const src = loadValue(sp + 32);\n                    if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                      this.mem.setUint8(sp + 48, 0);\n                      return;\n                    }\n                    const toCopy = src.subarray(0, dst.length);\n                    dst.set(toCopy);\n                    setInt64(sp + 40, toCopy.length);\n                    this.mem.setUint8(sp + 48, 1);\n                  },\n                  \"syscall/js.copyBytesToJS\": sp => {\n                    sp >>>= 0;\n                    const dst = loadValue(sp + 8);\n                    const src = loadSlice(sp + 16);\n                    if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                      this.mem.setUint8(sp + 48, 0);\n                      return;\n                    }\n                    const toCopy = src.subarray(0, dst.length);\n                    dst.set(toCopy);\n                    setInt64(sp + 40, toCopy.length);\n                    this.mem.setUint8(sp + 48, 1);\n                  },\n                  \"debug\": value => {\n                    console.log(value);\n                  }\n                }\n              };\n            }\n            run(instance) {\n              return __async(this, null, function* () {\n                if (!(instance instanceof WebAssembly.Instance)) {\n                  throw new Error(\"Go.run: WebAssembly.Instance expected\");\n                }\n                this._inst = instance;\n                this.mem = new DataView(this._inst.exports.mem.buffer);\n                this._values = [NaN, 0, null, true, false, globalThis, this];\n                this._goRefCounts = new Array(this._values.length).fill(Infinity);\n                this._ids = /* @__PURE__ */new Map([[0, 1], [null, 2], [true, 3], [false, 4], [globalThis, 5], [this, 6]]);\n                this._idPool = [];\n                this.exited = false;\n                let offset = 4096;\n                const strPtr = str => {\n                  const ptr = offset;\n                  const bytes = encoder.encode(str + \"\\0\");\n                  new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                  offset += bytes.length;\n                  if (offset % 8 !== 0) {\n                    offset += 8 - offset % 8;\n                  }\n                  return ptr;\n                };\n                const argc = this.argv.length;\n                const argvPtrs = [];\n                this.argv.forEach(arg => {\n                  argvPtrs.push(strPtr(arg));\n                });\n                argvPtrs.push(0);\n                const keys = Object.keys(this.env).sort();\n                keys.forEach(key => {\n                  argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n                });\n                argvPtrs.push(0);\n                const argv = offset;\n                argvPtrs.forEach(ptr => {\n                  this.mem.setUint32(offset, ptr, true);\n                  this.mem.setUint32(offset + 4, 0, true);\n                  offset += 8;\n                });\n                const wasmMinDataAddr = 4096 + 8192;\n                if (offset >= wasmMinDataAddr) {\n                  throw new Error(\"total length of command line and environment variables exceeds limit\");\n                }\n                this._inst.exports.run(argc, argv);\n                if (this.exited) {\n                  this._resolveExitPromise();\n                }\n                yield this._exitPromise;\n              });\n            }\n            _resume() {\n              if (this.exited) {\n                throw new Error(\"Go program has already exited\");\n              }\n              this._inst.exports.resume();\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n            }\n            _makeFuncWrapper(id) {\n              const go = this;\n              return function () {\n                const event = {\n                  id,\n                  this: this,\n                  args: arguments\n                };\n                go._pendingEvent = event;\n                go._resume();\n                return event.result;\n              };\n            }\n          };\n        })();\n        onmessage = ({\n          data: wasm\n        }) => {\n          let decoder = new TextDecoder();\n          let fs = globalThis.fs;\n          let stderr = \"\";\n          fs.writeSync = (fd, buffer) => {\n            if (fd === 1) {\n              postMessage(buffer);\n            } else if (fd === 2) {\n              stderr += decoder.decode(buffer);\n              let parts = stderr.split(\"\\n\");\n              if (parts.length > 1) console.log(parts.slice(0, -1).join(\"\\n\"));\n              stderr = parts[parts.length - 1];\n            } else {\n              throw new Error(\"Bad write\");\n            }\n            return buffer.length;\n          };\n          let stdin = [];\n          let resumeStdin;\n          let stdinPos = 0;\n          onmessage = ({\n            data\n          }) => {\n            if (data.length > 0) {\n              stdin.push(data);\n              if (resumeStdin) resumeStdin();\n            }\n          };\n          fs.read = (fd, buffer, offset, length, position, callback) => {\n            if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n              throw new Error(\"Bad read\");\n            }\n            if (stdin.length === 0) {\n              resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n              return;\n            }\n            let first = stdin[0];\n            let count = Math.max(0, Math.min(length, first.length - stdinPos));\n            buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n            stdinPos += count;\n            if (stdinPos === first.length) {\n              stdin.shift();\n              stdinPos = 0;\n            }\n            callback(null, count);\n          };\n          let go = new globalThis.Go();\n          go.argv = [\"\", `--service=${\"0.15.13\"}`];\n          if (wasm instanceof WebAssembly.Module) {\n            WebAssembly.instantiate(wasm, go.importObject).then(instance => go.run(instance));\n          } else {\n            WebAssembly.instantiate(wasm, go.importObject).then(({\n              instance\n            }) => go.run(instance));\n          }\n        };\n        return m => onmessage(m);\n      })(data => worker.onmessage({\n        data\n      }));\n      worker = {\n        onmessage: null,\n        postMessage: data => setTimeout(() => onmessage({\n          data\n        })),\n        terminate() {}\n      };\n    }\n    worker.postMessage(wasm);\n    worker.onmessage = ({\n      data\n    }) => readFromStdout(data);\n    let {\n      readFromStdout,\n      service\n    } = createChannel({\n      writeToStdin(bytes) {\n        worker.postMessage(bytes);\n      },\n      isSync: false,\n      isWriteUnavailable: true,\n      esbuild: browser_exports\n    });\n    longLivedService = {\n      build: options => new Promise((resolve, reject) => service.buildOrServe({\n        callName: \"build\",\n        refs: null,\n        serveOptions: null,\n        options,\n        isTTY: false,\n        defaultWD: \"/\",\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      })),\n      transform: (input, options) => new Promise((resolve, reject) => service.transform({\n        callName: \"transform\",\n        refs: null,\n        input,\n        options: options || {},\n        isTTY: false,\n        fs: {\n          readFile(_, callback) {\n            callback(new Error(\"Internal error\"), null);\n          },\n          writeFile(_, callback) {\n            callback(null);\n          }\n        },\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      })),\n      formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n        callName: \"formatMessages\",\n        refs: null,\n        messages,\n        options,\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      })),\n      analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n        callName: \"analyzeMetafile\",\n        refs: null,\n        metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n        options,\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      }))\n    };\n  });\n  var browser_default = browser_exports;\n})(typeof module === \"object\" ? module : {\n  set exports(x) {\n    (typeof self !== \"undefined\" ? self : this).esbuild = x;\n  }\n});","map":{"version":3,"names":["module","__defProp","Object","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toCommonJS","mod","value","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","browser_exports","analyzeMetafile","analyzeMetafileSync","build","buildSync","default","browser_default","formatMessages","formatMessagesSync","initialize","serve","transform","transformSync","version","exports","encodePacket","packet","visit","bb","write8","write32","write","encodeUTF8","Uint8Array","Array","length","item","keys","ByteBuffer","id","isRequest","writeUInt32LE","buf","len","subarray","decodePacket","bytes","read8","read32","decodeUTF8","read","count","value2","i","push","Error","ptr","constructor","_write","delta","clone","set","offset","_read","readUInt32LE","TextEncoder","TextDecoder","encoder","decoder","text","encode","decode","Buffer","buffer","byteOffset","byteLength","toString","buildLogLevelDefault","transformLogLevelDefault","validateTarget","indexOf","canBeAnything","mustBeBoolean","mustBeBooleanOrObject","isArray","mustBeString","mustBeRegExp","RegExp","mustBeInteger","mustBeFunction","mustBeArray","mustBeObject","mustBeWebAssemblyModule","WebAssembly","Module","mustBeArrayOrRecord","mustBeObjectOrNull","mustBeStringOrBoolean","mustBeStringOrObject","mustBeStringOrArray","mustBeStringOrUint8Array","getFlag","object","mustBeFn","mustBe","checkForInvalidFlags","where","validateInitializeOptions","options","create","wasmURL","wasmModule","worker","validateMangleCache","mangleCache","validated","JSON","stringify","pushLogFlags","flags","isTTY","logLevelDefault","color","logLevel","logLimit","pushCommonFlags","legalComments","sourceRoot","sourcesContent","format","globalName","mangleProps","reserveProps","mangleQuoted","minify","minifySyntax","minifyWhitespace","minifyIdentifiers","drop","charset","treeShaking","ignoreAnnotations","jsx","jsxFactory","jsxFragment","jsxImportSource","jsxDev","jsxSideEffects","define","logOverride","supported","pure","keepNames","platform","map","join","what","source","fn","flagsForBuildOptions","callName","writeDefault","_a","entries","stdinContents","stdinResolveDir","watchMode","sourcemap","bundle","watch","splitting","preserveSymlinks","metafile","outfile","outdir","outbase","tsconfig","resolveExtensions","nodePathsInput","mainFields","conditions","external","loader","outExtension","publicPath","entryNames","chunkNames","assetNames","inject","banner","footer","entryPoints","absWorkingDir","stdin","allowOverwrite","incremental","plugins","watchKeys","onRebuild","values","type","path","ext","entryPoint","stdinKeys","contents","resolveDir","sourcefile","loader2","nodePaths","flagsForTransformOptions","tsconfigRaw","createChannel","streamIn","requestCallbacksByKey","closeData","didClose","reason","responseCallbacks","nextRequestID","nextBuildKey","stdout","stdoutUsed","readFromStdout","chunk","limit","swap","handleIncomingPacket","copyWithin","afterClose","error","message","sendRequest","refs","callback","response","unref","ref","writeToStdin","sendResponse","handleRequest","request","command","requestCallbacks","errors","extractErrorMessageV8","isFirstPacket","binaryVersion","String","fromCharCode","buildOrServe","serveOptions","defaultWD","refCount","buildKey","buildRefs","buildOrServeImpl","err","res","transform2","input","fs","details","createObjectStash","start","inputPath","inputFS","replaceDetailsInMessages","warnings","outstanding","result","code","failureErrorWithLog","codeFS","readFile","mapFS","e2","detail","load","writeFile","formatMessages2","messages","sanitizeMessages","kind","terminalWidth","isWarning","analyzeMetafile2","verbose","service","logPluginError","pluginName","note","handleError","isSync","handlePlugins","ok","buildOrServeContinue","requestPlugins","runOnEndCallbacks","logPluginError2","isWriteUnavailable","serve2","buildServeData","rebuild","stop","copyResponseToResult","outputFiles","convertOutputFiles","parse","writeToStdout","console","log","replace","buildResponseToResult","callback2","isDisposed","error2","response2","location","notes","error3","result3","dispose","isStopped","request2","watchResponse","args","result2","serveResponse","port","host","wait","servedir","onRequest","initialOptions","onStartCallbacks","onEndCallbacks","onResolveCallbacks","onLoadCallbacks","nextCallbackID","isSetupDone","setup","plugin","onResolve","onLoad","keys2","importer","namespace","pluginData","resolve2","store","sideEffects","suffix","promise","onStart","registeredText","registeredNote","extractCallerV8","onEnd","filter","esbuild","_0","id2","ids","watchFiles","watchDirs","sanitizeStringArray","Map","nextID","ident","tried","lines","stack","split","splice","parseStackLinesV8","stash","at","readFileSync","startsWith","line","slice","match","exec","lineText","column","file","suggestion","summary","pluginText","sanitizeLocation","property","fallbackPluginName","messagesClone","index","notesClone","noteKeys","noteText","noteLocation","binary","ensureServiceIsRunning","initializePromise","longLivedService","useWorker","startRunningService","catch","wasm","fetch","arrayBuffer","blob","Blob","Worker","URL","createObjectURL","onmessage","postMessage","globalThis","o","self","getPrototypeOf","k","enosys","outputBuf","constants","O_WRONLY","O_RDWR","O_CREAT","O_TRUNC","O_APPEND","O_EXCL","writeSync","fd","nl","lastIndexOf","substr","position","n","chmod","mode","chown","uid","gid","close","fchmod","fchown","fstat","fsync","ftruncate","lchown","link","lstat","mkdir","perm","open","readdir","readlink","rename","rmdir","stat","symlink","truncate","unlink","utimes","atime","mtime","process","getuid","getgid","geteuid","getegid","getgroups","pid","ppid","umask","cwd","chdir","crypto","performance","Go","argv","env","exit","warn","_exitPromise","_resolveExitPromise","_pendingEvent","_scheduledTimeouts","_nextCallbackTimeoutID","setInt64","addr","v","mem","setUint32","Math","floor","getInt64","low","getUint32","high","getInt32","loadValue","f","getFloat64","isNaN","_values","storeValue","nanHead","setFloat64","_ids","_idPool","pop","_goRefCounts","typeFlag","loadSlice","array","_inst","loadSliceOfValues","a","loadString","saddr","DataView","timeOrigin","Date","now","importObject","go","sp","exited","p","msec","getTime","setInt32","setTimeout","_resume","has","clearTimeout","delete","getRandomValues","Reflect","getsp","deleteProperty","m","setUint8","construct","parseInt","str","dst","src","Uint8ClampedArray","toCopy","run","instance","Instance","NaN","fill","Infinity","strPtr","argc","argvPtrs","forEach","arg","sort","wasmMinDataAddr","resume","_makeFuncWrapper","event","this","arguments","data","stderr","parts","resumeStdin","stdinPos","first","max","min","shift","instantiate","terminate","_"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/esbuild-wasm/lib/browser.js"],"sourcesContent":["(module=>{\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// lib/npm/browser.ts\nvar browser_exports = {};\n__export(browser_exports, {\n  analyzeMetafile: () => analyzeMetafile,\n  analyzeMetafileSync: () => analyzeMetafileSync,\n  build: () => build,\n  buildSync: () => buildSync,\n  default: () => browser_default,\n  formatMessages: () => formatMessages,\n  formatMessagesSync: () => formatMessagesSync,\n  initialize: () => initialize,\n  serve: () => serve,\n  transform: () => transform,\n  transformSync: () => transformSync,\n  version: () => version\n});\nmodule.exports = __toCommonJS(browser_exports);\n\n// lib/shared/stdio_protocol.ts\nfunction encodePacket(packet) {\n  let visit = (value) => {\n    if (value === null) {\n      bb.write8(0);\n    } else if (typeof value === \"boolean\") {\n      bb.write8(1);\n      bb.write8(+value);\n    } else if (typeof value === \"number\") {\n      bb.write8(2);\n      bb.write32(value | 0);\n    } else if (typeof value === \"string\") {\n      bb.write8(3);\n      bb.write(encodeUTF8(value));\n    } else if (value instanceof Uint8Array) {\n      bb.write8(4);\n      bb.write(value);\n    } else if (value instanceof Array) {\n      bb.write8(5);\n      bb.write32(value.length);\n      for (let item of value) {\n        visit(item);\n      }\n    } else {\n      let keys = Object.keys(value);\n      bb.write8(6);\n      bb.write32(keys.length);\n      for (let key of keys) {\n        bb.write(encodeUTF8(key));\n        visit(value[key]);\n      }\n    }\n  };\n  let bb = new ByteBuffer();\n  bb.write32(0);\n  bb.write32(packet.id << 1 | +!packet.isRequest);\n  visit(packet.value);\n  writeUInt32LE(bb.buf, bb.len - 4, 0);\n  return bb.buf.subarray(0, bb.len);\n}\nfunction decodePacket(bytes) {\n  let visit = () => {\n    switch (bb.read8()) {\n      case 0:\n        return null;\n      case 1:\n        return !!bb.read8();\n      case 2:\n        return bb.read32();\n      case 3:\n        return decodeUTF8(bb.read());\n      case 4:\n        return bb.read();\n      case 5: {\n        let count = bb.read32();\n        let value2 = [];\n        for (let i = 0; i < count; i++) {\n          value2.push(visit());\n        }\n        return value2;\n      }\n      case 6: {\n        let count = bb.read32();\n        let value2 = {};\n        for (let i = 0; i < count; i++) {\n          value2[decodeUTF8(bb.read())] = visit();\n        }\n        return value2;\n      }\n      default:\n        throw new Error(\"Invalid packet\");\n    }\n  };\n  let bb = new ByteBuffer(bytes);\n  let id = bb.read32();\n  let isRequest = (id & 1) === 0;\n  id >>>= 1;\n  let value = visit();\n  if (bb.ptr !== bytes.length) {\n    throw new Error(\"Invalid packet\");\n  }\n  return { id, isRequest, value };\n}\nvar ByteBuffer = class {\n  constructor(buf = new Uint8Array(1024)) {\n    this.buf = buf;\n    this.len = 0;\n    this.ptr = 0;\n  }\n  _write(delta) {\n    if (this.len + delta > this.buf.length) {\n      let clone = new Uint8Array((this.len + delta) * 2);\n      clone.set(this.buf);\n      this.buf = clone;\n    }\n    this.len += delta;\n    return this.len - delta;\n  }\n  write8(value) {\n    let offset = this._write(1);\n    this.buf[offset] = value;\n  }\n  write32(value) {\n    let offset = this._write(4);\n    writeUInt32LE(this.buf, value, offset);\n  }\n  write(bytes) {\n    let offset = this._write(4 + bytes.length);\n    writeUInt32LE(this.buf, bytes.length, offset);\n    this.buf.set(bytes, offset + 4);\n  }\n  _read(delta) {\n    if (this.ptr + delta > this.buf.length) {\n      throw new Error(\"Invalid packet\");\n    }\n    this.ptr += delta;\n    return this.ptr - delta;\n  }\n  read8() {\n    return this.buf[this._read(1)];\n  }\n  read32() {\n    return readUInt32LE(this.buf, this._read(4));\n  }\n  read() {\n    let length = this.read32();\n    let bytes = new Uint8Array(length);\n    let ptr = this._read(bytes.length);\n    bytes.set(this.buf.subarray(ptr, ptr + length));\n    return bytes;\n  }\n};\nvar encodeUTF8;\nvar decodeUTF8;\nif (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  encodeUTF8 = (text) => encoder.encode(text);\n  decodeUTF8 = (bytes) => decoder.decode(bytes);\n} else if (typeof Buffer !== \"undefined\") {\n  encodeUTF8 = (text) => {\n    let buffer = Buffer.from(text);\n    if (!(buffer instanceof Uint8Array)) {\n      buffer = new Uint8Array(buffer);\n    }\n    return buffer;\n  };\n  decodeUTF8 = (bytes) => {\n    let { buffer, byteOffset, byteLength } = bytes;\n    return Buffer.from(buffer, byteOffset, byteLength).toString();\n  };\n} else {\n  throw new Error(\"No UTF-8 codec found\");\n}\nfunction readUInt32LE(buffer, offset) {\n  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n}\nfunction writeUInt32LE(buffer, value, offset) {\n  buffer[offset++] = value;\n  buffer[offset++] = value >> 8;\n  buffer[offset++] = value >> 16;\n  buffer[offset++] = value >> 24;\n}\n\n// lib/shared/common.ts\nvar buildLogLevelDefault = \"warning\";\nvar transformLogLevelDefault = \"silent\";\nfunction validateTarget(target) {\n  target += \"\";\n  if (target.indexOf(\",\") >= 0)\n    throw new Error(`Invalid target: ${target}`);\n  return target;\n}\nvar canBeAnything = () => null;\nvar mustBeBoolean = (value) => typeof value === \"boolean\" ? null : \"a boolean\";\nvar mustBeBooleanOrObject = (value) => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\nvar mustBeString = (value) => typeof value === \"string\" ? null : \"a string\";\nvar mustBeRegExp = (value) => value instanceof RegExp ? null : \"a RegExp object\";\nvar mustBeInteger = (value) => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\nvar mustBeFunction = (value) => typeof value === \"function\" ? null : \"a function\";\nvar mustBeArray = (value) => Array.isArray(value) ? null : \"an array\";\nvar mustBeObject = (value) => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\nvar mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : \"a WebAssembly.Module\";\nvar mustBeArrayOrRecord = (value) => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\nvar mustBeObjectOrNull = (value) => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\nvar mustBeStringOrBoolean = (value) => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\nvar mustBeStringOrObject = (value) => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\nvar mustBeStringOrArray = (value) => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\nvar mustBeStringOrUint8Array = (value) => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\nfunction getFlag(object, keys, key, mustBeFn) {\n  let value = object[key];\n  keys[key + \"\"] = true;\n  if (value === void 0)\n    return void 0;\n  let mustBe = mustBeFn(value);\n  if (mustBe !== null)\n    throw new Error(`\"${key}\" must be ${mustBe}`);\n  return value;\n}\nfunction checkForInvalidFlags(object, keys, where) {\n  for (let key in object) {\n    if (!(key in keys)) {\n      throw new Error(`Invalid option ${where}: \"${key}\"`);\n    }\n  }\n}\nfunction validateInitializeOptions(options) {\n  let keys = /* @__PURE__ */ Object.create(null);\n  let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n  let wasmModule = getFlag(options, keys, \"wasmModule\", mustBeWebAssemblyModule);\n  let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n  checkForInvalidFlags(options, keys, \"in initialize() call\");\n  return {\n    wasmURL,\n    wasmModule,\n    worker\n  };\n}\nfunction validateMangleCache(mangleCache) {\n  let validated;\n  if (mangleCache !== void 0) {\n    validated = /* @__PURE__ */ Object.create(null);\n    for (let key of Object.keys(mangleCache)) {\n      let value = mangleCache[key];\n      if (typeof value === \"string\" || value === false) {\n        validated[key] = value;\n      } else {\n        throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);\n      }\n    }\n  }\n  return validated;\n}\nfunction pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n  let color = getFlag(options, keys, \"color\", mustBeBoolean);\n  let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n  let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n  if (color !== void 0)\n    flags.push(`--color=${color}`);\n  else if (isTTY)\n    flags.push(`--color=true`);\n  flags.push(`--log-level=${logLevel || logLevelDefault}`);\n  flags.push(`--log-limit=${logLimit || 0}`);\n}\nfunction pushCommonFlags(flags, options, keys) {\n  let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n  let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n  let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n  let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n  let format = getFlag(options, keys, \"format\", mustBeString);\n  let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n  let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n  let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n  let mangleQuoted = getFlag(options, keys, \"mangleQuoted\", mustBeBoolean);\n  let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n  let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n  let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n  let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n  let drop = getFlag(options, keys, \"drop\", mustBeArray);\n  let charset = getFlag(options, keys, \"charset\", mustBeString);\n  let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n  let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n  let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n  let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n  let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n  let jsxImportSource = getFlag(options, keys, \"jsxImportSource\", mustBeString);\n  let jsxDev = getFlag(options, keys, \"jsxDev\", mustBeBoolean);\n  let jsxSideEffects = getFlag(options, keys, \"jsxSideEffects\", mustBeBoolean);\n  let define = getFlag(options, keys, \"define\", mustBeObject);\n  let logOverride = getFlag(options, keys, \"logOverride\", mustBeObject);\n  let supported = getFlag(options, keys, \"supported\", mustBeObject);\n  let pure = getFlag(options, keys, \"pure\", mustBeArray);\n  let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n  let platform = getFlag(options, keys, \"platform\", mustBeString);\n  if (legalComments)\n    flags.push(`--legal-comments=${legalComments}`);\n  if (sourceRoot !== void 0)\n    flags.push(`--source-root=${sourceRoot}`);\n  if (sourcesContent !== void 0)\n    flags.push(`--sources-content=${sourcesContent}`);\n  if (target) {\n    if (Array.isArray(target))\n      flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);\n    else\n      flags.push(`--target=${validateTarget(target)}`);\n  }\n  if (format)\n    flags.push(`--format=${format}`);\n  if (globalName)\n    flags.push(`--global-name=${globalName}`);\n  if (platform)\n    flags.push(`--platform=${platform}`);\n  if (minify)\n    flags.push(\"--minify\");\n  if (minifySyntax)\n    flags.push(\"--minify-syntax\");\n  if (minifyWhitespace)\n    flags.push(\"--minify-whitespace\");\n  if (minifyIdentifiers)\n    flags.push(\"--minify-identifiers\");\n  if (charset)\n    flags.push(`--charset=${charset}`);\n  if (treeShaking !== void 0)\n    flags.push(`--tree-shaking=${treeShaking}`);\n  if (ignoreAnnotations)\n    flags.push(`--ignore-annotations`);\n  if (drop)\n    for (let what of drop)\n      flags.push(`--drop:${what}`);\n  if (mangleProps)\n    flags.push(`--mangle-props=${mangleProps.source}`);\n  if (reserveProps)\n    flags.push(`--reserve-props=${reserveProps.source}`);\n  if (mangleQuoted !== void 0)\n    flags.push(`--mangle-quoted=${mangleQuoted}`);\n  if (jsx)\n    flags.push(`--jsx=${jsx}`);\n  if (jsxFactory)\n    flags.push(`--jsx-factory=${jsxFactory}`);\n  if (jsxFragment)\n    flags.push(`--jsx-fragment=${jsxFragment}`);\n  if (jsxImportSource)\n    flags.push(`--jsx-import-source=${jsxImportSource}`);\n  if (jsxDev)\n    flags.push(`--jsx-dev`);\n  if (jsxSideEffects)\n    flags.push(`--jsx-side-effects`);\n  if (define) {\n    for (let key in define) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid define: ${key}`);\n      flags.push(`--define:${key}=${define[key]}`);\n    }\n  }\n  if (logOverride) {\n    for (let key in logOverride) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid log override: ${key}`);\n      flags.push(`--log-override:${key}=${logOverride[key]}`);\n    }\n  }\n  if (supported) {\n    for (let key in supported) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid supported: ${key}`);\n      flags.push(`--supported:${key}=${supported[key]}`);\n    }\n  }\n  if (pure)\n    for (let fn of pure)\n      flags.push(`--pure:${fn}`);\n  if (keepNames)\n    flags.push(`--keep-names`);\n}\nfunction flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n  var _a;\n  let flags = [];\n  let entries = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  let stdinContents = null;\n  let stdinResolveDir = null;\n  let watchMode = null;\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n  let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n  let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n  let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n  let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n  let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n  let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n  let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n  let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n  let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n  let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n  let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n  let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n  let external = getFlag(options, keys, \"external\", mustBeArray);\n  let loader = getFlag(options, keys, \"loader\", mustBeObject);\n  let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n  let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n  let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n  let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n  let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n  let inject = getFlag(options, keys, \"inject\", mustBeArray);\n  let banner = getFlag(options, keys, \"banner\", mustBeObject);\n  let footer = getFlag(options, keys, \"footer\", mustBeObject);\n  let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n  let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n  let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n  let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n  let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n  let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n  let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n  keys.plugins = true;\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n  if (bundle)\n    flags.push(\"--bundle\");\n  if (allowOverwrite)\n    flags.push(\"--allow-overwrite\");\n  if (watch) {\n    flags.push(\"--watch\");\n    if (typeof watch === \"boolean\") {\n      watchMode = {};\n    } else {\n      let watchKeys = /* @__PURE__ */ Object.create(null);\n      let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n      checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n      watchMode = { onRebuild };\n    }\n  }\n  if (splitting)\n    flags.push(\"--splitting\");\n  if (preserveSymlinks)\n    flags.push(\"--preserve-symlinks\");\n  if (metafile)\n    flags.push(`--metafile`);\n  if (outfile)\n    flags.push(`--outfile=${outfile}`);\n  if (outdir)\n    flags.push(`--outdir=${outdir}`);\n  if (outbase)\n    flags.push(`--outbase=${outbase}`);\n  if (tsconfig)\n    flags.push(`--tsconfig=${tsconfig}`);\n  if (resolveExtensions) {\n    let values = [];\n    for (let value of resolveExtensions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid resolve extension: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--resolve-extensions=${values.join(\",\")}`);\n  }\n  if (publicPath)\n    flags.push(`--public-path=${publicPath}`);\n  if (entryNames)\n    flags.push(`--entry-names=${entryNames}`);\n  if (chunkNames)\n    flags.push(`--chunk-names=${chunkNames}`);\n  if (assetNames)\n    flags.push(`--asset-names=${assetNames}`);\n  if (mainFields) {\n    let values = [];\n    for (let value of mainFields) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid main field: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--main-fields=${values.join(\",\")}`);\n  }\n  if (conditions) {\n    let values = [];\n    for (let value of conditions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid condition: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--conditions=${values.join(\",\")}`);\n  }\n  if (external)\n    for (let name of external)\n      flags.push(`--external:${name}`);\n  if (banner) {\n    for (let type in banner) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid banner file type: ${type}`);\n      flags.push(`--banner:${type}=${banner[type]}`);\n    }\n  }\n  if (footer) {\n    for (let type in footer) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid footer file type: ${type}`);\n      flags.push(`--footer:${type}=${footer[type]}`);\n    }\n  }\n  if (inject)\n    for (let path of inject)\n      flags.push(`--inject:${path}`);\n  if (loader) {\n    for (let ext in loader) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid loader extension: ${ext}`);\n      flags.push(`--loader:${ext}=${loader[ext]}`);\n    }\n  }\n  if (outExtension) {\n    for (let ext in outExtension) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid out extension: ${ext}`);\n      flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n    }\n  }\n  if (entryPoints) {\n    if (Array.isArray(entryPoints)) {\n      for (let entryPoint of entryPoints) {\n        entries.push([\"\", entryPoint + \"\"]);\n      }\n    } else {\n      for (let [key, value] of Object.entries(entryPoints)) {\n        entries.push([key + \"\", value + \"\"]);\n      }\n    }\n  }\n  if (stdin) {\n    let stdinKeys = /* @__PURE__ */ Object.create(null);\n    let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeStringOrUint8Array);\n    let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n    let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n    let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n    checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n    if (sourcefile)\n      flags.push(`--sourcefile=${sourcefile}`);\n    if (loader2)\n      flags.push(`--loader=${loader2}`);\n    if (resolveDir)\n      stdinResolveDir = resolveDir + \"\";\n    if (typeof contents === \"string\")\n      stdinContents = encodeUTF8(contents);\n    else if (contents instanceof Uint8Array)\n      stdinContents = contents;\n  }\n  let nodePaths = [];\n  if (nodePathsInput) {\n    for (let value of nodePathsInput) {\n      value += \"\";\n      nodePaths.push(value);\n    }\n  }\n  return {\n    entries,\n    flags,\n    write,\n    stdinContents,\n    stdinResolveDir,\n    absWorkingDir,\n    incremental,\n    nodePaths,\n    watch: watchMode,\n    mangleCache: validateMangleCache(mangleCache)\n  };\n}\nfunction flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n  let flags = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n  let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n  let loader = getFlag(options, keys, \"loader\", mustBeString);\n  let banner = getFlag(options, keys, \"banner\", mustBeString);\n  let footer = getFlag(options, keys, \"footer\", mustBeString);\n  let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n  if (tsconfigRaw)\n    flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n  if (sourcefile)\n    flags.push(`--sourcefile=${sourcefile}`);\n  if (loader)\n    flags.push(`--loader=${loader}`);\n  if (banner)\n    flags.push(`--banner=${banner}`);\n  if (footer)\n    flags.push(`--footer=${footer}`);\n  return {\n    flags,\n    mangleCache: validateMangleCache(mangleCache)\n  };\n}\nfunction createChannel(streamIn) {\n  const requestCallbacksByKey = {};\n  const closeData = { didClose: false, reason: \"\" };\n  let responseCallbacks = {};\n  let nextRequestID = 0;\n  let nextBuildKey = 0;\n  let stdout = new Uint8Array(16 * 1024);\n  let stdoutUsed = 0;\n  let readFromStdout = (chunk) => {\n    let limit = stdoutUsed + chunk.length;\n    if (limit > stdout.length) {\n      let swap = new Uint8Array(limit * 2);\n      swap.set(stdout);\n      stdout = swap;\n    }\n    stdout.set(chunk, stdoutUsed);\n    stdoutUsed += chunk.length;\n    let offset = 0;\n    while (offset + 4 <= stdoutUsed) {\n      let length = readUInt32LE(stdout, offset);\n      if (offset + 4 + length > stdoutUsed) {\n        break;\n      }\n      offset += 4;\n      handleIncomingPacket(stdout.subarray(offset, offset + length));\n      offset += length;\n    }\n    if (offset > 0) {\n      stdout.copyWithin(0, offset, stdoutUsed);\n      stdoutUsed -= offset;\n    }\n  };\n  let afterClose = (error) => {\n    closeData.didClose = true;\n    if (error)\n      closeData.reason = \": \" + (error.message || error);\n    const text = \"The service was stopped\" + closeData.reason;\n    for (let id in responseCallbacks) {\n      responseCallbacks[id](text, null);\n    }\n    responseCallbacks = {};\n  };\n  let sendRequest = (refs, value, callback) => {\n    if (closeData.didClose)\n      return callback(\"The service is no longer running\" + closeData.reason, null);\n    let id = nextRequestID++;\n    responseCallbacks[id] = (error, response) => {\n      try {\n        callback(error, response);\n      } finally {\n        if (refs)\n          refs.unref();\n      }\n    };\n    if (refs)\n      refs.ref();\n    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));\n  };\n  let sendResponse = (id, value) => {\n    if (closeData.didClose)\n      throw new Error(\"The service is no longer running\" + closeData.reason);\n    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));\n  };\n  let handleRequest = (id, request) => __async(this, null, function* () {\n    try {\n      if (request.command === \"ping\") {\n        sendResponse(id, {});\n        return;\n      }\n      if (typeof request.key === \"number\") {\n        const requestCallbacks = requestCallbacksByKey[request.key];\n        if (requestCallbacks) {\n          const callback = requestCallbacks[request.command];\n          if (callback) {\n            yield callback(id, request);\n            return;\n          }\n        }\n      }\n      throw new Error(`Invalid command: ` + request.command);\n    } catch (e) {\n      sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")] });\n    }\n  });\n  let isFirstPacket = true;\n  let handleIncomingPacket = (bytes) => {\n    if (isFirstPacket) {\n      isFirstPacket = false;\n      let binaryVersion = String.fromCharCode(...bytes);\n      if (binaryVersion !== \"0.15.13\") {\n        throw new Error(`Cannot start service: Host version \"${\"0.15.13\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n      }\n      return;\n    }\n    let packet = decodePacket(bytes);\n    if (packet.isRequest) {\n      handleRequest(packet.id, packet.value);\n    } else {\n      let callback = responseCallbacks[packet.id];\n      delete responseCallbacks[packet.id];\n      if (packet.value.error)\n        callback(packet.value.error, {});\n      else\n        callback(null, packet.value);\n    }\n  };\n  let buildOrServe = ({ callName, refs, serveOptions, options, isTTY, defaultWD, callback }) => {\n    let refCount = 0;\n    const buildKey = nextBuildKey++;\n    const requestCallbacks = {};\n    const buildRefs = {\n      ref() {\n        if (++refCount === 1) {\n          if (refs)\n            refs.ref();\n        }\n      },\n      unref() {\n        if (--refCount === 0) {\n          delete requestCallbacksByKey[buildKey];\n          if (refs)\n            refs.unref();\n        }\n      }\n    };\n    requestCallbacksByKey[buildKey] = requestCallbacks;\n    buildRefs.ref();\n    buildOrServeImpl(\n      callName,\n      buildKey,\n      sendRequest,\n      sendResponse,\n      buildRefs,\n      streamIn,\n      requestCallbacks,\n      options,\n      serveOptions,\n      isTTY,\n      defaultWD,\n      closeData,\n      (err, res) => {\n        try {\n          callback(err, res);\n        } finally {\n          buildRefs.unref();\n        }\n      }\n    );\n  };\n  let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {\n    const details = createObjectStash();\n    let start = (inputPath) => {\n      try {\n        if (typeof input !== \"string\" && !(input instanceof Uint8Array))\n          throw new Error('The input to \"transform\" must be a string or a Uint8Array');\n        let {\n          flags,\n          mangleCache\n        } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n        let request = {\n          command: \"transform\",\n          flags,\n          inputFS: inputPath !== null,\n          input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === \"string\" ? encodeUTF8(input) : input\n        };\n        if (mangleCache)\n          request.mangleCache = mangleCache;\n        sendRequest(refs, request, (error, response) => {\n          if (error)\n            return callback(new Error(error), null);\n          let errors = replaceDetailsInMessages(response.errors, details);\n          let warnings = replaceDetailsInMessages(response.warnings, details);\n          let outstanding = 1;\n          let next = () => {\n            if (--outstanding === 0) {\n              let result = { warnings, code: response.code, map: response.map };\n              if (response.mangleCache)\n                result.mangleCache = response == null ? void 0 : response.mangleCache;\n              callback(null, result);\n            }\n          };\n          if (errors.length > 0)\n            return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n          if (response.codeFS) {\n            outstanding++;\n            fs.readFile(response.code, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.code = contents;\n                next();\n              }\n            });\n          }\n          if (response.mapFS) {\n            outstanding++;\n            fs.readFile(response.map, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.map = contents;\n                next();\n              }\n            });\n          }\n          next();\n        });\n      } catch (e) {\n        let flags = [];\n        try {\n          pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n        } catch (e2) {\n        }\n        const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n        sendRequest(refs, { command: \"error\", flags, error }, () => {\n          error.detail = details.load(error.detail);\n          callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n        });\n      }\n    };\n    if ((typeof input === \"string\" || input instanceof Uint8Array) && input.length > 1024 * 1024) {\n      let next = start;\n      start = () => fs.writeFile(input, next);\n    }\n    start(null);\n  };\n  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {\n    let result = sanitizeMessages(messages, \"messages\", null, \"\");\n    if (!options)\n      throw new Error(`Missing second argument in ${callName}() call`);\n    let keys = {};\n    let kind = getFlag(options, keys, \"kind\", mustBeString);\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (kind === void 0)\n      throw new Error(`Missing \"kind\" in ${callName}() call`);\n    if (kind !== \"error\" && kind !== \"warning\")\n      throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n    let request = {\n      command: \"format-msgs\",\n      messages: result,\n      isWarning: kind === \"warning\"\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (terminalWidth !== void 0)\n      request.terminalWidth = terminalWidth;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.messages);\n    });\n  };\n  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {\n    if (options === void 0)\n      options = {};\n    let keys = {};\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    let request = {\n      command: \"analyze-metafile\",\n      metafile\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (verbose !== void 0)\n      request.verbose = verbose;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.result);\n    });\n  };\n  return {\n    readFromStdout,\n    afterClose,\n    service: {\n      buildOrServe,\n      transform: transform2,\n      formatMessages: formatMessages2,\n      analyzeMetafile: analyzeMetafile2\n    }\n  };\n}\nfunction buildOrServeImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, serveOptions, isTTY, defaultWD, closeData, callback) {\n  const details = createObjectStash();\n  const logPluginError = (e, pluginName, note, done) => {\n    const flags = [];\n    try {\n      pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n    } catch (e2) {\n    }\n    const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n    sendRequest(refs, { command: \"error\", flags, error: message }, () => {\n      message.detail = details.load(message.detail);\n      done(message);\n    });\n  };\n  const handleError = (e, pluginName) => {\n    logPluginError(e, pluginName, void 0, (error) => {\n      callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n    });\n  };\n  let plugins;\n  if (typeof options === \"object\") {\n    const value = options.plugins;\n    if (value !== void 0) {\n      if (!Array.isArray(value))\n        throw new Error(`\"plugins\" must be an array`);\n      plugins = value;\n    }\n  }\n  if (plugins && plugins.length > 0) {\n    if (streamIn.isSync) {\n      handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n      return;\n    }\n    handlePlugins(\n      buildKey,\n      sendRequest,\n      sendResponse,\n      refs,\n      streamIn,\n      requestCallbacks,\n      options,\n      plugins,\n      details\n    ).then(\n      (result) => {\n        if (!result.ok) {\n          handleError(result.error, result.pluginName);\n          return;\n        }\n        try {\n          buildOrServeContinue(result.requestPlugins, result.runOnEndCallbacks);\n        } catch (e) {\n          handleError(e, \"\");\n        }\n      },\n      (e) => handleError(e, \"\")\n    );\n    return;\n  }\n  try {\n    buildOrServeContinue(null, (result, logPluginError2, done) => done());\n  } catch (e) {\n    handleError(e, \"\");\n  }\n  function buildOrServeContinue(requestPlugins, runOnEndCallbacks) {\n    let writeDefault = !streamIn.isWriteUnavailable;\n    let {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch,\n      mangleCache\n    } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n    let request = {\n      command: \"build\",\n      key: buildKey,\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir: absWorkingDir || defaultWD,\n      incremental,\n      nodePaths\n    };\n    if (requestPlugins)\n      request.plugins = requestPlugins;\n    if (mangleCache)\n      request.mangleCache = mangleCache;\n    let serve2 = serveOptions && buildServeData(buildKey, sendRequest, sendResponse, refs, requestCallbacks, serveOptions, request);\n    let rebuild;\n    let stop;\n    let copyResponseToResult = (response, result) => {\n      if (response.outputFiles)\n        result.outputFiles = response.outputFiles.map(convertOutputFiles);\n      if (response.metafile)\n        result.metafile = JSON.parse(response.metafile);\n      if (response.mangleCache)\n        result.mangleCache = response.mangleCache;\n      if (response.writeToStdout !== void 0)\n        console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n    };\n    let buildResponseToResult = (response, callback2) => {\n      let result = {\n        errors: replaceDetailsInMessages(response.errors, details),\n        warnings: replaceDetailsInMessages(response.warnings, details)\n      };\n      copyResponseToResult(response, result);\n      runOnEndCallbacks(result, logPluginError, () => {\n        if (result.errors.length > 0) {\n          return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n        }\n        if (response.rebuild) {\n          if (!rebuild) {\n            let isDisposed = false;\n            rebuild = () => new Promise((resolve, reject) => {\n              if (isDisposed || closeData.didClose)\n                throw new Error(\"Cannot rebuild\");\n              sendRequest(\n                refs,\n                { command: \"rebuild\", key: buildKey },\n                (error2, response2) => {\n                  if (error2) {\n                    const message = { id: \"\", pluginName: \"\", text: error2, location: null, notes: [], detail: void 0 };\n                    return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                  }\n                  buildResponseToResult(response2, (error3, result3) => {\n                    if (error3)\n                      reject(error3);\n                    else\n                      resolve(result3);\n                  });\n                }\n              );\n            });\n            refs.ref();\n            rebuild.dispose = () => {\n              if (isDisposed)\n                return;\n              isDisposed = true;\n              sendRequest(refs, { command: \"rebuild-dispose\", key: buildKey }, () => {\n              });\n              refs.unref();\n            };\n          }\n          result.rebuild = rebuild;\n        }\n        if (response.watch) {\n          if (!stop) {\n            let isStopped = false;\n            refs.ref();\n            stop = () => {\n              if (isStopped)\n                return;\n              isStopped = true;\n              delete requestCallbacks[\"watch-rebuild\"];\n              sendRequest(refs, { command: \"watch-stop\", key: buildKey }, () => {\n              });\n              refs.unref();\n            };\n            if (watch) {\n              requestCallbacks[\"watch-rebuild\"] = (id, request2) => {\n                try {\n                  let watchResponse = request2.args;\n                  let result2 = {\n                    errors: replaceDetailsInMessages(watchResponse.errors, details),\n                    warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                  };\n                  copyResponseToResult(watchResponse, result2);\n                  runOnEndCallbacks(result2, logPluginError, () => {\n                    if (result2.errors.length > 0) {\n                      if (watch.onRebuild)\n                        watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                      return;\n                    }\n                    result2.stop = stop;\n                    if (watch.onRebuild)\n                      watch.onRebuild(null, result2);\n                  });\n                } catch (err) {\n                  console.error(err);\n                }\n                sendResponse(id, {});\n              };\n            }\n          }\n          result.stop = stop;\n        }\n        callback2(null, result);\n      });\n    };\n    if (write && streamIn.isWriteUnavailable)\n      throw new Error(`The \"write\" option is unavailable in this environment`);\n    if (incremental && streamIn.isSync)\n      throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n    if (watch && streamIn.isSync)\n      throw new Error(`Cannot use \"watch\" with a synchronous build`);\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      if (serve2) {\n        let serveResponse = response;\n        let isStopped = false;\n        refs.ref();\n        let result = {\n          port: serveResponse.port,\n          host: serveResponse.host,\n          wait: serve2.wait,\n          stop() {\n            if (isStopped)\n              return;\n            isStopped = true;\n            serve2.stop();\n            refs.unref();\n          }\n        };\n        refs.ref();\n        serve2.wait.then(refs.unref, refs.unref);\n        return callback(null, result);\n      }\n      return buildResponseToResult(response, callback);\n    });\n  }\n}\nvar buildServeData = (buildKey, sendRequest, sendResponse, refs, requestCallbacks, options, request) => {\n  let keys = {};\n  let port = getFlag(options, keys, \"port\", mustBeInteger);\n  let host = getFlag(options, keys, \"host\", mustBeString);\n  let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n  let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n  let wait = new Promise((resolve, reject) => {\n    requestCallbacks[\"serve-wait\"] = (id, request2) => {\n      if (request2.error !== null)\n        reject(new Error(request2.error));\n      else\n        resolve();\n      sendResponse(id, {});\n    };\n  });\n  request.serve = {};\n  checkForInvalidFlags(options, keys, `in serve() call`);\n  if (port !== void 0)\n    request.serve.port = port;\n  if (host !== void 0)\n    request.serve.host = host;\n  if (servedir !== void 0)\n    request.serve.servedir = servedir;\n  requestCallbacks[\"serve-request\"] = (id, request2) => {\n    if (onRequest)\n      onRequest(request2.args);\n    sendResponse(id, {});\n  };\n  return {\n    wait,\n    stop() {\n      sendRequest(refs, { command: \"serve-stop\", key: buildKey }, () => {\n      });\n    }\n  };\n};\nvar handlePlugins = (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => __async(void 0, null, function* () {\n  let onStartCallbacks = [];\n  let onEndCallbacks = [];\n  let onResolveCallbacks = {};\n  let onLoadCallbacks = {};\n  let nextCallbackID = 0;\n  let i = 0;\n  let requestPlugins = [];\n  let isSetupDone = false;\n  plugins = [...plugins];\n  for (let item of plugins) {\n    let keys = {};\n    if (typeof item !== \"object\")\n      throw new Error(`Plugin at index ${i} must be an object`);\n    const name = getFlag(item, keys, \"name\", mustBeString);\n    if (typeof name !== \"string\" || name === \"\")\n      throw new Error(`Plugin at index ${i} is missing a name`);\n    try {\n      let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n      if (typeof setup !== \"function\")\n        throw new Error(`Plugin is missing a setup function`);\n      checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n      let plugin = {\n        name,\n        onResolve: [],\n        onLoad: []\n      };\n      i++;\n      let resolve = (path, options = {}) => {\n        if (!isSetupDone)\n          throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n        if (typeof path !== \"string\")\n          throw new Error(`The path to resolve must be a string`);\n        let keys2 = /* @__PURE__ */ Object.create(null);\n        let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n        let importer = getFlag(options, keys2, \"importer\", mustBeString);\n        let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n        let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n        let kind = getFlag(options, keys2, \"kind\", mustBeString);\n        let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n        checkForInvalidFlags(options, keys2, \"in resolve() call\");\n        return new Promise((resolve2, reject) => {\n          const request = {\n            command: \"resolve\",\n            path,\n            key: buildKey,\n            pluginName: name\n          };\n          if (pluginName != null)\n            request.pluginName = pluginName;\n          if (importer != null)\n            request.importer = importer;\n          if (namespace != null)\n            request.namespace = namespace;\n          if (resolveDir != null)\n            request.resolveDir = resolveDir;\n          if (kind != null)\n            request.kind = kind;\n          if (pluginData != null)\n            request.pluginData = details.store(pluginData);\n          sendRequest(refs, request, (error, response) => {\n            if (error !== null)\n              reject(new Error(error));\n            else\n              resolve2({\n                errors: replaceDetailsInMessages(response.errors, details),\n                warnings: replaceDetailsInMessages(response.warnings, details),\n                path: response.path,\n                external: response.external,\n                sideEffects: response.sideEffects,\n                namespace: response.namespace,\n                suffix: response.suffix,\n                pluginData: details.load(response.pluginData)\n              });\n          });\n        });\n      };\n      let promise = setup({\n        initialOptions,\n        resolve,\n        onStart(callback) {\n          let registeredText = `This error came from the \"onStart\" callback registered here:`;\n          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n          onStartCallbacks.push({ name, callback, note: registeredNote });\n        },\n        onEnd(callback) {\n          let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n          onEndCallbacks.push({ name, callback, note: registeredNote });\n        },\n        onResolve(options, callback) {\n          let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n          let keys2 = {};\n          let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n          let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n          checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n          if (filter == null)\n            throw new Error(`onResolve() call is missing a filter`);\n          let id = nextCallbackID++;\n          onResolveCallbacks[id] = { name, callback, note: registeredNote };\n          plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || \"\" });\n        },\n        onLoad(options, callback) {\n          let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n          let keys2 = {};\n          let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n          let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n          checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n          if (filter == null)\n            throw new Error(`onLoad() call is missing a filter`);\n          let id = nextCallbackID++;\n          onLoadCallbacks[id] = { name, callback, note: registeredNote };\n          plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || \"\" });\n        },\n        esbuild: streamIn.esbuild\n      });\n      if (promise)\n        yield promise;\n      requestPlugins.push(plugin);\n    } catch (e) {\n      return { ok: false, error: e, pluginName: name };\n    }\n  }\n  requestCallbacks[\"on-start\"] = (id, request) => __async(void 0, null, function* () {\n    let response = { errors: [], warnings: [] };\n    yield Promise.all(onStartCallbacks.map((_0) => __async(void 0, [_0], function* ({ name, callback, note }) {\n      try {\n        let result = yield callback();\n        if (result != null) {\n          if (typeof result !== \"object\")\n            throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n          let keys = {};\n          let errors = getFlag(result, keys, \"errors\", mustBeArray);\n          let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n          checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n          if (errors != null)\n            response.errors.push(...sanitizeMessages(errors, \"errors\", details, name));\n          if (warnings != null)\n            response.warnings.push(...sanitizeMessages(warnings, \"warnings\", details, name));\n        }\n      } catch (e) {\n        response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));\n      }\n    })));\n    sendResponse(id, response);\n  });\n  requestCallbacks[\"on-resolve\"] = (id, request) => __async(void 0, null, function* () {\n    let response = {}, name = \"\", callback, note;\n    for (let id2 of request.ids) {\n      try {\n        ({ name, callback, note } = onResolveCallbacks[id2]);\n        let result = yield callback({\n          path: request.path,\n          importer: request.importer,\n          namespace: request.namespace,\n          resolveDir: request.resolveDir,\n          kind: request.kind,\n          pluginData: details.load(request.pluginData)\n        });\n        if (result != null) {\n          if (typeof result !== \"object\")\n            throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n          let keys = {};\n          let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n          let path = getFlag(result, keys, \"path\", mustBeString);\n          let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n          let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n          let external = getFlag(result, keys, \"external\", mustBeBoolean);\n          let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n          let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n          let errors = getFlag(result, keys, \"errors\", mustBeArray);\n          let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n          let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n          let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n          checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n          response.id = id2;\n          if (pluginName != null)\n            response.pluginName = pluginName;\n          if (path != null)\n            response.path = path;\n          if (namespace != null)\n            response.namespace = namespace;\n          if (suffix != null)\n            response.suffix = suffix;\n          if (external != null)\n            response.external = external;\n          if (sideEffects != null)\n            response.sideEffects = sideEffects;\n          if (pluginData != null)\n            response.pluginData = details.store(pluginData);\n          if (errors != null)\n            response.errors = sanitizeMessages(errors, \"errors\", details, name);\n          if (warnings != null)\n            response.warnings = sanitizeMessages(warnings, \"warnings\", details, name);\n          if (watchFiles != null)\n            response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n          if (watchDirs != null)\n            response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n          break;\n        }\n      } catch (e) {\n        response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };\n        break;\n      }\n    }\n    sendResponse(id, response);\n  });\n  requestCallbacks[\"on-load\"] = (id, request) => __async(void 0, null, function* () {\n    let response = {}, name = \"\", callback, note;\n    for (let id2 of request.ids) {\n      try {\n        ({ name, callback, note } = onLoadCallbacks[id2]);\n        let result = yield callback({\n          path: request.path,\n          namespace: request.namespace,\n          suffix: request.suffix,\n          pluginData: details.load(request.pluginData)\n        });\n        if (result != null) {\n          if (typeof result !== \"object\")\n            throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n          let keys = {};\n          let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n          let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n          let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n          let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n          let loader = getFlag(result, keys, \"loader\", mustBeString);\n          let errors = getFlag(result, keys, \"errors\", mustBeArray);\n          let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n          let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n          let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n          checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n          response.id = id2;\n          if (pluginName != null)\n            response.pluginName = pluginName;\n          if (contents instanceof Uint8Array)\n            response.contents = contents;\n          else if (contents != null)\n            response.contents = encodeUTF8(contents);\n          if (resolveDir != null)\n            response.resolveDir = resolveDir;\n          if (pluginData != null)\n            response.pluginData = details.store(pluginData);\n          if (loader != null)\n            response.loader = loader;\n          if (errors != null)\n            response.errors = sanitizeMessages(errors, \"errors\", details, name);\n          if (warnings != null)\n            response.warnings = sanitizeMessages(warnings, \"warnings\", details, name);\n          if (watchFiles != null)\n            response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n          if (watchDirs != null)\n            response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n          break;\n        }\n      } catch (e) {\n        response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };\n        break;\n      }\n    }\n    sendResponse(id, response);\n  });\n  let runOnEndCallbacks = (result, logPluginError, done) => done();\n  if (onEndCallbacks.length > 0) {\n    runOnEndCallbacks = (result, logPluginError, done) => {\n      (() => __async(void 0, null, function* () {\n        for (const { name, callback, note } of onEndCallbacks) {\n          try {\n            yield callback(result);\n          } catch (e) {\n            result.errors.push(yield new Promise((resolve) => logPluginError(e, name, note && note(), resolve)));\n          }\n        }\n      }))().then(done);\n    };\n  }\n  isSetupDone = true;\n  return {\n    ok: true,\n    requestPlugins,\n    runOnEndCallbacks\n  };\n});\nfunction createObjectStash() {\n  const map = /* @__PURE__ */ new Map();\n  let nextID = 0;\n  return {\n    load(id) {\n      return map.get(id);\n    },\n    store(value) {\n      if (value === void 0)\n        return -1;\n      const id = nextID++;\n      map.set(id, value);\n      return id;\n    }\n  };\n}\nfunction extractCallerV8(e, streamIn, ident) {\n  let note;\n  let tried = false;\n  return () => {\n    if (tried)\n      return note;\n    tried = true;\n    try {\n      let lines = (e.stack + \"\").split(\"\\n\");\n      lines.splice(1, 1);\n      let location = parseStackLinesV8(streamIn, lines, ident);\n      if (location) {\n        note = { text: e.message, location };\n        return note;\n      }\n    } catch (e2) {\n    }\n  };\n}\nfunction extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n  let text = \"Internal error\";\n  let location = null;\n  try {\n    text = (e && e.message || e) + \"\";\n  } catch (e2) {\n  }\n  try {\n    location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n  } catch (e2) {\n  }\n  return { id: \"\", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };\n}\nfunction parseStackLinesV8(streamIn, lines, ident) {\n  let at = \"    at \";\n  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i];\n      if (!line.startsWith(at))\n        continue;\n      line = line.slice(at.length);\n      while (true) {\n        let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n        if (match) {\n          let contents;\n          try {\n            contents = streamIn.readFileSync(match[1], \"utf8\");\n          } catch (e) {\n            break;\n          }\n          let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n          let column = +match[3] - 1;\n          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n          return {\n            file: match[1],\n            namespace: \"file\",\n            line: +match[2],\n            column: encodeUTF8(lineText.slice(0, column)).length,\n            length: encodeUTF8(lineText.slice(column, column + length)).length,\n            lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n            suggestion: \"\"\n          };\n        }\n        break;\n      }\n    }\n  }\n  return null;\n}\nfunction failureErrorWithLog(text, errors, warnings) {\n  let limit = 5;\n  let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n    if (i === limit)\n      return \"\\n...\";\n    if (!e.location)\n      return `\nerror: ${e.text}`;\n    let { file, line, column } = e.location;\n    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n    return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n  }).join(\"\");\n  let error = new Error(`${text}${summary}`);\n  error.errors = errors;\n  error.warnings = warnings;\n  return error;\n}\nfunction replaceDetailsInMessages(messages, stash) {\n  for (const message of messages) {\n    message.detail = stash.load(message.detail);\n  }\n  return messages;\n}\nfunction sanitizeLocation(location, where) {\n  if (location == null)\n    return null;\n  let keys = {};\n  let file = getFlag(location, keys, \"file\", mustBeString);\n  let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n  let line = getFlag(location, keys, \"line\", mustBeInteger);\n  let column = getFlag(location, keys, \"column\", mustBeInteger);\n  let length = getFlag(location, keys, \"length\", mustBeInteger);\n  let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n  let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n  checkForInvalidFlags(location, keys, where);\n  return {\n    file: file || \"\",\n    namespace: namespace || \"\",\n    line: line || 0,\n    column: column || 0,\n    length: length || 0,\n    lineText: lineText || \"\",\n    suggestion: suggestion || \"\"\n  };\n}\nfunction sanitizeMessages(messages, property, stash, fallbackPluginName) {\n  let messagesClone = [];\n  let index = 0;\n  for (const message of messages) {\n    let keys = {};\n    let id = getFlag(message, keys, \"id\", mustBeString);\n    let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n    let text = getFlag(message, keys, \"text\", mustBeString);\n    let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n    let notes = getFlag(message, keys, \"notes\", mustBeArray);\n    let detail = getFlag(message, keys, \"detail\", canBeAnything);\n    let where = `in element ${index} of \"${property}\"`;\n    checkForInvalidFlags(message, keys, where);\n    let notesClone = [];\n    if (notes) {\n      for (const note of notes) {\n        let noteKeys = {};\n        let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n        let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n        checkForInvalidFlags(note, noteKeys, where);\n        notesClone.push({\n          text: noteText || \"\",\n          location: sanitizeLocation(noteLocation, where)\n        });\n      }\n    }\n    messagesClone.push({\n      id: id || \"\",\n      pluginName: pluginName || fallbackPluginName,\n      text: text || \"\",\n      location: sanitizeLocation(location, where),\n      notes: notesClone,\n      detail: stash ? stash.store(detail) : -1\n    });\n    index++;\n  }\n  return messagesClone;\n}\nfunction sanitizeStringArray(values, property) {\n  const result = [];\n  for (const value of values) {\n    if (typeof value !== \"string\")\n      throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n    result.push(value);\n  }\n  return result;\n}\nfunction convertOutputFiles({ path, contents }) {\n  let text = null;\n  return {\n    path,\n    contents,\n    get text() {\n      const binary = this.contents;\n      if (text === null || binary !== contents) {\n        contents = binary;\n        text = decodeUTF8(binary);\n      }\n      return text;\n    }\n  };\n}\n\n// lib/npm/browser.ts\nvar version = \"0.15.13\";\nvar build = (options) => ensureServiceIsRunning().build(options);\nvar serve = () => {\n  throw new Error(`The \"serve\" API only works in node`);\n};\nvar transform = (input, options) => ensureServiceIsRunning().transform(input, options);\nvar formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\nvar analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\nvar buildSync = () => {\n  throw new Error(`The \"buildSync\" API only works in node`);\n};\nvar transformSync = () => {\n  throw new Error(`The \"transformSync\" API only works in node`);\n};\nvar formatMessagesSync = () => {\n  throw new Error(`The \"formatMessagesSync\" API only works in node`);\n};\nvar analyzeMetafileSync = () => {\n  throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n};\nvar initializePromise;\nvar longLivedService;\nvar ensureServiceIsRunning = () => {\n  if (longLivedService)\n    return longLivedService;\n  if (initializePromise)\n    throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n  throw new Error('You need to call \"initialize\" before calling this');\n};\nvar initialize = (options) => {\n  options = validateInitializeOptions(options || {});\n  let wasmURL = options.wasmURL;\n  let wasmModule = options.wasmModule;\n  let useWorker = options.worker !== false;\n  if (!wasmURL && !wasmModule)\n    throw new Error('Must provide either the \"wasmURL\" option or the \"wasmModule\" option');\n  if (initializePromise)\n    throw new Error('Cannot call \"initialize\" more than once');\n  initializePromise = startRunningService(wasmURL || \"\", wasmModule, useWorker);\n  initializePromise.catch(() => {\n    initializePromise = void 0;\n  });\n  return initializePromise;\n};\nvar startRunningService = (wasmURL, wasmModule, useWorker) => __async(void 0, null, function* () {\n  let wasm;\n  if (wasmModule) {\n    wasm = wasmModule;\n  } else {\n    let res = yield fetch(wasmURL);\n    if (!res.ok)\n      throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n    wasm = yield res.arrayBuffer();\n  }\n  let worker;\n  if (useWorker) {\n    let blob = new Blob([`onmessage=${'((postMessage) => {\\n      // Copyright 2018 The Go Authors. All rights reserved.\\n      // Use of this source code is governed by a BSD-style\\n      // license that can be found in the LICENSE file.\\n      var __async = (__this, __arguments, generator) => {\\n        return new Promise((resolve, reject) => {\\n          var fulfilled = (value) => {\\n            try {\\n              step(generator.next(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var rejected = (value) => {\\n            try {\\n              step(generator.throw(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\\n          step((generator = generator.apply(__this, __arguments)).next());\\n        });\\n      };\\n      let onmessage;\\n      let globalThis = {};\\n      for (let o = self; o; o = Object.getPrototypeOf(o))\\n        for (let k of Object.getOwnPropertyNames(o))\\n          if (!(k in globalThis))\\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\\n      \"use strict\";\\n      (() => {\\n        const enosys = () => {\\n          const err = new Error(\"not implemented\");\\n          err.code = \"ENOSYS\";\\n          return err;\\n        };\\n        if (!globalThis.fs) {\\n          let outputBuf = \"\";\\n          globalThis.fs = {\\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\\n            writeSync(fd, buf) {\\n              outputBuf += decoder.decode(buf);\\n              const nl = outputBuf.lastIndexOf(\"\\\\n\");\\n              if (nl != -1) {\\n                console.log(outputBuf.substr(0, nl));\\n                outputBuf = outputBuf.substr(nl + 1);\\n              }\\n              return buf.length;\\n            },\\n            write(fd, buf, offset, length, position, callback) {\\n              if (offset !== 0 || length !== buf.length || position !== null) {\\n                callback(enosys());\\n                return;\\n              }\\n              const n = this.writeSync(fd, buf);\\n              callback(null, n);\\n            },\\n            chmod(path, mode, callback) {\\n              callback(enosys());\\n            },\\n            chown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            close(fd, callback) {\\n              callback(enosys());\\n            },\\n            fchmod(fd, mode, callback) {\\n              callback(enosys());\\n            },\\n            fchown(fd, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            fstat(fd, callback) {\\n              callback(enosys());\\n            },\\n            fsync(fd, callback) {\\n              callback(null);\\n            },\\n            ftruncate(fd, length, callback) {\\n              callback(enosys());\\n            },\\n            lchown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            link(path, link, callback) {\\n              callback(enosys());\\n            },\\n            lstat(path, callback) {\\n              callback(enosys());\\n            },\\n            mkdir(path, perm, callback) {\\n              callback(enosys());\\n            },\\n            open(path, flags, mode, callback) {\\n              callback(enosys());\\n            },\\n            read(fd, buffer, offset, length, position, callback) {\\n              callback(enosys());\\n            },\\n            readdir(path, callback) {\\n              callback(enosys());\\n            },\\n            readlink(path, callback) {\\n              callback(enosys());\\n            },\\n            rename(from, to, callback) {\\n              callback(enosys());\\n            },\\n            rmdir(path, callback) {\\n              callback(enosys());\\n            },\\n            stat(path, callback) {\\n              callback(enosys());\\n            },\\n            symlink(path, link, callback) {\\n              callback(enosys());\\n            },\\n            truncate(path, length, callback) {\\n              callback(enosys());\\n            },\\n            unlink(path, callback) {\\n              callback(enosys());\\n            },\\n            utimes(path, atime, mtime, callback) {\\n              callback(enosys());\\n            }\\n          };\\n        }\\n        if (!globalThis.process) {\\n          globalThis.process = {\\n            getuid() {\\n              return -1;\\n            },\\n            getgid() {\\n              return -1;\\n            },\\n            geteuid() {\\n              return -1;\\n            },\\n            getegid() {\\n              return -1;\\n            },\\n            getgroups() {\\n              throw enosys();\\n            },\\n            pid: -1,\\n            ppid: -1,\\n            umask() {\\n              throw enosys();\\n            },\\n            cwd() {\\n              throw enosys();\\n            },\\n            chdir() {\\n              throw enosys();\\n            }\\n          };\\n        }\\n        if (!globalThis.crypto) {\\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\\n        }\\n        if (!globalThis.performance) {\\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\\n        }\\n        if (!globalThis.TextEncoder) {\\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\\n        }\\n        if (!globalThis.TextDecoder) {\\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\\n        }\\n        const encoder = new TextEncoder(\"utf-8\");\\n        const decoder = new TextDecoder(\"utf-8\");\\n        globalThis.Go = class {\\n          constructor() {\\n            this.argv = [\"js\"];\\n            this.env = {};\\n            this.exit = (code) => {\\n              if (code !== 0) {\\n                console.warn(\"exit code:\", code);\\n              }\\n            };\\n            this._exitPromise = new Promise((resolve) => {\\n              this._resolveExitPromise = resolve;\\n            });\\n            this._pendingEvent = null;\\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\\n            this._nextCallbackTimeoutID = 1;\\n            const setInt64 = (addr, v) => {\\n              this.mem.setUint32(addr + 0, v, true);\\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\\n            };\\n            const getInt64 = (addr) => {\\n              const low = this.mem.getUint32(addr + 0, true);\\n              const high = this.mem.getInt32(addr + 4, true);\\n              return low + high * 4294967296;\\n            };\\n            const loadValue = (addr) => {\\n              const f = this.mem.getFloat64(addr, true);\\n              if (f === 0) {\\n                return void 0;\\n              }\\n              if (!isNaN(f)) {\\n                return f;\\n              }\\n              const id = this.mem.getUint32(addr, true);\\n              return this._values[id];\\n            };\\n            const storeValue = (addr, v) => {\\n              const nanHead = 2146959360;\\n              if (typeof v === \"number\" && v !== 0) {\\n                if (isNaN(v)) {\\n                  this.mem.setUint32(addr + 4, nanHead, true);\\n                  this.mem.setUint32(addr, 0, true);\\n                  return;\\n                }\\n                this.mem.setFloat64(addr, v, true);\\n                return;\\n              }\\n              if (v === void 0) {\\n                this.mem.setFloat64(addr, 0, true);\\n                return;\\n              }\\n              let id = this._ids.get(v);\\n              if (id === void 0) {\\n                id = this._idPool.pop();\\n                if (id === void 0) {\\n                  id = this._values.length;\\n                }\\n                this._values[id] = v;\\n                this._goRefCounts[id] = 0;\\n                this._ids.set(v, id);\\n              }\\n              this._goRefCounts[id]++;\\n              let typeFlag = 0;\\n              switch (typeof v) {\\n                case \"object\":\\n                  if (v !== null) {\\n                    typeFlag = 1;\\n                  }\\n                  break;\\n                case \"string\":\\n                  typeFlag = 2;\\n                  break;\\n                case \"symbol\":\\n                  typeFlag = 3;\\n                  break;\\n                case \"function\":\\n                  typeFlag = 4;\\n                  break;\\n              }\\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\\n              this.mem.setUint32(addr, id, true);\\n            };\\n            const loadSlice = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\\n            };\\n            const loadSliceOfValues = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              const a = new Array(len);\\n              for (let i = 0; i < len; i++) {\\n                a[i] = loadValue(array + i * 8);\\n              }\\n              return a;\\n            };\\n            const loadString = (addr) => {\\n              const saddr = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\\n            };\\n            const timeOrigin = Date.now() - performance.now();\\n            this.importObject = {\\n              go: {\\n                \"runtime.wasmExit\": (sp) => {\\n                  sp >>>= 0;\\n                  const code = this.mem.getInt32(sp + 8, true);\\n                  this.exited = true;\\n                  delete this._inst;\\n                  delete this._values;\\n                  delete this._goRefCounts;\\n                  delete this._ids;\\n                  delete this._idPool;\\n                  this.exit(code);\\n                },\\n                \"runtime.wasmWrite\": (sp) => {\\n                  sp >>>= 0;\\n                  const fd = getInt64(sp + 8);\\n                  const p = getInt64(sp + 16);\\n                  const n = this.mem.getInt32(sp + 24, true);\\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\\n                },\\n                \"runtime.resetMemoryDataView\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\\n                },\\n                \"runtime.nanotime1\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\\n                },\\n                \"runtime.walltime\": (sp) => {\\n                  sp >>>= 0;\\n                  const msec = new Date().getTime();\\n                  setInt64(sp + 8, msec / 1e3);\\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\\n                },\\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this._nextCallbackTimeoutID;\\n                  this._nextCallbackTimeoutID++;\\n                  this._scheduledTimeouts.set(id, setTimeout(\\n                    () => {\\n                      this._resume();\\n                      while (this._scheduledTimeouts.has(id)) {\\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\\n                        this._resume();\\n                      }\\n                    },\\n                    getInt64(sp + 8) + 1\\n                  ));\\n                  this.mem.setInt32(sp + 16, id, true);\\n                },\\n                \"runtime.clearTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getInt32(sp + 8, true);\\n                  clearTimeout(this._scheduledTimeouts.get(id));\\n                  this._scheduledTimeouts.delete(id);\\n                },\\n                \"runtime.getRandomData\": (sp) => {\\n                  sp >>>= 0;\\n                  crypto.getRandomValues(loadSlice(sp + 8));\\n                },\\n                \"syscall/js.finalizeRef\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getUint32(sp + 8, true);\\n                  this._goRefCounts[id]--;\\n                  if (this._goRefCounts[id] === 0) {\\n                    const v = this._values[id];\\n                    this._values[id] = null;\\n                    this._ids.delete(v);\\n                    this._idPool.push(id);\\n                  }\\n                },\\n                \"syscall/js.stringVal\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, loadString(sp + 8));\\n                },\\n                \"syscall/js.valueGet\": (sp) => {\\n                  sp >>>= 0;\\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\\n                  sp = this._inst.exports.getsp() >>> 0;\\n                  storeValue(sp + 32, result);\\n                },\\n                \"syscall/js.valueSet\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\\n                },\\n                \"syscall/js.valueDelete\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\\n                },\\n                \"syscall/js.valueIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\\n                },\\n                \"syscall/js.valueSetIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\\n                },\\n                \"syscall/js.valueCall\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const m = Reflect.get(v, loadString(sp + 16));\\n                    const args = loadSliceOfValues(sp + 32);\\n                    const result = Reflect.apply(m, v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, result);\\n                    this.mem.setUint8(sp + 64, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, err);\\n                    this.mem.setUint8(sp + 64, 0);\\n                  }\\n                },\\n                \"syscall/js.valueInvoke\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.apply(v, void 0, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueNew\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.construct(v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueLength\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\\n                },\\n                \"syscall/js.valuePrepareString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = encoder.encode(String(loadValue(sp + 8)));\\n                  storeValue(sp + 16, str);\\n                  setInt64(sp + 24, str.length);\\n                },\\n                \"syscall/js.valueLoadString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = loadValue(sp + 8);\\n                  loadSlice(sp + 16).set(str);\\n                },\\n                \"syscall/js.valueInstanceOf\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\\n                },\\n                \"syscall/js.copyBytesToGo\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadSlice(sp + 8);\\n                  const src = loadValue(sp + 32);\\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"syscall/js.copyBytesToJS\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadValue(sp + 8);\\n                  const src = loadSlice(sp + 16);\\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"debug\": (value) => {\\n                  console.log(value);\\n                }\\n              }\\n            };\\n          }\\n          run(instance) {\\n            return __async(this, null, function* () {\\n              if (!(instance instanceof WebAssembly.Instance)) {\\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\\n              }\\n              this._inst = instance;\\n              this.mem = new DataView(this._inst.exports.mem.buffer);\\n              this._values = [\\n                NaN,\\n                0,\\n                null,\\n                true,\\n                false,\\n                globalThis,\\n                this\\n              ];\\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\\n              this._ids = /* @__PURE__ */ new Map([\\n                [0, 1],\\n                [null, 2],\\n                [true, 3],\\n                [false, 4],\\n                [globalThis, 5],\\n                [this, 6]\\n              ]);\\n              this._idPool = [];\\n              this.exited = false;\\n              let offset = 4096;\\n              const strPtr = (str) => {\\n                const ptr = offset;\\n                const bytes = encoder.encode(str + \"\\\\0\");\\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\\n                offset += bytes.length;\\n                if (offset % 8 !== 0) {\\n                  offset += 8 - offset % 8;\\n                }\\n                return ptr;\\n              };\\n              const argc = this.argv.length;\\n              const argvPtrs = [];\\n              this.argv.forEach((arg) => {\\n                argvPtrs.push(strPtr(arg));\\n              });\\n              argvPtrs.push(0);\\n              const keys = Object.keys(this.env).sort();\\n              keys.forEach((key) => {\\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\\n              });\\n              argvPtrs.push(0);\\n              const argv = offset;\\n              argvPtrs.forEach((ptr) => {\\n                this.mem.setUint32(offset, ptr, true);\\n                this.mem.setUint32(offset + 4, 0, true);\\n                offset += 8;\\n              });\\n              const wasmMinDataAddr = 4096 + 8192;\\n              if (offset >= wasmMinDataAddr) {\\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\\n              }\\n              this._inst.exports.run(argc, argv);\\n              if (this.exited) {\\n                this._resolveExitPromise();\\n              }\\n              yield this._exitPromise;\\n            });\\n          }\\n          _resume() {\\n            if (this.exited) {\\n              throw new Error(\"Go program has already exited\");\\n            }\\n            this._inst.exports.resume();\\n            if (this.exited) {\\n              this._resolveExitPromise();\\n            }\\n          }\\n          _makeFuncWrapper(id) {\\n            const go = this;\\n            return function() {\\n              const event = { id, this: this, args: arguments };\\n              go._pendingEvent = event;\\n              go._resume();\\n              return event.result;\\n            };\\n          }\\n        };\\n      })();\\n      onmessage = ({ data: wasm }) => {\\n        let decoder = new TextDecoder();\\n        let fs = globalThis.fs;\\n        let stderr = \"\";\\n        fs.writeSync = (fd, buffer) => {\\n          if (fd === 1) {\\n            postMessage(buffer);\\n          } else if (fd === 2) {\\n            stderr += decoder.decode(buffer);\\n            let parts = stderr.split(\"\\\\n\");\\n            if (parts.length > 1)\\n              console.log(parts.slice(0, -1).join(\"\\\\n\"));\\n            stderr = parts[parts.length - 1];\\n          } else {\\n            throw new Error(\"Bad write\");\\n          }\\n          return buffer.length;\\n        };\\n        let stdin = [];\\n        let resumeStdin;\\n        let stdinPos = 0;\\n        onmessage = ({ data }) => {\\n          if (data.length > 0) {\\n            stdin.push(data);\\n            if (resumeStdin)\\n              resumeStdin();\\n          }\\n        };\\n        fs.read = (fd, buffer, offset, length, position, callback) => {\\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\\n            throw new Error(\"Bad read\");\\n          }\\n          if (stdin.length === 0) {\\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\\n            return;\\n          }\\n          let first = stdin[0];\\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\\n          stdinPos += count;\\n          if (stdinPos === first.length) {\\n            stdin.shift();\\n            stdinPos = 0;\\n          }\\n          callback(null, count);\\n        };\\n        let go = new globalThis.Go();\\n        go.argv = [\"\", `--service=${\"0.15.13\"}`];\\n        if (wasm instanceof WebAssembly.Module) {\\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\\n        } else {\\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\\n        }\\n      };\\n      return (m) => onmessage(m);\\n    })'}(postMessage)`], { type: \"text/javascript\" });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    let onmessage = ((postMessage) => {\n      // Copyright 2018 The Go Authors. All rights reserved.\n      // Use of this source code is governed by a BSD-style\n      // license that can be found in the LICENSE file.\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve, reject) => {\n          var fulfilled = (value) => {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value) => {\n            try {\n              step(generator.throw(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      let onmessage;\n      let globalThis = {};\n      for (let o = self; o; o = Object.getPrototypeOf(o))\n        for (let k of Object.getOwnPropertyNames(o))\n          if (!(k in globalThis))\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\n      \"use strict\";\n      (() => {\n        const enosys = () => {\n          const err = new Error(\"not implemented\");\n          err.code = \"ENOSYS\";\n          return err;\n        };\n        if (!globalThis.fs) {\n          let outputBuf = \"\";\n          globalThis.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\n            writeSync(fd, buf) {\n              outputBuf += decoder.decode(buf);\n              const nl = outputBuf.lastIndexOf(\"\\n\");\n              if (nl != -1) {\n                console.log(outputBuf.substr(0, nl));\n                outputBuf = outputBuf.substr(nl + 1);\n              }\n              return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n              if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n              }\n              const n = this.writeSync(fd, buf);\n              callback(null, n);\n            },\n            chmod(path, mode, callback) {\n              callback(enosys());\n            },\n            chown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            close(fd, callback) {\n              callback(enosys());\n            },\n            fchmod(fd, mode, callback) {\n              callback(enosys());\n            },\n            fchown(fd, uid, gid, callback) {\n              callback(enosys());\n            },\n            fstat(fd, callback) {\n              callback(enosys());\n            },\n            fsync(fd, callback) {\n              callback(null);\n            },\n            ftruncate(fd, length, callback) {\n              callback(enosys());\n            },\n            lchown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            link(path, link, callback) {\n              callback(enosys());\n            },\n            lstat(path, callback) {\n              callback(enosys());\n            },\n            mkdir(path, perm, callback) {\n              callback(enosys());\n            },\n            open(path, flags, mode, callback) {\n              callback(enosys());\n            },\n            read(fd, buffer, offset, length, position, callback) {\n              callback(enosys());\n            },\n            readdir(path, callback) {\n              callback(enosys());\n            },\n            readlink(path, callback) {\n              callback(enosys());\n            },\n            rename(from, to, callback) {\n              callback(enosys());\n            },\n            rmdir(path, callback) {\n              callback(enosys());\n            },\n            stat(path, callback) {\n              callback(enosys());\n            },\n            symlink(path, link, callback) {\n              callback(enosys());\n            },\n            truncate(path, length, callback) {\n              callback(enosys());\n            },\n            unlink(path, callback) {\n              callback(enosys());\n            },\n            utimes(path, atime, mtime, callback) {\n              callback(enosys());\n            }\n          };\n        }\n        if (!globalThis.process) {\n          globalThis.process = {\n            getuid() {\n              return -1;\n            },\n            getgid() {\n              return -1;\n            },\n            geteuid() {\n              return -1;\n            },\n            getegid() {\n              return -1;\n            },\n            getgroups() {\n              throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            umask() {\n              throw enosys();\n            },\n            cwd() {\n              throw enosys();\n            },\n            chdir() {\n              throw enosys();\n            }\n          };\n        }\n        if (!globalThis.crypto) {\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n        }\n        if (!globalThis.performance) {\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n        }\n        if (!globalThis.TextEncoder) {\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n        }\n        if (!globalThis.TextDecoder) {\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n        }\n        const encoder = new TextEncoder(\"utf-8\");\n        const decoder = new TextDecoder(\"utf-8\");\n        globalThis.Go = class {\n          constructor() {\n            this.argv = [\"js\"];\n            this.env = {};\n            this.exit = (code) => {\n              if (code !== 0) {\n                console.warn(\"exit code:\", code);\n              }\n            };\n            this._exitPromise = new Promise((resolve) => {\n              this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\n            this._nextCallbackTimeoutID = 1;\n            const setInt64 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            const getInt64 = (addr) => {\n              const low = this.mem.getUint32(addr + 0, true);\n              const high = this.mem.getInt32(addr + 4, true);\n              return low + high * 4294967296;\n            };\n            const loadValue = (addr) => {\n              const f = this.mem.getFloat64(addr, true);\n              if (f === 0) {\n                return void 0;\n              }\n              if (!isNaN(f)) {\n                return f;\n              }\n              const id = this.mem.getUint32(addr, true);\n              return this._values[id];\n            };\n            const storeValue = (addr, v) => {\n              const nanHead = 2146959360;\n              if (typeof v === \"number\" && v !== 0) {\n                if (isNaN(v)) {\n                  this.mem.setUint32(addr + 4, nanHead, true);\n                  this.mem.setUint32(addr, 0, true);\n                  return;\n                }\n                this.mem.setFloat64(addr, v, true);\n                return;\n              }\n              if (v === void 0) {\n                this.mem.setFloat64(addr, 0, true);\n                return;\n              }\n              let id = this._ids.get(v);\n              if (id === void 0) {\n                id = this._idPool.pop();\n                if (id === void 0) {\n                  id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n              }\n              this._goRefCounts[id]++;\n              let typeFlag = 0;\n              switch (typeof v) {\n                case \"object\":\n                  if (v !== null) {\n                    typeFlag = 1;\n                  }\n                  break;\n                case \"string\":\n                  typeFlag = 2;\n                  break;\n                case \"symbol\":\n                  typeFlag = 3;\n                  break;\n                case \"function\":\n                  typeFlag = 4;\n                  break;\n              }\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n              this.mem.setUint32(addr, id, true);\n            };\n            const loadSlice = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            const loadSliceOfValues = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              const a = new Array(len);\n              for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n              }\n              return a;\n            };\n            const loadString = (addr) => {\n              const saddr = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n              go: {\n                \"runtime.wasmExit\": (sp) => {\n                  sp >>>= 0;\n                  const code = this.mem.getInt32(sp + 8, true);\n                  this.exited = true;\n                  delete this._inst;\n                  delete this._values;\n                  delete this._goRefCounts;\n                  delete this._ids;\n                  delete this._idPool;\n                  this.exit(code);\n                },\n                \"runtime.wasmWrite\": (sp) => {\n                  sp >>>= 0;\n                  const fd = getInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                \"runtime.resetMemoryDataView\": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                \"runtime.nanotime1\": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                \"runtime.walltime\": (sp) => {\n                  sp >>>= 0;\n                  const msec = new Date().getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(\n                    () => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n                        this._resume();\n                      }\n                    },\n                    getInt64(sp + 8) + 1\n                  ));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                \"runtime.clearTimeoutEvent\": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                \"runtime.getRandomData\": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                \"syscall/js.finalizeRef\": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                \"syscall/js.stringVal\": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                \"syscall/js.valueGet\": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                \"syscall/js.valueSet\": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                \"syscall/js.valueDelete\": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                \"syscall/js.valueIndex\": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                \"syscall/js.valueSetIndex\": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                \"syscall/js.valueCall\": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                \"syscall/js.valueInvoke\": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                \"syscall/js.valueNew\": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                \"syscall/js.valueLength\": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                \"syscall/js.valuePrepareString\": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                \"syscall/js.valueLoadString\": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                \"syscall/js.valueInstanceOf\": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                \"syscall/js.copyBytesToGo\": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                \"syscall/js.copyBytesToJS\": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                \"debug\": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          run(instance) {\n            return __async(this, null, function* () {\n              if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\n              }\n              this._inst = instance;\n              this.mem = new DataView(this._inst.exports.mem.buffer);\n              this._values = [\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n              ];\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\n              this._ids = /* @__PURE__ */ new Map([\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6]\n              ]);\n              this._idPool = [];\n              this.exited = false;\n              let offset = 4096;\n              const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + \"\\0\");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                  offset += 8 - offset % 8;\n                }\n                return ptr;\n              };\n              const argc = this.argv.length;\n              const argvPtrs = [];\n              this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n              });\n              argvPtrs.push(0);\n              const keys = Object.keys(this.env).sort();\n              keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n              });\n              argvPtrs.push(0);\n              const argv = offset;\n              argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n              });\n              const wasmMinDataAddr = 4096 + 8192;\n              if (offset >= wasmMinDataAddr) {\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\n              }\n              this._inst.exports.run(argc, argv);\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n              yield this._exitPromise;\n            });\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error(\"Go program has already exited\");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = \"\";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split(\"\\n\");\n            if (parts.length > 1)\n              console.log(parts.slice(0, -1).join(\"\\n\"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error(\"Bad write\");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin)\n              resumeStdin();\n          }\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error(\"Bad read\");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = [\"\", `--service=${\"0.15.13\"}`];\n        if (wasm instanceof WebAssembly.Module) {\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\n        } else {\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n        }\n      };\n      return (m) => onmessage(m);\n    })((data) => worker.onmessage({ data }));\n    worker = {\n      onmessage: null,\n      postMessage: (data) => setTimeout(() => onmessage({ data })),\n      terminate() {\n      }\n    };\n  }\n  worker.postMessage(wasm);\n  worker.onmessage = ({ data }) => readFromStdout(data);\n  let { readFromStdout, service } = createChannel({\n    writeToStdin(bytes) {\n      worker.postMessage(bytes);\n    },\n    isSync: false,\n    isWriteUnavailable: true,\n    esbuild: browser_exports\n  });\n  longLivedService = {\n    build: (options) => new Promise((resolve, reject) => service.buildOrServe({\n      callName: \"build\",\n      refs: null,\n      serveOptions: null,\n      options,\n      isTTY: false,\n      defaultWD: \"/\",\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    })),\n    transform: (input, options) => new Promise((resolve, reject) => service.transform({\n      callName: \"transform\",\n      refs: null,\n      input,\n      options: options || {},\n      isTTY: false,\n      fs: {\n        readFile(_, callback) {\n          callback(new Error(\"Internal error\"), null);\n        },\n        writeFile(_, callback) {\n          callback(null);\n        }\n      },\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    })),\n    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n      callName: \"formatMessages\",\n      refs: null,\n      messages,\n      options,\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    })),\n    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n      callName: \"analyzeMetafile\",\n      refs: null,\n      metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n      options,\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    }))\n  };\n});\nvar browser_default = browser_exports;\n})(typeof module===\"object\"?module:{set exports(x){(typeof self!==\"undefined\"?self:this).esbuild=x}});\n"],"mappings":"AAAA,CAACA,MAAM,IAAE;EACT,YAAY;;EACZ,IAAIC,SAAS,GAAGC,MAAM,CAACC,cAAc;EACrC,IAAIC,gBAAgB,GAAGF,MAAM,CAACG,wBAAwB;EACtD,IAAIC,iBAAiB,GAAGJ,MAAM,CAACK,mBAAmB;EAClD,IAAIC,YAAY,GAAGN,MAAM,CAACO,SAAS,CAACC,cAAc;EAClD,IAAIC,QAAQ,GAAG,CAACC,MAAM,EAAEC,GAAG,KAAK;IAC9B,KAAK,IAAIC,IAAI,IAAID,GAAG,EAClBZ,SAAS,CAACW,MAAM,EAAEE,IAAI,EAAE;MAAEC,GAAG,EAAEF,GAAG,CAACC,IAAI,CAAC;MAAEE,UAAU,EAAE;IAAK,CAAC,CAAC;EACjE,CAAC;EACD,IAAIC,WAAW,GAAG,CAACC,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAEC,IAAI,KAAK;IAC5C,IAAIF,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;MAClE,KAAK,IAAIG,GAAG,IAAIhB,iBAAiB,CAACa,IAAI,CAAC,EACrC,IAAI,CAACX,YAAY,CAACe,IAAI,CAACL,EAAE,EAAEI,GAAG,CAAC,IAAIA,GAAG,KAAKF,MAAM,EAC/CnB,SAAS,CAACiB,EAAE,EAAEI,GAAG,EAAE;QAAEP,GAAG,EAAE,MAAMI,IAAI,CAACG,GAAG,CAAC;QAAEN,UAAU,EAAE,EAAEK,IAAI,GAAGjB,gBAAgB,CAACe,IAAI,EAAEG,GAAG,CAAC,CAAC,IAAID,IAAI,CAACL;MAAW,CAAC,CAAC;IACxH;IACA,OAAOE,EAAE;EACX,CAAC;EACD,IAAIM,YAAY,GAAIC,GAAG,IAAKR,WAAW,CAAChB,SAAS,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE;IAAEyB,KAAK,EAAE;EAAK,CAAC,CAAC,EAAED,GAAG,CAAC;EAC1F,IAAIE,OAAO,GAAG,CAACC,MAAM,EAAEC,WAAW,EAAEC,SAAS,KAAK;IAChD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAIC,SAAS,GAAIR,KAAK,IAAK;QACzB,IAAI;UACFS,IAAI,CAACL,SAAS,CAACM,IAAI,CAACV,KAAK,CAAC,CAAC;QAC7B,CAAC,CAAC,OAAOW,CAAC,EAAE;UACVJ,MAAM,CAACI,CAAC,CAAC;QACX;MACF,CAAC;MACD,IAAIC,QAAQ,GAAIZ,KAAK,IAAK;QACxB,IAAI;UACFS,IAAI,CAACL,SAAS,CAACS,KAAK,CAACb,KAAK,CAAC,CAAC;QAC9B,CAAC,CAAC,OAAOW,CAAC,EAAE;UACVJ,MAAM,CAACI,CAAC,CAAC;QACX;MACF,CAAC;MACD,IAAIF,IAAI,GAAIK,CAAC,IAAKA,CAAC,CAACC,IAAI,GAAGT,OAAO,CAACQ,CAAC,CAACd,KAAK,CAAC,GAAGK,OAAO,CAACC,OAAO,CAACQ,CAAC,CAACd,KAAK,CAAC,CAACgB,IAAI,CAACR,SAAS,EAAEI,QAAQ,CAAC;MAChGH,IAAI,CAAC,CAACL,SAAS,GAAGA,SAAS,CAACa,KAAK,CAACf,MAAM,EAAEC,WAAW,CAAC,EAAEO,IAAI,EAAE,CAAC;IACjE,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,IAAIQ,eAAe,GAAG,CAAC,CAAC;EACxBjC,QAAQ,CAACiC,eAAe,EAAE;IACxBC,eAAe,EAAE,MAAMA,eAAe;IACtCC,mBAAmB,EAAE,MAAMA,mBAAmB;IAC9CC,KAAK,EAAE,MAAMA,KAAK;IAClBC,SAAS,EAAE,MAAMA,SAAS;IAC1BC,OAAO,EAAE,MAAMC,eAAe;IAC9BC,cAAc,EAAE,MAAMA,cAAc;IACpCC,kBAAkB,EAAE,MAAMA,kBAAkB;IAC5CC,UAAU,EAAE,MAAMA,UAAU;IAC5BC,KAAK,EAAE,MAAMA,KAAK;IAClBC,SAAS,EAAE,MAAMA,SAAS;IAC1BC,aAAa,EAAE,MAAMA,aAAa;IAClCC,OAAO,EAAE,MAAMA;EACjB,CAAC,CAAC;EACFzD,MAAM,CAAC0D,OAAO,GAAGlC,YAAY,CAACoB,eAAe,CAAC;;EAE9C;EACA,SAASe,YAAY,CAACC,MAAM,EAAE;IAC5B,IAAIC,KAAK,GAAInC,KAAK,IAAK;MACrB,IAAIA,KAAK,KAAK,IAAI,EAAE;QAClBoC,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;MACd,CAAC,MAAM,IAAI,OAAOrC,KAAK,KAAK,SAAS,EAAE;QACrCoC,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;QACZD,EAAE,CAACC,MAAM,CAAC,CAACrC,KAAK,CAAC;MACnB,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QACpCoC,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;QACZD,EAAE,CAACE,OAAO,CAACtC,KAAK,GAAG,CAAC,CAAC;MACvB,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QACpCoC,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;QACZD,EAAE,CAACG,KAAK,CAACC,UAAU,CAACxC,KAAK,CAAC,CAAC;MAC7B,CAAC,MAAM,IAAIA,KAAK,YAAYyC,UAAU,EAAE;QACtCL,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;QACZD,EAAE,CAACG,KAAK,CAACvC,KAAK,CAAC;MACjB,CAAC,MAAM,IAAIA,KAAK,YAAY0C,KAAK,EAAE;QACjCN,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;QACZD,EAAE,CAACE,OAAO,CAACtC,KAAK,CAAC2C,MAAM,CAAC;QACxB,KAAK,IAAIC,IAAI,IAAI5C,KAAK,EAAE;UACtBmC,KAAK,CAACS,IAAI,CAAC;QACb;MACF,CAAC,MAAM;QACL,IAAIC,IAAI,GAAGrE,MAAM,CAACqE,IAAI,CAAC7C,KAAK,CAAC;QAC7BoC,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC;QACZD,EAAE,CAACE,OAAO,CAACO,IAAI,CAACF,MAAM,CAAC;QACvB,KAAK,IAAI/C,GAAG,IAAIiD,IAAI,EAAE;UACpBT,EAAE,CAACG,KAAK,CAACC,UAAU,CAAC5C,GAAG,CAAC,CAAC;UACzBuC,KAAK,CAACnC,KAAK,CAACJ,GAAG,CAAC,CAAC;QACnB;MACF;IACF,CAAC;IACD,IAAIwC,EAAE,GAAG,IAAIU,UAAU,EAAE;IACzBV,EAAE,CAACE,OAAO,CAAC,CAAC,CAAC;IACbF,EAAE,CAACE,OAAO,CAACJ,MAAM,CAACa,EAAE,IAAI,CAAC,GAAG,CAAC,CAACb,MAAM,CAACc,SAAS,CAAC;IAC/Cb,KAAK,CAACD,MAAM,CAAClC,KAAK,CAAC;IACnBiD,aAAa,CAACb,EAAE,CAACc,GAAG,EAAEd,EAAE,CAACe,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IACpC,OAAOf,EAAE,CAACc,GAAG,CAACE,QAAQ,CAAC,CAAC,EAAEhB,EAAE,CAACe,GAAG,CAAC;EACnC;EACA,SAASE,YAAY,CAACC,KAAK,EAAE;IAC3B,IAAInB,KAAK,GAAG,MAAM;MAChB,QAAQC,EAAE,CAACmB,KAAK,EAAE;QAChB,KAAK,CAAC;UACJ,OAAO,IAAI;QACb,KAAK,CAAC;UACJ,OAAO,CAAC,CAACnB,EAAE,CAACmB,KAAK,EAAE;QACrB,KAAK,CAAC;UACJ,OAAOnB,EAAE,CAACoB,MAAM,EAAE;QACpB,KAAK,CAAC;UACJ,OAAOC,UAAU,CAACrB,EAAE,CAACsB,IAAI,EAAE,CAAC;QAC9B,KAAK,CAAC;UACJ,OAAOtB,EAAE,CAACsB,IAAI,EAAE;QAClB,KAAK,CAAC;UAAE;YACN,IAAIC,KAAK,GAAGvB,EAAE,CAACoB,MAAM,EAAE;YACvB,IAAII,MAAM,GAAG,EAAE;YACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;cAC9BD,MAAM,CAACE,IAAI,CAAC3B,KAAK,EAAE,CAAC;YACtB;YACA,OAAOyB,MAAM;UACf;QACA,KAAK,CAAC;UAAE;YACN,IAAID,KAAK,GAAGvB,EAAE,CAACoB,MAAM,EAAE;YACvB,IAAII,MAAM,GAAG,CAAC,CAAC;YACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;cAC9BD,MAAM,CAACH,UAAU,CAACrB,EAAE,CAACsB,IAAI,EAAE,CAAC,CAAC,GAAGvB,KAAK,EAAE;YACzC;YACA,OAAOyB,MAAM;UACf;QACA;UACE,MAAM,IAAIG,KAAK,CAAC,gBAAgB,CAAC;MAAC;IAExC,CAAC;IACD,IAAI3B,EAAE,GAAG,IAAIU,UAAU,CAACQ,KAAK,CAAC;IAC9B,IAAIP,EAAE,GAAGX,EAAE,CAACoB,MAAM,EAAE;IACpB,IAAIR,SAAS,GAAG,CAACD,EAAE,GAAG,CAAC,MAAM,CAAC;IAC9BA,EAAE,MAAM,CAAC;IACT,IAAI/C,KAAK,GAAGmC,KAAK,EAAE;IACnB,IAAIC,EAAE,CAAC4B,GAAG,KAAKV,KAAK,CAACX,MAAM,EAAE;MAC3B,MAAM,IAAIoB,KAAK,CAAC,gBAAgB,CAAC;IACnC;IACA,OAAO;MAAEhB,EAAE;MAAEC,SAAS;MAAEhD;IAAM,CAAC;EACjC;EACA,IAAI8C,UAAU,GAAG,MAAM;IACrBmB,WAAW,CAACf,GAAG,GAAG,IAAIT,UAAU,CAAC,IAAI,CAAC,EAAE;MACtC,IAAI,CAACS,GAAG,GAAGA,GAAG;MACd,IAAI,CAACC,GAAG,GAAG,CAAC;MACZ,IAAI,CAACa,GAAG,GAAG,CAAC;IACd;IACAE,MAAM,CAACC,KAAK,EAAE;MACZ,IAAI,IAAI,CAAChB,GAAG,GAAGgB,KAAK,GAAG,IAAI,CAACjB,GAAG,CAACP,MAAM,EAAE;QACtC,IAAIyB,KAAK,GAAG,IAAI3B,UAAU,CAAC,CAAC,IAAI,CAACU,GAAG,GAAGgB,KAAK,IAAI,CAAC,CAAC;QAClDC,KAAK,CAACC,GAAG,CAAC,IAAI,CAACnB,GAAG,CAAC;QACnB,IAAI,CAACA,GAAG,GAAGkB,KAAK;MAClB;MACA,IAAI,CAACjB,GAAG,IAAIgB,KAAK;MACjB,OAAO,IAAI,CAAChB,GAAG,GAAGgB,KAAK;IACzB;IACA9B,MAAM,CAACrC,KAAK,EAAE;MACZ,IAAIsE,MAAM,GAAG,IAAI,CAACJ,MAAM,CAAC,CAAC,CAAC;MAC3B,IAAI,CAAChB,GAAG,CAACoB,MAAM,CAAC,GAAGtE,KAAK;IAC1B;IACAsC,OAAO,CAACtC,KAAK,EAAE;MACb,IAAIsE,MAAM,GAAG,IAAI,CAACJ,MAAM,CAAC,CAAC,CAAC;MAC3BjB,aAAa,CAAC,IAAI,CAACC,GAAG,EAAElD,KAAK,EAAEsE,MAAM,CAAC;IACxC;IACA/B,KAAK,CAACe,KAAK,EAAE;MACX,IAAIgB,MAAM,GAAG,IAAI,CAACJ,MAAM,CAAC,CAAC,GAAGZ,KAAK,CAACX,MAAM,CAAC;MAC1CM,aAAa,CAAC,IAAI,CAACC,GAAG,EAAEI,KAAK,CAACX,MAAM,EAAE2B,MAAM,CAAC;MAC7C,IAAI,CAACpB,GAAG,CAACmB,GAAG,CAACf,KAAK,EAAEgB,MAAM,GAAG,CAAC,CAAC;IACjC;IACAC,KAAK,CAACJ,KAAK,EAAE;MACX,IAAI,IAAI,CAACH,GAAG,GAAGG,KAAK,GAAG,IAAI,CAACjB,GAAG,CAACP,MAAM,EAAE;QACtC,MAAM,IAAIoB,KAAK,CAAC,gBAAgB,CAAC;MACnC;MACA,IAAI,CAACC,GAAG,IAAIG,KAAK;MACjB,OAAO,IAAI,CAACH,GAAG,GAAGG,KAAK;IACzB;IACAZ,KAAK,GAAG;MACN,OAAO,IAAI,CAACL,GAAG,CAAC,IAAI,CAACqB,KAAK,CAAC,CAAC,CAAC,CAAC;IAChC;IACAf,MAAM,GAAG;MACP,OAAOgB,YAAY,CAAC,IAAI,CAACtB,GAAG,EAAE,IAAI,CAACqB,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9C;IACAb,IAAI,GAAG;MACL,IAAIf,MAAM,GAAG,IAAI,CAACa,MAAM,EAAE;MAC1B,IAAIF,KAAK,GAAG,IAAIb,UAAU,CAACE,MAAM,CAAC;MAClC,IAAIqB,GAAG,GAAG,IAAI,CAACO,KAAK,CAACjB,KAAK,CAACX,MAAM,CAAC;MAClCW,KAAK,CAACe,GAAG,CAAC,IAAI,CAACnB,GAAG,CAACE,QAAQ,CAACY,GAAG,EAAEA,GAAG,GAAGrB,MAAM,CAAC,CAAC;MAC/C,OAAOW,KAAK;IACd;EACF,CAAC;EACD,IAAId,UAAU;EACd,IAAIiB,UAAU;EACd,IAAI,OAAOgB,WAAW,KAAK,WAAW,IAAI,OAAOC,WAAW,KAAK,WAAW,EAAE;IAC5E,IAAIC,OAAO,GAAG,IAAIF,WAAW,EAAE;IAC/B,IAAIG,OAAO,GAAG,IAAIF,WAAW,EAAE;IAC/BlC,UAAU,GAAIqC,IAAI,IAAKF,OAAO,CAACG,MAAM,CAACD,IAAI,CAAC;IAC3CpB,UAAU,GAAIH,KAAK,IAAKsB,OAAO,CAACG,MAAM,CAACzB,KAAK,CAAC;EAC/C,CAAC,MAAM,IAAI,OAAO0B,MAAM,KAAK,WAAW,EAAE;IACxCxC,UAAU,GAAIqC,IAAI,IAAK;MACrB,IAAII,MAAM,GAAGD,MAAM,CAACvF,IAAI,CAACoF,IAAI,CAAC;MAC9B,IAAI,EAAEI,MAAM,YAAYxC,UAAU,CAAC,EAAE;QACnCwC,MAAM,GAAG,IAAIxC,UAAU,CAACwC,MAAM,CAAC;MACjC;MACA,OAAOA,MAAM;IACf,CAAC;IACDxB,UAAU,GAAIH,KAAK,IAAK;MACtB,IAAI;QAAE2B,MAAM;QAAEC,UAAU;QAAEC;MAAW,CAAC,GAAG7B,KAAK;MAC9C,OAAO0B,MAAM,CAACvF,IAAI,CAACwF,MAAM,EAAEC,UAAU,EAAEC,UAAU,CAAC,CAACC,QAAQ,EAAE;IAC/D,CAAC;EACH,CAAC,MAAM;IACL,MAAM,IAAIrB,KAAK,CAAC,sBAAsB,CAAC;EACzC;EACA,SAASS,YAAY,CAACS,MAAM,EAAEX,MAAM,EAAE;IACpC,OAAOW,MAAM,CAACX,MAAM,EAAE,CAAC,GAAGW,MAAM,CAACX,MAAM,EAAE,CAAC,IAAI,CAAC,GAAGW,MAAM,CAACX,MAAM,EAAE,CAAC,IAAI,EAAE,GAAGW,MAAM,CAACX,MAAM,EAAE,CAAC,IAAI,EAAE;EACnG;EACA,SAASrB,aAAa,CAACgC,MAAM,EAAEjF,KAAK,EAAEsE,MAAM,EAAE;IAC5CW,MAAM,CAACX,MAAM,EAAE,CAAC,GAAGtE,KAAK;IACxBiF,MAAM,CAACX,MAAM,EAAE,CAAC,GAAGtE,KAAK,IAAI,CAAC;IAC7BiF,MAAM,CAACX,MAAM,EAAE,CAAC,GAAGtE,KAAK,IAAI,EAAE;IAC9BiF,MAAM,CAACX,MAAM,EAAE,CAAC,GAAGtE,KAAK,IAAI,EAAE;EAChC;;EAEA;EACA,IAAIqF,oBAAoB,GAAG,SAAS;EACpC,IAAIC,wBAAwB,GAAG,QAAQ;EACvC,SAASC,cAAc,CAACrG,MAAM,EAAE;IAC9BA,MAAM,IAAI,EAAE;IACZ,IAAIA,MAAM,CAACsG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAC1B,MAAM,IAAIzB,KAAK,CAAE,mBAAkB7E,MAAO,EAAC,CAAC;IAC9C,OAAOA,MAAM;EACf;EACA,IAAIuG,aAAa,GAAG,MAAM,IAAI;EAC9B,IAAIC,aAAa,GAAI1F,KAAK,IAAK,OAAOA,KAAK,KAAK,SAAS,GAAG,IAAI,GAAG,WAAW;EAC9E,IAAI2F,qBAAqB,GAAI3F,KAAK,IAAK,OAAOA,KAAK,KAAK,SAAS,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAAC0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,GAAG,IAAI,GAAG,wBAAwB;EACzJ,IAAI6F,YAAY,GAAI7F,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,GAAG,IAAI,GAAG,UAAU;EAC3E,IAAI8F,YAAY,GAAI9F,KAAK,IAAKA,KAAK,YAAY+F,MAAM,GAAG,IAAI,GAAG,iBAAiB;EAChF,IAAIC,aAAa,GAAIhG,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,MAAMA,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,YAAY;EACvG,IAAIiG,cAAc,GAAIjG,KAAK,IAAK,OAAOA,KAAK,KAAK,UAAU,GAAG,IAAI,GAAG,YAAY;EACjF,IAAIkG,WAAW,GAAIlG,KAAK,IAAK0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,GAAG,IAAI,GAAG,UAAU;EACrE,IAAImG,YAAY,GAAInG,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAI,CAAC0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,GAAG,IAAI,GAAG,WAAW;EACvH,IAAIoG,uBAAuB,GAAIpG,KAAK,IAAKA,KAAK,YAAYqG,WAAW,CAACC,MAAM,GAAG,IAAI,GAAG,sBAAsB;EAC5G,IAAIC,mBAAmB,GAAIvG,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,uBAAuB;EACjH,IAAIwG,kBAAkB,GAAIxG,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAAC0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,GAAG,IAAI,GAAG,mBAAmB;EACnH,IAAIyG,qBAAqB,GAAIzG,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,SAAS,GAAG,IAAI,GAAG,uBAAuB;EAC/H,IAAI0G,oBAAoB,GAAI1G,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAI,CAAC0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,GAAG,IAAI,GAAG,uBAAuB;EACxK,IAAI2G,mBAAmB,GAAI3G,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAI0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,GAAG,IAAI,GAAG,sBAAsB;EACtH,IAAI4G,wBAAwB,GAAI5G,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAYyC,UAAU,GAAG,IAAI,GAAG,0BAA0B;EACtI,SAASoE,OAAO,CAACC,MAAM,EAAEjE,IAAI,EAAEjD,GAAG,EAAEmH,QAAQ,EAAE;IAC5C,IAAI/G,KAAK,GAAG8G,MAAM,CAAClH,GAAG,CAAC;IACvBiD,IAAI,CAACjD,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI;IACrB,IAAII,KAAK,KAAK,KAAK,CAAC,EAClB,OAAO,KAAK,CAAC;IACf,IAAIgH,MAAM,GAAGD,QAAQ,CAAC/G,KAAK,CAAC;IAC5B,IAAIgH,MAAM,KAAK,IAAI,EACjB,MAAM,IAAIjD,KAAK,CAAE,IAAGnE,GAAI,aAAYoH,MAAO,EAAC,CAAC;IAC/C,OAAOhH,KAAK;EACd;EACA,SAASiH,oBAAoB,CAACH,MAAM,EAAEjE,IAAI,EAAEqE,KAAK,EAAE;IACjD,KAAK,IAAItH,GAAG,IAAIkH,MAAM,EAAE;MACtB,IAAI,EAAElH,GAAG,IAAIiD,IAAI,CAAC,EAAE;QAClB,MAAM,IAAIkB,KAAK,CAAE,kBAAiBmD,KAAM,MAAKtH,GAAI,GAAE,CAAC;MACtD;IACF;EACF;EACA,SAASuH,yBAAyB,CAACC,OAAO,EAAE;IAC1C,IAAIvE,IAAI,GAAG,eAAgBrE,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;IAC9C,IAAIC,OAAO,GAAGT,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,SAAS,EAAEgD,YAAY,CAAC;IAC7D,IAAI0B,UAAU,GAAGV,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEuD,uBAAuB,CAAC;IAC9E,IAAIoB,MAAM,GAAGX,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAE6C,aAAa,CAAC;IAC5DuB,oBAAoB,CAACG,OAAO,EAAEvE,IAAI,EAAE,sBAAsB,CAAC;IAC3D,OAAO;MACLyE,OAAO;MACPC,UAAU;MACVC;IACF,CAAC;EACH;EACA,SAASC,mBAAmB,CAACC,WAAW,EAAE;IACxC,IAAIC,SAAS;IACb,IAAID,WAAW,KAAK,KAAK,CAAC,EAAE;MAC1BC,SAAS,GAAG,eAAgBnJ,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;MAC/C,KAAK,IAAIzH,GAAG,IAAIpB,MAAM,CAACqE,IAAI,CAAC6E,WAAW,CAAC,EAAE;QACxC,IAAI1H,KAAK,GAAG0H,WAAW,CAAC9H,GAAG,CAAC;QAC5B,IAAI,OAAOI,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,KAAK,EAAE;UAChD2H,SAAS,CAAC/H,GAAG,CAAC,GAAGI,KAAK;QACxB,CAAC,MAAM;UACL,MAAM,IAAI+D,KAAK,CAAE,YAAW6D,IAAI,CAACC,SAAS,CAACjI,GAAG,CAAE,qDAAoD,CAAC;QACvG;MACF;IACF;IACA,OAAO+H,SAAS;EAClB;EACA,SAASG,YAAY,CAACC,KAAK,EAAEX,OAAO,EAAEvE,IAAI,EAAEmF,KAAK,EAAEC,eAAe,EAAE;IAClE,IAAIC,KAAK,GAAGrB,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,OAAO,EAAE6C,aAAa,CAAC;IAC1D,IAAIyC,QAAQ,GAAGtB,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAEgD,YAAY,CAAC;IAC/D,IAAIuC,QAAQ,GAAGvB,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAEmD,aAAa,CAAC;IAChE,IAAIkC,KAAK,KAAK,KAAK,CAAC,EAClBH,KAAK,CAACjE,IAAI,CAAE,WAAUoE,KAAM,EAAC,CAAC,CAAC,KAC5B,IAAIF,KAAK,EACZD,KAAK,CAACjE,IAAI,CAAE,cAAa,CAAC;IAC5BiE,KAAK,CAACjE,IAAI,CAAE,eAAcqE,QAAQ,IAAIF,eAAgB,EAAC,CAAC;IACxDF,KAAK,CAACjE,IAAI,CAAE,eAAcsE,QAAQ,IAAI,CAAE,EAAC,CAAC;EAC5C;EACA,SAASC,eAAe,CAACN,KAAK,EAAEX,OAAO,EAAEvE,IAAI,EAAE;IAC7C,IAAIyF,aAAa,GAAGzB,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,eAAe,EAAEgD,YAAY,CAAC;IACzE,IAAI0C,UAAU,GAAG1B,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAI2C,cAAc,GAAG3B,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,gBAAgB,EAAE6C,aAAa,CAAC;IAC5E,IAAIxG,MAAM,GAAG2H,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAE8D,mBAAmB,CAAC;IAClE,IAAI8B,MAAM,GAAG5B,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;IAC3D,IAAI6C,UAAU,GAAG7B,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAI8C,WAAW,GAAG9B,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAEiD,YAAY,CAAC;IACrE,IAAI8C,YAAY,GAAG/B,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,cAAc,EAAEiD,YAAY,CAAC;IACvE,IAAI+C,YAAY,GAAGhC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,cAAc,EAAE6C,aAAa,CAAC;IACxE,IAAIoD,MAAM,GAAGjC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAE6C,aAAa,CAAC;IAC5D,IAAIqD,YAAY,GAAGlC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,cAAc,EAAE6C,aAAa,CAAC;IACxE,IAAIsD,gBAAgB,GAAGnC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,kBAAkB,EAAE6C,aAAa,CAAC;IAChF,IAAIuD,iBAAiB,GAAGpC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,mBAAmB,EAAE6C,aAAa,CAAC;IAClF,IAAIwD,IAAI,GAAGrC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,MAAM,EAAEqD,WAAW,CAAC;IACtD,IAAIiD,OAAO,GAAGtC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,SAAS,EAAEgD,YAAY,CAAC;IAC7D,IAAIuD,WAAW,GAAGvC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAE6C,aAAa,CAAC;IACtE,IAAI2D,iBAAiB,GAAGxC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,mBAAmB,EAAE6C,aAAa,CAAC;IAClF,IAAI4D,GAAG,GAAGzC,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,KAAK,EAAEgD,YAAY,CAAC;IACrD,IAAI0D,UAAU,GAAG1C,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAI2D,WAAW,GAAG3C,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAEgD,YAAY,CAAC;IACrE,IAAI4D,eAAe,GAAG5C,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,iBAAiB,EAAEgD,YAAY,CAAC;IAC7E,IAAI6D,MAAM,GAAG7C,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAE6C,aAAa,CAAC;IAC5D,IAAIiE,cAAc,GAAG9C,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,gBAAgB,EAAE6C,aAAa,CAAC;IAC5E,IAAIkE,MAAM,GAAG/C,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEsD,YAAY,CAAC;IAC3D,IAAI0D,WAAW,GAAGhD,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAEsD,YAAY,CAAC;IACrE,IAAI2D,SAAS,GAAGjD,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAEsD,YAAY,CAAC;IACjE,IAAI4D,IAAI,GAAGlD,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,MAAM,EAAEqD,WAAW,CAAC;IACtD,IAAI8D,SAAS,GAAGnD,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAE6C,aAAa,CAAC;IAClE,IAAIuE,QAAQ,GAAGpD,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAEgD,YAAY,CAAC;IAC/D,IAAIyC,aAAa,EACfP,KAAK,CAACjE,IAAI,CAAE,oBAAmBwE,aAAc,EAAC,CAAC;IACjD,IAAIC,UAAU,KAAK,KAAK,CAAC,EACvBR,KAAK,CAACjE,IAAI,CAAE,iBAAgByE,UAAW,EAAC,CAAC;IAC3C,IAAIC,cAAc,KAAK,KAAK,CAAC,EAC3BT,KAAK,CAACjE,IAAI,CAAE,qBAAoB0E,cAAe,EAAC,CAAC;IACnD,IAAItJ,MAAM,EAAE;MACV,IAAIwD,KAAK,CAACkD,OAAO,CAAC1G,MAAM,CAAC,EACvB6I,KAAK,CAACjE,IAAI,CAAE,YAAWpB,KAAK,CAACjD,IAAI,CAACP,MAAM,CAAC,CAACgL,GAAG,CAAC3E,cAAc,CAAC,CAAC4E,IAAI,CAAC,GAAG,CAAE,EAAC,CAAC,CAAC,KAE3EpC,KAAK,CAACjE,IAAI,CAAE,YAAWyB,cAAc,CAACrG,MAAM,CAAE,EAAC,CAAC;IACpD;IACA,IAAIuJ,MAAM,EACRV,KAAK,CAACjE,IAAI,CAAE,YAAW2E,MAAO,EAAC,CAAC;IAClC,IAAIC,UAAU,EACZX,KAAK,CAACjE,IAAI,CAAE,iBAAgB4E,UAAW,EAAC,CAAC;IAC3C,IAAIuB,QAAQ,EACVlC,KAAK,CAACjE,IAAI,CAAE,cAAamG,QAAS,EAAC,CAAC;IACtC,IAAInB,MAAM,EACRf,KAAK,CAACjE,IAAI,CAAC,UAAU,CAAC;IACxB,IAAIiF,YAAY,EACdhB,KAAK,CAACjE,IAAI,CAAC,iBAAiB,CAAC;IAC/B,IAAIkF,gBAAgB,EAClBjB,KAAK,CAACjE,IAAI,CAAC,qBAAqB,CAAC;IACnC,IAAImF,iBAAiB,EACnBlB,KAAK,CAACjE,IAAI,CAAC,sBAAsB,CAAC;IACpC,IAAIqF,OAAO,EACTpB,KAAK,CAACjE,IAAI,CAAE,aAAYqF,OAAQ,EAAC,CAAC;IACpC,IAAIC,WAAW,KAAK,KAAK,CAAC,EACxBrB,KAAK,CAACjE,IAAI,CAAE,kBAAiBsF,WAAY,EAAC,CAAC;IAC7C,IAAIC,iBAAiB,EACnBtB,KAAK,CAACjE,IAAI,CAAE,sBAAqB,CAAC;IACpC,IAAIoF,IAAI,EACN,KAAK,IAAIkB,IAAI,IAAIlB,IAAI,EACnBnB,KAAK,CAACjE,IAAI,CAAE,UAASsG,IAAK,EAAC,CAAC;IAChC,IAAIzB,WAAW,EACbZ,KAAK,CAACjE,IAAI,CAAE,kBAAiB6E,WAAW,CAAC0B,MAAO,EAAC,CAAC;IACpD,IAAIzB,YAAY,EACdb,KAAK,CAACjE,IAAI,CAAE,mBAAkB8E,YAAY,CAACyB,MAAO,EAAC,CAAC;IACtD,IAAIxB,YAAY,KAAK,KAAK,CAAC,EACzBd,KAAK,CAACjE,IAAI,CAAE,mBAAkB+E,YAAa,EAAC,CAAC;IAC/C,IAAIS,GAAG,EACLvB,KAAK,CAACjE,IAAI,CAAE,SAAQwF,GAAI,EAAC,CAAC;IAC5B,IAAIC,UAAU,EACZxB,KAAK,CAACjE,IAAI,CAAE,iBAAgByF,UAAW,EAAC,CAAC;IAC3C,IAAIC,WAAW,EACbzB,KAAK,CAACjE,IAAI,CAAE,kBAAiB0F,WAAY,EAAC,CAAC;IAC7C,IAAIC,eAAe,EACjB1B,KAAK,CAACjE,IAAI,CAAE,uBAAsB2F,eAAgB,EAAC,CAAC;IACtD,IAAIC,MAAM,EACR3B,KAAK,CAACjE,IAAI,CAAE,WAAU,CAAC;IACzB,IAAI6F,cAAc,EAChB5B,KAAK,CAACjE,IAAI,CAAE,oBAAmB,CAAC;IAClC,IAAI8F,MAAM,EAAE;MACV,KAAK,IAAIhK,GAAG,IAAIgK,MAAM,EAAE;QACtB,IAAIhK,GAAG,CAAC4F,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,MAAM,IAAIzB,KAAK,CAAE,mBAAkBnE,GAAI,EAAC,CAAC;QAC3CmI,KAAK,CAACjE,IAAI,CAAE,YAAWlE,GAAI,IAAGgK,MAAM,CAAChK,GAAG,CAAE,EAAC,CAAC;MAC9C;IACF;IACA,IAAIiK,WAAW,EAAE;MACf,KAAK,IAAIjK,GAAG,IAAIiK,WAAW,EAAE;QAC3B,IAAIjK,GAAG,CAAC4F,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,MAAM,IAAIzB,KAAK,CAAE,yBAAwBnE,GAAI,EAAC,CAAC;QACjDmI,KAAK,CAACjE,IAAI,CAAE,kBAAiBlE,GAAI,IAAGiK,WAAW,CAACjK,GAAG,CAAE,EAAC,CAAC;MACzD;IACF;IACA,IAAIkK,SAAS,EAAE;MACb,KAAK,IAAIlK,GAAG,IAAIkK,SAAS,EAAE;QACzB,IAAIlK,GAAG,CAAC4F,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,MAAM,IAAIzB,KAAK,CAAE,sBAAqBnE,GAAI,EAAC,CAAC;QAC9CmI,KAAK,CAACjE,IAAI,CAAE,eAAclE,GAAI,IAAGkK,SAAS,CAAClK,GAAG,CAAE,EAAC,CAAC;MACpD;IACF;IACA,IAAImK,IAAI,EACN,KAAK,IAAIO,EAAE,IAAIP,IAAI,EACjBhC,KAAK,CAACjE,IAAI,CAAE,UAASwG,EAAG,EAAC,CAAC;IAC9B,IAAIN,SAAS,EACXjC,KAAK,CAACjE,IAAI,CAAE,cAAa,CAAC;EAC9B;EACA,SAASyG,oBAAoB,CAACC,QAAQ,EAAEpD,OAAO,EAAEY,KAAK,EAAEC,eAAe,EAAEwC,YAAY,EAAE;IACrF,IAAIC,EAAE;IACN,IAAI3C,KAAK,GAAG,EAAE;IACd,IAAI4C,OAAO,GAAG,EAAE;IAChB,IAAI9H,IAAI,GAAG,eAAgBrE,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;IAC9C,IAAIuD,aAAa,GAAG,IAAI;IACxB,IAAIC,eAAe,GAAG,IAAI;IAC1B,IAAIC,SAAS,GAAG,IAAI;IACpBhD,YAAY,CAACC,KAAK,EAAEX,OAAO,EAAEvE,IAAI,EAAEmF,KAAK,EAAEC,eAAe,CAAC;IAC1DI,eAAe,CAACN,KAAK,EAAEX,OAAO,EAAEvE,IAAI,CAAC;IACrC,IAAIkI,SAAS,GAAGlE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAE4D,qBAAqB,CAAC;IAC1E,IAAIuE,MAAM,GAAGnE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAE6C,aAAa,CAAC;IAC5D,IAAIuF,KAAK,GAAGpE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,OAAO,EAAE8C,qBAAqB,CAAC;IAClE,IAAIuF,SAAS,GAAGrE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAE6C,aAAa,CAAC;IAClE,IAAIyF,gBAAgB,GAAGtE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,kBAAkB,EAAE6C,aAAa,CAAC;IAChF,IAAI0F,QAAQ,GAAGvE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAE6C,aAAa,CAAC;IAChE,IAAI2F,OAAO,GAAGxE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,SAAS,EAAEgD,YAAY,CAAC;IAC7D,IAAIyF,MAAM,GAAGzE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;IAC3D,IAAI0F,OAAO,GAAG1E,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,SAAS,EAAEgD,YAAY,CAAC;IAC7D,IAAI2F,QAAQ,GAAG3E,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAEgD,YAAY,CAAC;IAC/D,IAAI4F,iBAAiB,GAAG5E,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,mBAAmB,EAAEqD,WAAW,CAAC;IAChF,IAAIwF,cAAc,GAAG7E,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAEqD,WAAW,CAAC;IACrE,IAAIyF,UAAU,GAAG9E,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEqD,WAAW,CAAC;IAClE,IAAI0F,UAAU,GAAG/E,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEqD,WAAW,CAAC;IAClE,IAAI2F,QAAQ,GAAGhF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAEqD,WAAW,CAAC;IAC9D,IAAI4F,MAAM,GAAGjF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEsD,YAAY,CAAC;IAC3D,IAAI4F,YAAY,GAAGlF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,cAAc,EAAEsD,YAAY,CAAC;IACvE,IAAI6F,UAAU,GAAGnF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAIoG,UAAU,GAAGpF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAIqG,UAAU,GAAGrF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAIsG,UAAU,GAAGtF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAIuG,MAAM,GAAGvF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEqD,WAAW,CAAC;IAC1D,IAAImG,MAAM,GAAGxF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEsD,YAAY,CAAC;IAC3D,IAAImG,MAAM,GAAGzF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEsD,YAAY,CAAC;IAC3D,IAAIoG,WAAW,GAAG1F,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAE0D,mBAAmB,CAAC;IAC5E,IAAIiG,aAAa,GAAG3F,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,eAAe,EAAEgD,YAAY,CAAC;IACzE,IAAI4G,KAAK,GAAG5F,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,OAAO,EAAEsD,YAAY,CAAC;IACzD,IAAI5D,KAAK,GAAG,CAACmI,EAAE,GAAG7D,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,OAAO,EAAE6C,aAAa,CAAC,KAAK,IAAI,GAAGgF,EAAE,GAAGD,YAAY;IAC7F,IAAIiC,cAAc,GAAG7F,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,gBAAgB,EAAE6C,aAAa,CAAC;IAC5E,IAAIiH,WAAW,GAAG9F,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAE6C,aAAa,CAAC,KAAK,IAAI;IAC/E,IAAIgC,WAAW,GAAGb,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAEsD,YAAY,CAAC;IACrEtD,IAAI,CAAC+J,OAAO,GAAG,IAAI;IACnB3F,oBAAoB,CAACG,OAAO,EAAEvE,IAAI,EAAG,MAAK2H,QAAS,SAAQ,CAAC;IAC5D,IAAIO,SAAS,EACXhD,KAAK,CAACjE,IAAI,CAAE,cAAaiH,SAAS,KAAK,IAAI,GAAG,EAAE,GAAI,IAAGA,SAAU,EAAE,EAAC,CAAC;IACvE,IAAIC,MAAM,EACRjD,KAAK,CAACjE,IAAI,CAAC,UAAU,CAAC;IACxB,IAAI4I,cAAc,EAChB3E,KAAK,CAACjE,IAAI,CAAC,mBAAmB,CAAC;IACjC,IAAImH,KAAK,EAAE;MACTlD,KAAK,CAACjE,IAAI,CAAC,SAAS,CAAC;MACrB,IAAI,OAAOmH,KAAK,KAAK,SAAS,EAAE;QAC9BH,SAAS,GAAG,CAAC,CAAC;MAChB,CAAC,MAAM;QACL,IAAI+B,SAAS,GAAG,eAAgBrO,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;QACnD,IAAIyF,SAAS,GAAGjG,OAAO,CAACoE,KAAK,EAAE4B,SAAS,EAAE,WAAW,EAAE5G,cAAc,CAAC;QACtEgB,oBAAoB,CAACgE,KAAK,EAAE4B,SAAS,EAAG,iBAAgBrC,QAAS,SAAQ,CAAC;QAC1EM,SAAS,GAAG;UAAEgC;QAAU,CAAC;MAC3B;IACF;IACA,IAAI5B,SAAS,EACXnD,KAAK,CAACjE,IAAI,CAAC,aAAa,CAAC;IAC3B,IAAIqH,gBAAgB,EAClBpD,KAAK,CAACjE,IAAI,CAAC,qBAAqB,CAAC;IACnC,IAAIsH,QAAQ,EACVrD,KAAK,CAACjE,IAAI,CAAE,YAAW,CAAC;IAC1B,IAAIuH,OAAO,EACTtD,KAAK,CAACjE,IAAI,CAAE,aAAYuH,OAAQ,EAAC,CAAC;IACpC,IAAIC,MAAM,EACRvD,KAAK,CAACjE,IAAI,CAAE,YAAWwH,MAAO,EAAC,CAAC;IAClC,IAAIC,OAAO,EACTxD,KAAK,CAACjE,IAAI,CAAE,aAAYyH,OAAQ,EAAC,CAAC;IACpC,IAAIC,QAAQ,EACVzD,KAAK,CAACjE,IAAI,CAAE,cAAa0H,QAAS,EAAC,CAAC;IACtC,IAAIC,iBAAiB,EAAE;MACrB,IAAIsB,MAAM,GAAG,EAAE;MACf,KAAK,IAAI/M,KAAK,IAAIyL,iBAAiB,EAAE;QACnCzL,KAAK,IAAI,EAAE;QACX,IAAIA,KAAK,CAACwF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACzB,MAAM,IAAIzB,KAAK,CAAE,8BAA6B/D,KAAM,EAAC,CAAC;QACxD+M,MAAM,CAACjJ,IAAI,CAAC9D,KAAK,CAAC;MACpB;MACA+H,KAAK,CAACjE,IAAI,CAAE,wBAAuBiJ,MAAM,CAAC5C,IAAI,CAAC,GAAG,CAAE,EAAC,CAAC;IACxD;IACA,IAAI6B,UAAU,EACZjE,KAAK,CAACjE,IAAI,CAAE,iBAAgBkI,UAAW,EAAC,CAAC;IAC3C,IAAIC,UAAU,EACZlE,KAAK,CAACjE,IAAI,CAAE,iBAAgBmI,UAAW,EAAC,CAAC;IAC3C,IAAIC,UAAU,EACZnE,KAAK,CAACjE,IAAI,CAAE,iBAAgBoI,UAAW,EAAC,CAAC;IAC3C,IAAIC,UAAU,EACZpE,KAAK,CAACjE,IAAI,CAAE,iBAAgBqI,UAAW,EAAC,CAAC;IAC3C,IAAIR,UAAU,EAAE;MACd,IAAIoB,MAAM,GAAG,EAAE;MACf,KAAK,IAAI/M,KAAK,IAAI2L,UAAU,EAAE;QAC5B3L,KAAK,IAAI,EAAE;QACX,IAAIA,KAAK,CAACwF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACzB,MAAM,IAAIzB,KAAK,CAAE,uBAAsB/D,KAAM,EAAC,CAAC;QACjD+M,MAAM,CAACjJ,IAAI,CAAC9D,KAAK,CAAC;MACpB;MACA+H,KAAK,CAACjE,IAAI,CAAE,iBAAgBiJ,MAAM,CAAC5C,IAAI,CAAC,GAAG,CAAE,EAAC,CAAC;IACjD;IACA,IAAIyB,UAAU,EAAE;MACd,IAAImB,MAAM,GAAG,EAAE;MACf,KAAK,IAAI/M,KAAK,IAAI4L,UAAU,EAAE;QAC5B5L,KAAK,IAAI,EAAE;QACX,IAAIA,KAAK,CAACwF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACzB,MAAM,IAAIzB,KAAK,CAAE,sBAAqB/D,KAAM,EAAC,CAAC;QAChD+M,MAAM,CAACjJ,IAAI,CAAC9D,KAAK,CAAC;MACpB;MACA+H,KAAK,CAACjE,IAAI,CAAE,gBAAeiJ,MAAM,CAAC5C,IAAI,CAAC,GAAG,CAAE,EAAC,CAAC;IAChD;IACA,IAAI0B,QAAQ,EACV,KAAK,IAAIzM,IAAI,IAAIyM,QAAQ,EACvB9D,KAAK,CAACjE,IAAI,CAAE,cAAa1E,IAAK,EAAC,CAAC;IACpC,IAAIiN,MAAM,EAAE;MACV,KAAK,IAAIW,IAAI,IAAIX,MAAM,EAAE;QACvB,IAAIW,IAAI,CAACxH,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACxB,MAAM,IAAIzB,KAAK,CAAE,6BAA4BiJ,IAAK,EAAC,CAAC;QACtDjF,KAAK,CAACjE,IAAI,CAAE,YAAWkJ,IAAK,IAAGX,MAAM,CAACW,IAAI,CAAE,EAAC,CAAC;MAChD;IACF;IACA,IAAIV,MAAM,EAAE;MACV,KAAK,IAAIU,IAAI,IAAIV,MAAM,EAAE;QACvB,IAAIU,IAAI,CAACxH,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACxB,MAAM,IAAIzB,KAAK,CAAE,6BAA4BiJ,IAAK,EAAC,CAAC;QACtDjF,KAAK,CAACjE,IAAI,CAAE,YAAWkJ,IAAK,IAAGV,MAAM,CAACU,IAAI,CAAE,EAAC,CAAC;MAChD;IACF;IACA,IAAIZ,MAAM,EACR,KAAK,IAAIa,IAAI,IAAIb,MAAM,EACrBrE,KAAK,CAACjE,IAAI,CAAE,YAAWmJ,IAAK,EAAC,CAAC;IAClC,IAAInB,MAAM,EAAE;MACV,KAAK,IAAIoB,GAAG,IAAIpB,MAAM,EAAE;QACtB,IAAIoB,GAAG,CAAC1H,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,MAAM,IAAIzB,KAAK,CAAE,6BAA4BmJ,GAAI,EAAC,CAAC;QACrDnF,KAAK,CAACjE,IAAI,CAAE,YAAWoJ,GAAI,IAAGpB,MAAM,CAACoB,GAAG,CAAE,EAAC,CAAC;MAC9C;IACF;IACA,IAAInB,YAAY,EAAE;MAChB,KAAK,IAAImB,GAAG,IAAInB,YAAY,EAAE;QAC5B,IAAImB,GAAG,CAAC1H,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,MAAM,IAAIzB,KAAK,CAAE,0BAAyBmJ,GAAI,EAAC,CAAC;QAClDnF,KAAK,CAACjE,IAAI,CAAE,mBAAkBoJ,GAAI,IAAGnB,YAAY,CAACmB,GAAG,CAAE,EAAC,CAAC;MAC3D;IACF;IACA,IAAIX,WAAW,EAAE;MACf,IAAI7J,KAAK,CAACkD,OAAO,CAAC2G,WAAW,CAAC,EAAE;QAC9B,KAAK,IAAIY,UAAU,IAAIZ,WAAW,EAAE;UAClC5B,OAAO,CAAC7G,IAAI,CAAC,CAAC,EAAE,EAAEqJ,UAAU,GAAG,EAAE,CAAC,CAAC;QACrC;MACF,CAAC,MAAM;QACL,KAAK,IAAI,CAACvN,GAAG,EAAEI,KAAK,CAAC,IAAIxB,MAAM,CAACmM,OAAO,CAAC4B,WAAW,CAAC,EAAE;UACpD5B,OAAO,CAAC7G,IAAI,CAAC,CAAClE,GAAG,GAAG,EAAE,EAAEI,KAAK,GAAG,EAAE,CAAC,CAAC;QACtC;MACF;IACF;IACA,IAAIyM,KAAK,EAAE;MACT,IAAIW,SAAS,GAAG,eAAgB5O,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;MACnD,IAAIgG,QAAQ,GAAGxG,OAAO,CAAC4F,KAAK,EAAEW,SAAS,EAAE,UAAU,EAAExG,wBAAwB,CAAC;MAC9E,IAAI0G,UAAU,GAAGzG,OAAO,CAAC4F,KAAK,EAAEW,SAAS,EAAE,YAAY,EAAEvH,YAAY,CAAC;MACtE,IAAI0H,UAAU,GAAG1G,OAAO,CAAC4F,KAAK,EAAEW,SAAS,EAAE,YAAY,EAAEvH,YAAY,CAAC;MACtE,IAAI2H,OAAO,GAAG3G,OAAO,CAAC4F,KAAK,EAAEW,SAAS,EAAE,QAAQ,EAAEvH,YAAY,CAAC;MAC/DoB,oBAAoB,CAACwF,KAAK,EAAEW,SAAS,EAAE,mBAAmB,CAAC;MAC3D,IAAIG,UAAU,EACZxF,KAAK,CAACjE,IAAI,CAAE,gBAAeyJ,UAAW,EAAC,CAAC;MAC1C,IAAIC,OAAO,EACTzF,KAAK,CAACjE,IAAI,CAAE,YAAW0J,OAAQ,EAAC,CAAC;MACnC,IAAIF,UAAU,EACZzC,eAAe,GAAGyC,UAAU,GAAG,EAAE;MACnC,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAC9BzC,aAAa,GAAGpI,UAAU,CAAC6K,QAAQ,CAAC,CAAC,KAClC,IAAIA,QAAQ,YAAY5K,UAAU,EACrCmI,aAAa,GAAGyC,QAAQ;IAC5B;IACA,IAAII,SAAS,GAAG,EAAE;IAClB,IAAI/B,cAAc,EAAE;MAClB,KAAK,IAAI1L,KAAK,IAAI0L,cAAc,EAAE;QAChC1L,KAAK,IAAI,EAAE;QACXyN,SAAS,CAAC3J,IAAI,CAAC9D,KAAK,CAAC;MACvB;IACF;IACA,OAAO;MACL2K,OAAO;MACP5C,KAAK;MACLxF,KAAK;MACLqI,aAAa;MACbC,eAAe;MACf2B,aAAa;MACbG,WAAW;MACXc,SAAS;MACTxC,KAAK,EAAEH,SAAS;MAChBpD,WAAW,EAAED,mBAAmB,CAACC,WAAW;IAC9C,CAAC;EACH;EACA,SAASgG,wBAAwB,CAAClD,QAAQ,EAAEpD,OAAO,EAAEY,KAAK,EAAEC,eAAe,EAAE;IAC3E,IAAIF,KAAK,GAAG,EAAE;IACd,IAAIlF,IAAI,GAAG,eAAgBrE,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;IAC9CS,YAAY,CAACC,KAAK,EAAEX,OAAO,EAAEvE,IAAI,EAAEmF,KAAK,EAAEC,eAAe,CAAC;IAC1DI,eAAe,CAACN,KAAK,EAAEX,OAAO,EAAEvE,IAAI,CAAC;IACrC,IAAIkI,SAAS,GAAGlE,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAE4D,qBAAqB,CAAC;IAC1E,IAAIkH,WAAW,GAAG9G,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAE6D,oBAAoB,CAAC;IAC7E,IAAI6G,UAAU,GAAG1G,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACnE,IAAIiG,MAAM,GAAGjF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;IAC3D,IAAIwG,MAAM,GAAGxF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;IAC3D,IAAIyG,MAAM,GAAGzF,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;IAC3D,IAAI6B,WAAW,GAAGb,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,aAAa,EAAEsD,YAAY,CAAC;IACrEc,oBAAoB,CAACG,OAAO,EAAEvE,IAAI,EAAG,MAAK2H,QAAS,SAAQ,CAAC;IAC5D,IAAIO,SAAS,EACXhD,KAAK,CAACjE,IAAI,CAAE,eAAciH,SAAS,KAAK,IAAI,GAAG,UAAU,GAAGA,SAAU,EAAC,CAAC;IAC1E,IAAI4C,WAAW,EACb5F,KAAK,CAACjE,IAAI,CAAE,kBAAiB,OAAO6J,WAAW,KAAK,QAAQ,GAAGA,WAAW,GAAG/F,IAAI,CAACC,SAAS,CAAC8F,WAAW,CAAE,EAAC,CAAC;IAC7G,IAAIJ,UAAU,EACZxF,KAAK,CAACjE,IAAI,CAAE,gBAAeyJ,UAAW,EAAC,CAAC;IAC1C,IAAIzB,MAAM,EACR/D,KAAK,CAACjE,IAAI,CAAE,YAAWgI,MAAO,EAAC,CAAC;IAClC,IAAIO,MAAM,EACRtE,KAAK,CAACjE,IAAI,CAAE,YAAWuI,MAAO,EAAC,CAAC;IAClC,IAAIC,MAAM,EACRvE,KAAK,CAACjE,IAAI,CAAE,YAAWwI,MAAO,EAAC,CAAC;IAClC,OAAO;MACLvE,KAAK;MACLL,WAAW,EAAED,mBAAmB,CAACC,WAAW;IAC9C,CAAC;EACH;EACA,SAASkG,aAAa,CAACC,QAAQ,EAAE;IAC/B,MAAMC,qBAAqB,GAAG,CAAC,CAAC;IAChC,MAAMC,SAAS,GAAG;MAAEC,QAAQ,EAAE,KAAK;MAAEC,MAAM,EAAE;IAAG,CAAC;IACjD,IAAIC,iBAAiB,GAAG,CAAC,CAAC;IAC1B,IAAIC,aAAa,GAAG,CAAC;IACrB,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIC,MAAM,GAAG,IAAI5L,UAAU,CAAC,EAAE,GAAG,IAAI,CAAC;IACtC,IAAI6L,UAAU,GAAG,CAAC;IAClB,IAAIC,cAAc,GAAIC,KAAK,IAAK;MAC9B,IAAIC,KAAK,GAAGH,UAAU,GAAGE,KAAK,CAAC7L,MAAM;MACrC,IAAI8L,KAAK,GAAGJ,MAAM,CAAC1L,MAAM,EAAE;QACzB,IAAI+L,IAAI,GAAG,IAAIjM,UAAU,CAACgM,KAAK,GAAG,CAAC,CAAC;QACpCC,IAAI,CAACrK,GAAG,CAACgK,MAAM,CAAC;QAChBA,MAAM,GAAGK,IAAI;MACf;MACAL,MAAM,CAAChK,GAAG,CAACmK,KAAK,EAAEF,UAAU,CAAC;MAC7BA,UAAU,IAAIE,KAAK,CAAC7L,MAAM;MAC1B,IAAI2B,MAAM,GAAG,CAAC;MACd,OAAOA,MAAM,GAAG,CAAC,IAAIgK,UAAU,EAAE;QAC/B,IAAI3L,MAAM,GAAG6B,YAAY,CAAC6J,MAAM,EAAE/J,MAAM,CAAC;QACzC,IAAIA,MAAM,GAAG,CAAC,GAAG3B,MAAM,GAAG2L,UAAU,EAAE;UACpC;QACF;QACAhK,MAAM,IAAI,CAAC;QACXqK,oBAAoB,CAACN,MAAM,CAACjL,QAAQ,CAACkB,MAAM,EAAEA,MAAM,GAAG3B,MAAM,CAAC,CAAC;QAC9D2B,MAAM,IAAI3B,MAAM;MAClB;MACA,IAAI2B,MAAM,GAAG,CAAC,EAAE;QACd+J,MAAM,CAACO,UAAU,CAAC,CAAC,EAAEtK,MAAM,EAAEgK,UAAU,CAAC;QACxCA,UAAU,IAAIhK,MAAM;MACtB;IACF,CAAC;IACD,IAAIuK,UAAU,GAAIC,KAAK,IAAK;MAC1Bf,SAAS,CAACC,QAAQ,GAAG,IAAI;MACzB,IAAIc,KAAK,EACPf,SAAS,CAACE,MAAM,GAAG,IAAI,IAAIa,KAAK,CAACC,OAAO,IAAID,KAAK,CAAC;MACpD,MAAMjK,IAAI,GAAG,yBAAyB,GAAGkJ,SAAS,CAACE,MAAM;MACzD,KAAK,IAAIlL,EAAE,IAAImL,iBAAiB,EAAE;QAChCA,iBAAiB,CAACnL,EAAE,CAAC,CAAC8B,IAAI,EAAE,IAAI,CAAC;MACnC;MACAqJ,iBAAiB,GAAG,CAAC,CAAC;IACxB,CAAC;IACD,IAAIc,WAAW,GAAG,CAACC,IAAI,EAAEjP,KAAK,EAAEkP,QAAQ,KAAK;MAC3C,IAAInB,SAAS,CAACC,QAAQ,EACpB,OAAOkB,QAAQ,CAAC,kCAAkC,GAAGnB,SAAS,CAACE,MAAM,EAAE,IAAI,CAAC;MAC9E,IAAIlL,EAAE,GAAGoL,aAAa,EAAE;MACxBD,iBAAiB,CAACnL,EAAE,CAAC,GAAG,CAAC+L,KAAK,EAAEK,QAAQ,KAAK;QAC3C,IAAI;UACFD,QAAQ,CAACJ,KAAK,EAAEK,QAAQ,CAAC;QAC3B,CAAC,SAAS;UACR,IAAIF,IAAI,EACNA,IAAI,CAACG,KAAK,EAAE;QAChB;MACF,CAAC;MACD,IAAIH,IAAI,EACNA,IAAI,CAACI,GAAG,EAAE;MACZxB,QAAQ,CAACyB,YAAY,CAACrN,YAAY,CAAC;QAAEc,EAAE;QAAEC,SAAS,EAAE,IAAI;QAAEhD;MAAM,CAAC,CAAC,CAAC;IACrE,CAAC;IACD,IAAIuP,YAAY,GAAG,CAACxM,EAAE,EAAE/C,KAAK,KAAK;MAChC,IAAI+N,SAAS,CAACC,QAAQ,EACpB,MAAM,IAAIjK,KAAK,CAAC,kCAAkC,GAAGgK,SAAS,CAACE,MAAM,CAAC;MACxEJ,QAAQ,CAACyB,YAAY,CAACrN,YAAY,CAAC;QAAEc,EAAE;QAAEC,SAAS,EAAE,KAAK;QAAEhD;MAAM,CAAC,CAAC,CAAC;IACtE,CAAC;IACD,IAAIwP,aAAa,GAAG,CAACzM,EAAE,EAAE0M,OAAO,KAAKxP,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,aAAa;MACpE,IAAI;QACF,IAAIwP,OAAO,CAACC,OAAO,KAAK,MAAM,EAAE;UAC9BH,YAAY,CAACxM,EAAE,EAAE,CAAC,CAAC,CAAC;UACpB;QACF;QACA,IAAI,OAAO0M,OAAO,CAAC7P,GAAG,KAAK,QAAQ,EAAE;UACnC,MAAM+P,gBAAgB,GAAG7B,qBAAqB,CAAC2B,OAAO,CAAC7P,GAAG,CAAC;UAC3D,IAAI+P,gBAAgB,EAAE;YACpB,MAAMT,QAAQ,GAAGS,gBAAgB,CAACF,OAAO,CAACC,OAAO,CAAC;YAClD,IAAIR,QAAQ,EAAE;cACZ,MAAMA,QAAQ,CAACnM,EAAE,EAAE0M,OAAO,CAAC;cAC3B;YACF;UACF;QACF;QACA,MAAM,IAAI1L,KAAK,CAAE,mBAAkB,GAAG0L,OAAO,CAACC,OAAO,CAAC;MACxD,CAAC,CAAC,OAAO/O,CAAC,EAAE;QACV4O,YAAY,CAACxM,EAAE,EAAE;UAAE6M,MAAM,EAAE,CAACC,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC;QAAE,CAAC,CAAC;MACtF;IACF,CAAC,CAAC;IACF,IAAIiC,aAAa,GAAG,IAAI;IACxB,IAAInB,oBAAoB,GAAIrL,KAAK,IAAK;MACpC,IAAIwM,aAAa,EAAE;QACjBA,aAAa,GAAG,KAAK;QACrB,IAAIC,aAAa,GAAGC,MAAM,CAACC,YAAY,CAAC,GAAG3M,KAAK,CAAC;QACjD,IAAIyM,aAAa,KAAK,SAAS,EAAE;UAC/B,MAAM,IAAIhM,KAAK,CAAE,uCAAsC,SAAU,mCAAkC6D,IAAI,CAACC,SAAS,CAACkI,aAAa,CAAE,EAAC,CAAC;QACrI;QACA;MACF;MACA,IAAI7N,MAAM,GAAGmB,YAAY,CAACC,KAAK,CAAC;MAChC,IAAIpB,MAAM,CAACc,SAAS,EAAE;QACpBwM,aAAa,CAACtN,MAAM,CAACa,EAAE,EAAEb,MAAM,CAAClC,KAAK,CAAC;MACxC,CAAC,MAAM;QACL,IAAIkP,QAAQ,GAAGhB,iBAAiB,CAAChM,MAAM,CAACa,EAAE,CAAC;QAC3C,OAAOmL,iBAAiB,CAAChM,MAAM,CAACa,EAAE,CAAC;QACnC,IAAIb,MAAM,CAAClC,KAAK,CAAC8O,KAAK,EACpBI,QAAQ,CAAChN,MAAM,CAAClC,KAAK,CAAC8O,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,KAEjCI,QAAQ,CAAC,IAAI,EAAEhN,MAAM,CAAClC,KAAK,CAAC;MAChC;IACF,CAAC;IACD,IAAIkQ,YAAY,GAAG,CAAC;MAAE1F,QAAQ;MAAEyE,IAAI;MAAEkB,YAAY;MAAE/I,OAAO;MAAEY,KAAK;MAAEoI,SAAS;MAAElB;IAAS,CAAC,KAAK;MAC5F,IAAImB,QAAQ,GAAG,CAAC;MAChB,MAAMC,QAAQ,GAAGlC,YAAY,EAAE;MAC/B,MAAMuB,gBAAgB,GAAG,CAAC,CAAC;MAC3B,MAAMY,SAAS,GAAG;QAChBlB,GAAG,GAAG;UACJ,IAAI,EAAEgB,QAAQ,KAAK,CAAC,EAAE;YACpB,IAAIpB,IAAI,EACNA,IAAI,CAACI,GAAG,EAAE;UACd;QACF,CAAC;QACDD,KAAK,GAAG;UACN,IAAI,EAAEiB,QAAQ,KAAK,CAAC,EAAE;YACpB,OAAOvC,qBAAqB,CAACwC,QAAQ,CAAC;YACtC,IAAIrB,IAAI,EACNA,IAAI,CAACG,KAAK,EAAE;UAChB;QACF;MACF,CAAC;MACDtB,qBAAqB,CAACwC,QAAQ,CAAC,GAAGX,gBAAgB;MAClDY,SAAS,CAAClB,GAAG,EAAE;MACfmB,gBAAgB,CACdhG,QAAQ,EACR8F,QAAQ,EACRtB,WAAW,EACXO,YAAY,EACZgB,SAAS,EACT1C,QAAQ,EACR8B,gBAAgB,EAChBvI,OAAO,EACP+I,YAAY,EACZnI,KAAK,EACLoI,SAAS,EACTrC,SAAS,EACT,CAAC0C,GAAG,EAAEC,GAAG,KAAK;QACZ,IAAI;UACFxB,QAAQ,CAACuB,GAAG,EAAEC,GAAG,CAAC;QACpB,CAAC,SAAS;UACRH,SAAS,CAACnB,KAAK,EAAE;QACnB;MACF,CAAC,CACF;IACH,CAAC;IACD,IAAIuB,UAAU,GAAG,CAAC;MAAEnG,QAAQ;MAAEyE,IAAI;MAAE2B,KAAK;MAAExJ,OAAO;MAAEY,KAAK;MAAE6I,EAAE;MAAE3B;IAAS,CAAC,KAAK;MAC5E,MAAM4B,OAAO,GAAGC,iBAAiB,EAAE;MACnC,IAAIC,KAAK,GAAIC,SAAS,IAAK;QACzB,IAAI;UACF,IAAI,OAAOL,KAAK,KAAK,QAAQ,IAAI,EAAEA,KAAK,YAAYnO,UAAU,CAAC,EAC7D,MAAM,IAAIsB,KAAK,CAAC,2DAA2D,CAAC;UAC9E,IAAI;YACFgE,KAAK;YACLL;UACF,CAAC,GAAGgG,wBAAwB,CAAClD,QAAQ,EAAEpD,OAAO,EAAEY,KAAK,EAAE1C,wBAAwB,CAAC;UAChF,IAAImK,OAAO,GAAG;YACZC,OAAO,EAAE,WAAW;YACpB3H,KAAK;YACLmJ,OAAO,EAAED,SAAS,KAAK,IAAI;YAC3BL,KAAK,EAAEK,SAAS,KAAK,IAAI,GAAGzO,UAAU,CAACyO,SAAS,CAAC,GAAG,OAAOL,KAAK,KAAK,QAAQ,GAAGpO,UAAU,CAACoO,KAAK,CAAC,GAAGA;UACtG,CAAC;UACD,IAAIlJ,WAAW,EACb+H,OAAO,CAAC/H,WAAW,GAAGA,WAAW;UACnCsH,WAAW,CAACC,IAAI,EAAEQ,OAAO,EAAE,CAACX,KAAK,EAAEK,QAAQ,KAAK;YAC9C,IAAIL,KAAK,EACP,OAAOI,QAAQ,CAAC,IAAInL,KAAK,CAAC+K,KAAK,CAAC,EAAE,IAAI,CAAC;YACzC,IAAIc,MAAM,GAAGuB,wBAAwB,CAAChC,QAAQ,CAACS,MAAM,EAAEkB,OAAO,CAAC;YAC/D,IAAIM,QAAQ,GAAGD,wBAAwB,CAAChC,QAAQ,CAACiC,QAAQ,EAAEN,OAAO,CAAC;YACnE,IAAIO,WAAW,GAAG,CAAC;YACnB,IAAI3Q,IAAI,GAAG,MAAM;cACf,IAAI,EAAE2Q,WAAW,KAAK,CAAC,EAAE;gBACvB,IAAIC,MAAM,GAAG;kBAAEF,QAAQ;kBAAEG,IAAI,EAAEpC,QAAQ,CAACoC,IAAI;kBAAErH,GAAG,EAAEiF,QAAQ,CAACjF;gBAAI,CAAC;gBACjE,IAAIiF,QAAQ,CAACzH,WAAW,EACtB4J,MAAM,CAAC5J,WAAW,GAAGyH,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACzH,WAAW;gBACvEwH,QAAQ,CAAC,IAAI,EAAEoC,MAAM,CAAC;cACxB;YACF,CAAC;YACD,IAAI1B,MAAM,CAACjN,MAAM,GAAG,CAAC,EACnB,OAAOuM,QAAQ,CAACsC,mBAAmB,CAAC,kBAAkB,EAAE5B,MAAM,EAAEwB,QAAQ,CAAC,EAAE,IAAI,CAAC;YAClF,IAAIjC,QAAQ,CAACsC,MAAM,EAAE;cACnBJ,WAAW,EAAE;cACbR,EAAE,CAACa,QAAQ,CAACvC,QAAQ,CAACoC,IAAI,EAAE,CAACd,GAAG,EAAEpD,QAAQ,KAAK;gBAC5C,IAAIoD,GAAG,KAAK,IAAI,EAAE;kBAChBvB,QAAQ,CAACuB,GAAG,EAAE,IAAI,CAAC;gBACrB,CAAC,MAAM;kBACLtB,QAAQ,CAACoC,IAAI,GAAGlE,QAAQ;kBACxB3M,IAAI,EAAE;gBACR;cACF,CAAC,CAAC;YACJ;YACA,IAAIyO,QAAQ,CAACwC,KAAK,EAAE;cAClBN,WAAW,EAAE;cACbR,EAAE,CAACa,QAAQ,CAACvC,QAAQ,CAACjF,GAAG,EAAE,CAACuG,GAAG,EAAEpD,QAAQ,KAAK;gBAC3C,IAAIoD,GAAG,KAAK,IAAI,EAAE;kBAChBvB,QAAQ,CAACuB,GAAG,EAAE,IAAI,CAAC;gBACrB,CAAC,MAAM;kBACLtB,QAAQ,CAACjF,GAAG,GAAGmD,QAAQ;kBACvB3M,IAAI,EAAE;gBACR;cACF,CAAC,CAAC;YACJ;YACAA,IAAI,EAAE;UACR,CAAC,CAAC;QACJ,CAAC,CAAC,OAAOC,CAAC,EAAE;UACV,IAAIoH,KAAK,GAAG,EAAE;UACd,IAAI;YACFD,YAAY,CAACC,KAAK,EAAEX,OAAO,EAAE,CAAC,CAAC,EAAEY,KAAK,EAAE1C,wBAAwB,CAAC;UACnE,CAAC,CAAC,OAAOsM,EAAE,EAAE,CACb;UACA,MAAM9C,KAAK,GAAGe,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAEiD,OAAO,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC;UACrE9B,WAAW,CAACC,IAAI,EAAE;YAAES,OAAO,EAAE,OAAO;YAAE3H,KAAK;YAAE+G;UAAM,CAAC,EAAE,MAAM;YAC1DA,KAAK,CAAC+C,MAAM,GAAGf,OAAO,CAACgB,IAAI,CAAChD,KAAK,CAAC+C,MAAM,CAAC;YACzC3C,QAAQ,CAACsC,mBAAmB,CAAC,kBAAkB,EAAE,CAAC1C,KAAK,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC;UACtE,CAAC,CAAC;QACJ;MACF,CAAC;MACD,IAAI,CAAC,OAAO8B,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAYnO,UAAU,KAAKmO,KAAK,CAACjO,MAAM,GAAG,IAAI,GAAG,IAAI,EAAE;QAC5F,IAAIjC,IAAI,GAAGsQ,KAAK;QAChBA,KAAK,GAAG,MAAMH,EAAE,CAACkB,SAAS,CAACnB,KAAK,EAAElQ,IAAI,CAAC;MACzC;MACAsQ,KAAK,CAAC,IAAI,CAAC;IACb,CAAC;IACD,IAAIgB,eAAe,GAAG,CAAC;MAAExH,QAAQ;MAAEyE,IAAI;MAAEgD,QAAQ;MAAE7K,OAAO;MAAE8H;IAAS,CAAC,KAAK;MACzE,IAAIoC,MAAM,GAAGY,gBAAgB,CAACD,QAAQ,EAAE,UAAU,EAAE,IAAI,EAAE,EAAE,CAAC;MAC7D,IAAI,CAAC7K,OAAO,EACV,MAAM,IAAIrD,KAAK,CAAE,8BAA6ByG,QAAS,SAAQ,CAAC;MAClE,IAAI3H,IAAI,GAAG,CAAC,CAAC;MACb,IAAIsP,IAAI,GAAGtL,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,MAAM,EAAEgD,YAAY,CAAC;MACvD,IAAIqC,KAAK,GAAGrB,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,OAAO,EAAE6C,aAAa,CAAC;MAC1D,IAAI0M,aAAa,GAAGvL,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,eAAe,EAAEmD,aAAa,CAAC;MAC1EiB,oBAAoB,CAACG,OAAO,EAAEvE,IAAI,EAAG,MAAK2H,QAAS,SAAQ,CAAC;MAC5D,IAAI2H,IAAI,KAAK,KAAK,CAAC,EACjB,MAAM,IAAIpO,KAAK,CAAE,qBAAoByG,QAAS,SAAQ,CAAC;MACzD,IAAI2H,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,SAAS,EACxC,MAAM,IAAIpO,KAAK,CAAE,iDAAgDyG,QAAS,SAAQ,CAAC;MACrF,IAAIiF,OAAO,GAAG;QACZC,OAAO,EAAE,aAAa;QACtBuC,QAAQ,EAAEX,MAAM;QAChBe,SAAS,EAAEF,IAAI,KAAK;MACtB,CAAC;MACD,IAAIjK,KAAK,KAAK,KAAK,CAAC,EAClBuH,OAAO,CAACvH,KAAK,GAAGA,KAAK;MACvB,IAAIkK,aAAa,KAAK,KAAK,CAAC,EAC1B3C,OAAO,CAAC2C,aAAa,GAAGA,aAAa;MACvCpD,WAAW,CAACC,IAAI,EAAEQ,OAAO,EAAE,CAACX,KAAK,EAAEK,QAAQ,KAAK;QAC9C,IAAIL,KAAK,EACP,OAAOI,QAAQ,CAAC,IAAInL,KAAK,CAAC+K,KAAK,CAAC,EAAE,IAAI,CAAC;QACzCI,QAAQ,CAAC,IAAI,EAAEC,QAAQ,CAAC8C,QAAQ,CAAC;MACnC,CAAC,CAAC;IACJ,CAAC;IACD,IAAIK,gBAAgB,GAAG,CAAC;MAAE9H,QAAQ;MAAEyE,IAAI;MAAE7D,QAAQ;MAAEhE,OAAO;MAAE8H;IAAS,CAAC,KAAK;MAC1E,IAAI9H,OAAO,KAAK,KAAK,CAAC,EACpBA,OAAO,GAAG,CAAC,CAAC;MACd,IAAIvE,IAAI,GAAG,CAAC,CAAC;MACb,IAAIqF,KAAK,GAAGrB,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,OAAO,EAAE6C,aAAa,CAAC;MAC1D,IAAI6M,OAAO,GAAG1L,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,SAAS,EAAE6C,aAAa,CAAC;MAC9DuB,oBAAoB,CAACG,OAAO,EAAEvE,IAAI,EAAG,MAAK2H,QAAS,SAAQ,CAAC;MAC5D,IAAIiF,OAAO,GAAG;QACZC,OAAO,EAAE,kBAAkB;QAC3BtE;MACF,CAAC;MACD,IAAIlD,KAAK,KAAK,KAAK,CAAC,EAClBuH,OAAO,CAACvH,KAAK,GAAGA,KAAK;MACvB,IAAIqK,OAAO,KAAK,KAAK,CAAC,EACpB9C,OAAO,CAAC8C,OAAO,GAAGA,OAAO;MAC3BvD,WAAW,CAACC,IAAI,EAAEQ,OAAO,EAAE,CAACX,KAAK,EAAEK,QAAQ,KAAK;QAC9C,IAAIL,KAAK,EACP,OAAOI,QAAQ,CAAC,IAAInL,KAAK,CAAC+K,KAAK,CAAC,EAAE,IAAI,CAAC;QACzCI,QAAQ,CAAC,IAAI,EAAEC,QAAQ,CAACmC,MAAM,CAAC;MACjC,CAAC,CAAC;IACJ,CAAC;IACD,OAAO;MACL/C,cAAc;MACdM,UAAU;MACV2D,OAAO,EAAE;QACPtC,YAAY;QACZrO,SAAS,EAAE8O,UAAU;QACrBlP,cAAc,EAAEuQ,eAAe;QAC/B7Q,eAAe,EAAEmR;MACnB;IACF,CAAC;EACH;EACA,SAAS9B,gBAAgB,CAAChG,QAAQ,EAAE8F,QAAQ,EAAEtB,WAAW,EAAEO,YAAY,EAAEN,IAAI,EAAEpB,QAAQ,EAAE8B,gBAAgB,EAAEvI,OAAO,EAAE+I,YAAY,EAAEnI,KAAK,EAAEoI,SAAS,EAAErC,SAAS,EAAEmB,QAAQ,EAAE;IACvK,MAAM4B,OAAO,GAAGC,iBAAiB,EAAE;IACnC,MAAM0B,cAAc,GAAG,CAAC9R,CAAC,EAAE+R,UAAU,EAAEC,IAAI,EAAE5R,IAAI,KAAK;MACpD,MAAMgH,KAAK,GAAG,EAAE;MAChB,IAAI;QACFD,YAAY,CAACC,KAAK,EAAEX,OAAO,EAAE,CAAC,CAAC,EAAEY,KAAK,EAAE3C,oBAAoB,CAAC;MAC/D,CAAC,CAAC,OAAOuM,EAAE,EAAE,CACb;MACA,MAAM7C,OAAO,GAAGc,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAEiD,OAAO,EAAE6B,IAAI,EAAED,UAAU,CAAC;MAC7E1D,WAAW,CAACC,IAAI,EAAE;QAAES,OAAO,EAAE,OAAO;QAAE3H,KAAK;QAAE+G,KAAK,EAAEC;MAAQ,CAAC,EAAE,MAAM;QACnEA,OAAO,CAAC8C,MAAM,GAAGf,OAAO,CAACgB,IAAI,CAAC/C,OAAO,CAAC8C,MAAM,CAAC;QAC7C9Q,IAAI,CAACgO,OAAO,CAAC;MACf,CAAC,CAAC;IACJ,CAAC;IACD,MAAM6D,WAAW,GAAG,CAACjS,CAAC,EAAE+R,UAAU,KAAK;MACrCD,cAAc,CAAC9R,CAAC,EAAE+R,UAAU,EAAE,KAAK,CAAC,EAAG5D,KAAK,IAAK;QAC/CI,QAAQ,CAACsC,mBAAmB,CAAC,cAAc,EAAE,CAAC1C,KAAK,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC;MAClE,CAAC,CAAC;IACJ,CAAC;IACD,IAAIlC,OAAO;IACX,IAAI,OAAOxF,OAAO,KAAK,QAAQ,EAAE;MAC/B,MAAMpH,KAAK,GAAGoH,OAAO,CAACwF,OAAO;MAC7B,IAAI5M,KAAK,KAAK,KAAK,CAAC,EAAE;QACpB,IAAI,CAAC0C,KAAK,CAACkD,OAAO,CAAC5F,KAAK,CAAC,EACvB,MAAM,IAAI+D,KAAK,CAAE,4BAA2B,CAAC;QAC/C6I,OAAO,GAAG5M,KAAK;MACjB;IACF;IACA,IAAI4M,OAAO,IAAIA,OAAO,CAACjK,MAAM,GAAG,CAAC,EAAE;MACjC,IAAIkL,QAAQ,CAACgF,MAAM,EAAE;QACnBD,WAAW,CAAC,IAAI7O,KAAK,CAAC,6CAA6C,CAAC,EAAE,EAAE,CAAC;QACzE;MACF;MACA+O,aAAa,CACXxC,QAAQ,EACRtB,WAAW,EACXO,YAAY,EACZN,IAAI,EACJpB,QAAQ,EACR8B,gBAAgB,EAChBvI,OAAO,EACPwF,OAAO,EACPkE,OAAO,CACR,CAAC9P,IAAI,CACHsQ,MAAM,IAAK;QACV,IAAI,CAACA,MAAM,CAACyB,EAAE,EAAE;UACdH,WAAW,CAACtB,MAAM,CAACxC,KAAK,EAAEwC,MAAM,CAACoB,UAAU,CAAC;UAC5C;QACF;QACA,IAAI;UACFM,oBAAoB,CAAC1B,MAAM,CAAC2B,cAAc,EAAE3B,MAAM,CAAC4B,iBAAiB,CAAC;QACvE,CAAC,CAAC,OAAOvS,CAAC,EAAE;UACViS,WAAW,CAACjS,CAAC,EAAE,EAAE,CAAC;QACpB;MACF,CAAC,EACAA,CAAC,IAAKiS,WAAW,CAACjS,CAAC,EAAE,EAAE,CAAC,CAC1B;MACD;IACF;IACA,IAAI;MACFqS,oBAAoB,CAAC,IAAI,EAAE,CAAC1B,MAAM,EAAE6B,eAAe,EAAEpS,IAAI,KAAKA,IAAI,EAAE,CAAC;IACvE,CAAC,CAAC,OAAOJ,CAAC,EAAE;MACViS,WAAW,CAACjS,CAAC,EAAE,EAAE,CAAC;IACpB;IACA,SAASqS,oBAAoB,CAACC,cAAc,EAAEC,iBAAiB,EAAE;MAC/D,IAAIzI,YAAY,GAAG,CAACoD,QAAQ,CAACuF,kBAAkB;MAC/C,IAAI;QACFzI,OAAO;QACP5C,KAAK;QACLxF,KAAK;QACLqI,aAAa;QACbC,eAAe;QACf2B,aAAa;QACbG,WAAW;QACXc,SAAS;QACTxC,KAAK;QACLvD;MACF,CAAC,GAAG6C,oBAAoB,CAACC,QAAQ,EAAEpD,OAAO,EAAEY,KAAK,EAAE3C,oBAAoB,EAAEoF,YAAY,CAAC;MACtF,IAAIgF,OAAO,GAAG;QACZC,OAAO,EAAE,OAAO;QAChB9P,GAAG,EAAE0Q,QAAQ;QACb3F,OAAO;QACP5C,KAAK;QACLxF,KAAK;QACLqI,aAAa;QACbC,eAAe;QACf2B,aAAa,EAAEA,aAAa,IAAI4D,SAAS;QACzCzD,WAAW;QACXc;MACF,CAAC;MACD,IAAIwF,cAAc,EAChBxD,OAAO,CAAC7C,OAAO,GAAGqG,cAAc;MAClC,IAAIvL,WAAW,EACb+H,OAAO,CAAC/H,WAAW,GAAGA,WAAW;MACnC,IAAI2L,MAAM,GAAGlD,YAAY,IAAImD,cAAc,CAAChD,QAAQ,EAAEtB,WAAW,EAAEO,YAAY,EAAEN,IAAI,EAAEU,gBAAgB,EAAEQ,YAAY,EAAEV,OAAO,CAAC;MAC/H,IAAI8D,OAAO;MACX,IAAIC,IAAI;MACR,IAAIC,oBAAoB,GAAG,CAACtE,QAAQ,EAAEmC,MAAM,KAAK;QAC/C,IAAInC,QAAQ,CAACuE,WAAW,EACtBpC,MAAM,CAACoC,WAAW,GAAGvE,QAAQ,CAACuE,WAAW,CAACxJ,GAAG,CAACyJ,kBAAkB,CAAC;QACnE,IAAIxE,QAAQ,CAAC/D,QAAQ,EACnBkG,MAAM,CAAClG,QAAQ,GAAGxD,IAAI,CAACgM,KAAK,CAACzE,QAAQ,CAAC/D,QAAQ,CAAC;QACjD,IAAI+D,QAAQ,CAACzH,WAAW,EACtB4J,MAAM,CAAC5J,WAAW,GAAGyH,QAAQ,CAACzH,WAAW;QAC3C,IAAIyH,QAAQ,CAAC0E,aAAa,KAAK,KAAK,CAAC,EACnCC,OAAO,CAACC,GAAG,CAACtQ,UAAU,CAAC0L,QAAQ,CAAC0E,aAAa,CAAC,CAACG,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;MACtE,CAAC;MACD,IAAIC,qBAAqB,GAAG,CAAC9E,QAAQ,EAAE+E,SAAS,KAAK;QACnD,IAAI5C,MAAM,GAAG;UACX1B,MAAM,EAAEuB,wBAAwB,CAAChC,QAAQ,CAACS,MAAM,EAAEkB,OAAO,CAAC;UAC1DM,QAAQ,EAAED,wBAAwB,CAAChC,QAAQ,CAACiC,QAAQ,EAAEN,OAAO;QAC/D,CAAC;QACD2C,oBAAoB,CAACtE,QAAQ,EAAEmC,MAAM,CAAC;QACtC4B,iBAAiB,CAAC5B,MAAM,EAAEmB,cAAc,EAAE,MAAM;UAC9C,IAAInB,MAAM,CAAC1B,MAAM,CAACjN,MAAM,GAAG,CAAC,EAAE;YAC5B,OAAOuR,SAAS,CAAC1C,mBAAmB,CAAC,cAAc,EAAEF,MAAM,CAAC1B,MAAM,EAAE0B,MAAM,CAACF,QAAQ,CAAC,EAAE,IAAI,CAAC;UAC7F;UACA,IAAIjC,QAAQ,CAACoE,OAAO,EAAE;YACpB,IAAI,CAACA,OAAO,EAAE;cACZ,IAAIY,UAAU,GAAG,KAAK;cACtBZ,OAAO,GAAG,MAAM,IAAIlT,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;gBAC/C,IAAI4T,UAAU,IAAIpG,SAAS,CAACC,QAAQ,EAClC,MAAM,IAAIjK,KAAK,CAAC,gBAAgB,CAAC;gBACnCiL,WAAW,CACTC,IAAI,EACJ;kBAAES,OAAO,EAAE,SAAS;kBAAE9P,GAAG,EAAE0Q;gBAAS,CAAC,EACrC,CAAC8D,MAAM,EAAEC,SAAS,KAAK;kBACrB,IAAID,MAAM,EAAE;oBACV,MAAMrF,OAAO,GAAG;sBAAEhM,EAAE,EAAE,EAAE;sBAAE2P,UAAU,EAAE,EAAE;sBAAE7N,IAAI,EAAEuP,MAAM;sBAAEE,QAAQ,EAAE,IAAI;sBAAEC,KAAK,EAAE,EAAE;sBAAE1C,MAAM,EAAE,KAAK;oBAAE,CAAC;oBACnG,OAAOqC,SAAS,CAAC1C,mBAAmB,CAAC,cAAc,EAAE,CAACzC,OAAO,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC;kBAC5E;kBACAkF,qBAAqB,CAACI,SAAS,EAAE,CAACG,MAAM,EAAEC,OAAO,KAAK;oBACpD,IAAID,MAAM,EACRjU,MAAM,CAACiU,MAAM,CAAC,CAAC,KAEflU,OAAO,CAACmU,OAAO,CAAC;kBACpB,CAAC,CAAC;gBACJ,CAAC,CACF;cACH,CAAC,CAAC;cACFxF,IAAI,CAACI,GAAG,EAAE;cACVkE,OAAO,CAACmB,OAAO,GAAG,MAAM;gBACtB,IAAIP,UAAU,EACZ;gBACFA,UAAU,GAAG,IAAI;gBACjBnF,WAAW,CAACC,IAAI,EAAE;kBAAES,OAAO,EAAE,iBAAiB;kBAAE9P,GAAG,EAAE0Q;gBAAS,CAAC,EAAE,MAAM,CACvE,CAAC,CAAC;gBACFrB,IAAI,CAACG,KAAK,EAAE;cACd,CAAC;YACH;YACAkC,MAAM,CAACiC,OAAO,GAAGA,OAAO;UAC1B;UACA,IAAIpE,QAAQ,CAAClE,KAAK,EAAE;YAClB,IAAI,CAACuI,IAAI,EAAE;cACT,IAAImB,SAAS,GAAG,KAAK;cACrB1F,IAAI,CAACI,GAAG,EAAE;cACVmE,IAAI,GAAG,MAAM;gBACX,IAAImB,SAAS,EACX;gBACFA,SAAS,GAAG,IAAI;gBAChB,OAAOhF,gBAAgB,CAAC,eAAe,CAAC;gBACxCX,WAAW,CAACC,IAAI,EAAE;kBAAES,OAAO,EAAE,YAAY;kBAAE9P,GAAG,EAAE0Q;gBAAS,CAAC,EAAE,MAAM,CAClE,CAAC,CAAC;gBACFrB,IAAI,CAACG,KAAK,EAAE;cACd,CAAC;cACD,IAAInE,KAAK,EAAE;gBACT0E,gBAAgB,CAAC,eAAe,CAAC,GAAG,CAAC5M,EAAE,EAAE6R,QAAQ,KAAK;kBACpD,IAAI;oBACF,IAAIC,aAAa,GAAGD,QAAQ,CAACE,IAAI;oBACjC,IAAIC,OAAO,GAAG;sBACZnF,MAAM,EAAEuB,wBAAwB,CAAC0D,aAAa,CAACjF,MAAM,EAAEkB,OAAO,CAAC;sBAC/DM,QAAQ,EAAED,wBAAwB,CAAC0D,aAAa,CAACzD,QAAQ,EAAEN,OAAO;oBACpE,CAAC;oBACD2C,oBAAoB,CAACoB,aAAa,EAAEE,OAAO,CAAC;oBAC5C7B,iBAAiB,CAAC6B,OAAO,EAAEtC,cAAc,EAAE,MAAM;sBAC/C,IAAIsC,OAAO,CAACnF,MAAM,CAACjN,MAAM,GAAG,CAAC,EAAE;wBAC7B,IAAIsI,KAAK,CAAC6B,SAAS,EACjB7B,KAAK,CAAC6B,SAAS,CAAC0E,mBAAmB,CAAC,cAAc,EAAEuD,OAAO,CAACnF,MAAM,EAAEmF,OAAO,CAAC3D,QAAQ,CAAC,EAAE,IAAI,CAAC;wBAC9F;sBACF;sBACA2D,OAAO,CAACvB,IAAI,GAAGA,IAAI;sBACnB,IAAIvI,KAAK,CAAC6B,SAAS,EACjB7B,KAAK,CAAC6B,SAAS,CAAC,IAAI,EAAEiI,OAAO,CAAC;oBAClC,CAAC,CAAC;kBACJ,CAAC,CAAC,OAAOtE,GAAG,EAAE;oBACZqD,OAAO,CAAChF,KAAK,CAAC2B,GAAG,CAAC;kBACpB;kBACAlB,YAAY,CAACxM,EAAE,EAAE,CAAC,CAAC,CAAC;gBACtB,CAAC;cACH;YACF;YACAuO,MAAM,CAACkC,IAAI,GAAGA,IAAI;UACpB;UACAU,SAAS,CAAC,IAAI,EAAE5C,MAAM,CAAC;QACzB,CAAC,CAAC;MACJ,CAAC;MACD,IAAI/O,KAAK,IAAIsL,QAAQ,CAACuF,kBAAkB,EACtC,MAAM,IAAIrP,KAAK,CAAE,uDAAsD,CAAC;MAC1E,IAAI4I,WAAW,IAAIkB,QAAQ,CAACgF,MAAM,EAChC,MAAM,IAAI9O,KAAK,CAAE,mDAAkD,CAAC;MACtE,IAAIkH,KAAK,IAAI4C,QAAQ,CAACgF,MAAM,EAC1B,MAAM,IAAI9O,KAAK,CAAE,6CAA4C,CAAC;MAChEiL,WAAW,CAACC,IAAI,EAAEQ,OAAO,EAAE,CAACX,KAAK,EAAEK,QAAQ,KAAK;QAC9C,IAAIL,KAAK,EACP,OAAOI,QAAQ,CAAC,IAAInL,KAAK,CAAC+K,KAAK,CAAC,EAAE,IAAI,CAAC;QACzC,IAAIuE,MAAM,EAAE;UACV,IAAI2B,aAAa,GAAG7F,QAAQ;UAC5B,IAAIwF,SAAS,GAAG,KAAK;UACrB1F,IAAI,CAACI,GAAG,EAAE;UACV,IAAIiC,MAAM,GAAG;YACX2D,IAAI,EAAED,aAAa,CAACC,IAAI;YACxBC,IAAI,EAAEF,aAAa,CAACE,IAAI;YACxBC,IAAI,EAAE9B,MAAM,CAAC8B,IAAI;YACjB3B,IAAI,GAAG;cACL,IAAImB,SAAS,EACX;cACFA,SAAS,GAAG,IAAI;cAChBtB,MAAM,CAACG,IAAI,EAAE;cACbvE,IAAI,CAACG,KAAK,EAAE;YACd;UACF,CAAC;UACDH,IAAI,CAACI,GAAG,EAAE;UACVgE,MAAM,CAAC8B,IAAI,CAACnU,IAAI,CAACiO,IAAI,CAACG,KAAK,EAAEH,IAAI,CAACG,KAAK,CAAC;UACxC,OAAOF,QAAQ,CAAC,IAAI,EAAEoC,MAAM,CAAC;QAC/B;QACA,OAAO2C,qBAAqB,CAAC9E,QAAQ,EAAED,QAAQ,CAAC;MAClD,CAAC,CAAC;IACJ;EACF;EACA,IAAIoE,cAAc,GAAG,CAAChD,QAAQ,EAAEtB,WAAW,EAAEO,YAAY,EAAEN,IAAI,EAAEU,gBAAgB,EAAEvI,OAAO,EAAEqI,OAAO,KAAK;IACtG,IAAI5M,IAAI,GAAG,CAAC,CAAC;IACb,IAAIoS,IAAI,GAAGpO,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,MAAM,EAAEmD,aAAa,CAAC;IACxD,IAAIkP,IAAI,GAAGrO,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,MAAM,EAAEgD,YAAY,CAAC;IACvD,IAAIuP,QAAQ,GAAGvO,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,UAAU,EAAEgD,YAAY,CAAC;IAC/D,IAAIwP,SAAS,GAAGxO,OAAO,CAACO,OAAO,EAAEvE,IAAI,EAAE,WAAW,EAAEoD,cAAc,CAAC;IACnE,IAAIkP,IAAI,GAAG,IAAI9U,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MAC1CoP,gBAAgB,CAAC,YAAY,CAAC,GAAG,CAAC5M,EAAE,EAAE6R,QAAQ,KAAK;QACjD,IAAIA,QAAQ,CAAC9F,KAAK,KAAK,IAAI,EACzBvO,MAAM,CAAC,IAAIwD,KAAK,CAAC6Q,QAAQ,CAAC9F,KAAK,CAAC,CAAC,CAAC,KAElCxO,OAAO,EAAE;QACXiP,YAAY,CAACxM,EAAE,EAAE,CAAC,CAAC,CAAC;MACtB,CAAC;IACH,CAAC,CAAC;IACF0M,OAAO,CAAC7N,KAAK,GAAG,CAAC,CAAC;IAClBqF,oBAAoB,CAACG,OAAO,EAAEvE,IAAI,EAAG,iBAAgB,CAAC;IACtD,IAAIoS,IAAI,KAAK,KAAK,CAAC,EACjBxF,OAAO,CAAC7N,KAAK,CAACqT,IAAI,GAAGA,IAAI;IAC3B,IAAIC,IAAI,KAAK,KAAK,CAAC,EACjBzF,OAAO,CAAC7N,KAAK,CAACsT,IAAI,GAAGA,IAAI;IAC3B,IAAIE,QAAQ,KAAK,KAAK,CAAC,EACrB3F,OAAO,CAAC7N,KAAK,CAACwT,QAAQ,GAAGA,QAAQ;IACnCzF,gBAAgB,CAAC,eAAe,CAAC,GAAG,CAAC5M,EAAE,EAAE6R,QAAQ,KAAK;MACpD,IAAIS,SAAS,EACXA,SAAS,CAACT,QAAQ,CAACE,IAAI,CAAC;MAC1BvF,YAAY,CAACxM,EAAE,EAAE,CAAC,CAAC,CAAC;IACtB,CAAC;IACD,OAAO;MACLoS,IAAI;MACJ3B,IAAI,GAAG;QACLxE,WAAW,CAACC,IAAI,EAAE;UAAES,OAAO,EAAE,YAAY;UAAE9P,GAAG,EAAE0Q;QAAS,CAAC,EAAE,MAAM,CAClE,CAAC,CAAC;MACJ;IACF,CAAC;EACH,CAAC;EACD,IAAIwC,aAAa,GAAG,CAACxC,QAAQ,EAAEtB,WAAW,EAAEO,YAAY,EAAEN,IAAI,EAAEpB,QAAQ,EAAE8B,gBAAgB,EAAE2F,cAAc,EAAE1I,OAAO,EAAEkE,OAAO,KAAK7Q,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,aAAa;IAClK,IAAIsV,gBAAgB,GAAG,EAAE;IACzB,IAAIC,cAAc,GAAG,EAAE;IACvB,IAAIC,kBAAkB,GAAG,CAAC,CAAC;IAC3B,IAAIC,eAAe,GAAG,CAAC,CAAC;IACxB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAI9R,CAAC,GAAG,CAAC;IACT,IAAIoP,cAAc,GAAG,EAAE;IACvB,IAAI2C,WAAW,GAAG,KAAK;IACvBhJ,OAAO,GAAG,CAAC,GAAGA,OAAO,CAAC;IACtB,KAAK,IAAIhK,IAAI,IAAIgK,OAAO,EAAE;MACxB,IAAI/J,IAAI,GAAG,CAAC,CAAC;MACb,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAC1B,MAAM,IAAImB,KAAK,CAAE,mBAAkBF,CAAE,oBAAmB,CAAC;MAC3D,MAAMzE,IAAI,GAAGyH,OAAO,CAACjE,IAAI,EAAEC,IAAI,EAAE,MAAM,EAAEgD,YAAY,CAAC;MACtD,IAAI,OAAOzG,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,EAAE,EACzC,MAAM,IAAI2E,KAAK,CAAE,mBAAkBF,CAAE,oBAAmB,CAAC;MAC3D,IAAI;QACF,IAAIgS,KAAK,GAAGhP,OAAO,CAACjE,IAAI,EAAEC,IAAI,EAAE,OAAO,EAAEoD,cAAc,CAAC;QACxD,IAAI,OAAO4P,KAAK,KAAK,UAAU,EAC7B,MAAM,IAAI9R,KAAK,CAAE,oCAAmC,CAAC;QACvDkD,oBAAoB,CAACrE,IAAI,EAAEC,IAAI,EAAG,aAAY+E,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,EAAC,CAAC;QACrE,IAAI0W,MAAM,GAAG;UACX1W,IAAI;UACJ2W,SAAS,EAAE,EAAE;UACbC,MAAM,EAAE;QACV,CAAC;QACDnS,CAAC,EAAE;QACH,IAAIvD,OAAO,GAAG,CAAC2M,IAAI,EAAE7F,OAAO,GAAG,CAAC,CAAC,KAAK;UACpC,IAAI,CAACwO,WAAW,EACd,MAAM,IAAI7R,KAAK,CAAC,yDAAyD,CAAC;UAC5E,IAAI,OAAOkJ,IAAI,KAAK,QAAQ,EAC1B,MAAM,IAAIlJ,KAAK,CAAE,sCAAqC,CAAC;UACzD,IAAIkS,KAAK,GAAG,eAAgBzX,MAAM,CAAC6I,MAAM,CAAC,IAAI,CAAC;UAC/C,IAAIqL,UAAU,GAAG7L,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,YAAY,EAAEpQ,YAAY,CAAC;UACpE,IAAIqQ,QAAQ,GAAGrP,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,UAAU,EAAEpQ,YAAY,CAAC;UAChE,IAAIsQ,SAAS,GAAGtP,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,WAAW,EAAEpQ,YAAY,CAAC;UAClE,IAAIyH,UAAU,GAAGzG,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,YAAY,EAAEpQ,YAAY,CAAC;UACpE,IAAIsM,IAAI,GAAGtL,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,MAAM,EAAEpQ,YAAY,CAAC;UACxD,IAAIuQ,UAAU,GAAGvP,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,YAAY,EAAExQ,aAAa,CAAC;UACrEwB,oBAAoB,CAACG,OAAO,EAAE6O,KAAK,EAAE,mBAAmB,CAAC;UACzD,OAAO,IAAI5V,OAAO,CAAC,CAACgW,QAAQ,EAAE9V,MAAM,KAAK;YACvC,MAAMkP,OAAO,GAAG;cACdC,OAAO,EAAE,SAAS;cAClBzC,IAAI;cACJrN,GAAG,EAAE0Q,QAAQ;cACboC,UAAU,EAAEtT;YACd,CAAC;YACD,IAAIsT,UAAU,IAAI,IAAI,EACpBjD,OAAO,CAACiD,UAAU,GAAGA,UAAU;YACjC,IAAIwD,QAAQ,IAAI,IAAI,EAClBzG,OAAO,CAACyG,QAAQ,GAAGA,QAAQ;YAC7B,IAAIC,SAAS,IAAI,IAAI,EACnB1G,OAAO,CAAC0G,SAAS,GAAGA,SAAS;YAC/B,IAAI7I,UAAU,IAAI,IAAI,EACpBmC,OAAO,CAACnC,UAAU,GAAGA,UAAU;YACjC,IAAI6E,IAAI,IAAI,IAAI,EACd1C,OAAO,CAAC0C,IAAI,GAAGA,IAAI;YACrB,IAAIiE,UAAU,IAAI,IAAI,EACpB3G,OAAO,CAAC2G,UAAU,GAAGtF,OAAO,CAACwF,KAAK,CAACF,UAAU,CAAC;YAChDpH,WAAW,CAACC,IAAI,EAAEQ,OAAO,EAAE,CAACX,KAAK,EAAEK,QAAQ,KAAK;cAC9C,IAAIL,KAAK,KAAK,IAAI,EAChBvO,MAAM,CAAC,IAAIwD,KAAK,CAAC+K,KAAK,CAAC,CAAC,CAAC,KAEzBuH,QAAQ,CAAC;gBACPzG,MAAM,EAAEuB,wBAAwB,CAAChC,QAAQ,CAACS,MAAM,EAAEkB,OAAO,CAAC;gBAC1DM,QAAQ,EAAED,wBAAwB,CAAChC,QAAQ,CAACiC,QAAQ,EAAEN,OAAO,CAAC;gBAC9D7D,IAAI,EAAEkC,QAAQ,CAAClC,IAAI;gBACnBpB,QAAQ,EAAEsD,QAAQ,CAACtD,QAAQ;gBAC3B0K,WAAW,EAAEpH,QAAQ,CAACoH,WAAW;gBACjCJ,SAAS,EAAEhH,QAAQ,CAACgH,SAAS;gBAC7BK,MAAM,EAAErH,QAAQ,CAACqH,MAAM;gBACvBJ,UAAU,EAAEtF,OAAO,CAACgB,IAAI,CAAC3C,QAAQ,CAACiH,UAAU;cAC9C,CAAC,CAAC;YACN,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC;QACD,IAAIK,OAAO,GAAGZ,KAAK,CAAC;UAClBP,cAAc;UACdhV,OAAO;UACPoW,OAAO,CAACxH,QAAQ,EAAE;YAChB,IAAIyH,cAAc,GAAI,8DAA6D;YACnF,IAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI9S,KAAK,CAAC4S,cAAc,CAAC,EAAE9I,QAAQ,EAAE,SAAS,CAAC;YACpF0H,gBAAgB,CAACzR,IAAI,CAAC;cAAE1E,IAAI;cAAE8P,QAAQ;cAAEyD,IAAI,EAAEiE;YAAe,CAAC,CAAC;UACjE,CAAC;UACDE,KAAK,CAAC5H,QAAQ,EAAE;YACd,IAAIyH,cAAc,GAAI,4DAA2D;YACjF,IAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI9S,KAAK,CAAC4S,cAAc,CAAC,EAAE9I,QAAQ,EAAE,OAAO,CAAC;YAClF2H,cAAc,CAAC1R,IAAI,CAAC;cAAE1E,IAAI;cAAE8P,QAAQ;cAAEyD,IAAI,EAAEiE;YAAe,CAAC,CAAC;UAC/D,CAAC;UACDb,SAAS,CAAC3O,OAAO,EAAE8H,QAAQ,EAAE;YAC3B,IAAIyH,cAAc,GAAI,gEAA+D;YACrF,IAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI9S,KAAK,CAAC4S,cAAc,CAAC,EAAE9I,QAAQ,EAAE,WAAW,CAAC;YACtF,IAAIoI,KAAK,GAAG,CAAC,CAAC;YACd,IAAIc,MAAM,GAAGlQ,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,QAAQ,EAAEnQ,YAAY,CAAC;YAC5D,IAAIqQ,SAAS,GAAGtP,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,WAAW,EAAEpQ,YAAY,CAAC;YAClEoB,oBAAoB,CAACG,OAAO,EAAE6O,KAAK,EAAG,kCAAiCrO,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,EAAC,CAAC;YAC9F,IAAI2X,MAAM,IAAI,IAAI,EAChB,MAAM,IAAIhT,KAAK,CAAE,sCAAqC,CAAC;YACzD,IAAIhB,EAAE,GAAG4S,cAAc,EAAE;YACzBF,kBAAkB,CAAC1S,EAAE,CAAC,GAAG;cAAE3D,IAAI;cAAE8P,QAAQ;cAAEyD,IAAI,EAAEiE;YAAe,CAAC;YACjEd,MAAM,CAACC,SAAS,CAACjS,IAAI,CAAC;cAAEf,EAAE;cAAEgU,MAAM,EAAEA,MAAM,CAAC1M,MAAM;cAAE8L,SAAS,EAAEA,SAAS,IAAI;YAAG,CAAC,CAAC;UAClF,CAAC;UACDH,MAAM,CAAC5O,OAAO,EAAE8H,QAAQ,EAAE;YACxB,IAAIyH,cAAc,GAAI,6DAA4D;YAClF,IAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI9S,KAAK,CAAC4S,cAAc,CAAC,EAAE9I,QAAQ,EAAE,QAAQ,CAAC;YACnF,IAAIoI,KAAK,GAAG,CAAC,CAAC;YACd,IAAIc,MAAM,GAAGlQ,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,QAAQ,EAAEnQ,YAAY,CAAC;YAC5D,IAAIqQ,SAAS,GAAGtP,OAAO,CAACO,OAAO,EAAE6O,KAAK,EAAE,WAAW,EAAEpQ,YAAY,CAAC;YAClEoB,oBAAoB,CAACG,OAAO,EAAE6O,KAAK,EAAG,+BAA8BrO,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,EAAC,CAAC;YAC3F,IAAI2X,MAAM,IAAI,IAAI,EAChB,MAAM,IAAIhT,KAAK,CAAE,mCAAkC,CAAC;YACtD,IAAIhB,EAAE,GAAG4S,cAAc,EAAE;YACzBD,eAAe,CAAC3S,EAAE,CAAC,GAAG;cAAE3D,IAAI;cAAE8P,QAAQ;cAAEyD,IAAI,EAAEiE;YAAe,CAAC;YAC9Dd,MAAM,CAACE,MAAM,CAAClS,IAAI,CAAC;cAAEf,EAAE;cAAEgU,MAAM,EAAEA,MAAM,CAAC1M,MAAM;cAAE8L,SAAS,EAAEA,SAAS,IAAI;YAAG,CAAC,CAAC;UAC/E,CAAC;UACDa,OAAO,EAAEnJ,QAAQ,CAACmJ;QACpB,CAAC,CAAC;QACF,IAAIP,OAAO,EACT,MAAMA,OAAO;QACfxD,cAAc,CAACnP,IAAI,CAACgS,MAAM,CAAC;MAC7B,CAAC,CAAC,OAAOnV,CAAC,EAAE;QACV,OAAO;UAAEoS,EAAE,EAAE,KAAK;UAAEjE,KAAK,EAAEnO,CAAC;UAAE+R,UAAU,EAAEtT;QAAK,CAAC;MAClD;IACF;IACAuQ,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC5M,EAAE,EAAE0M,OAAO,KAAKxP,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,aAAa;MACjF,IAAIkP,QAAQ,GAAG;QAAES,MAAM,EAAE,EAAE;QAAEwB,QAAQ,EAAE;MAAG,CAAC;MAC3C,MAAM/Q,OAAO,CAAClB,GAAG,CAACoW,gBAAgB,CAACrL,GAAG,CAAE+M,EAAE,IAAKhX,OAAO,CAAC,KAAK,CAAC,EAAE,CAACgX,EAAE,CAAC,EAAE,WAAW;QAAE7X,IAAI;QAAE8P,QAAQ;QAAEyD;MAAK,CAAC,EAAE;QACxG,IAAI;UACF,IAAIrB,MAAM,GAAG,MAAMpC,QAAQ,EAAE;UAC7B,IAAIoC,MAAM,IAAI,IAAI,EAAE;YAClB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAC5B,MAAM,IAAIvN,KAAK,CAAE,yCAAwC6D,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,sBAAqB,CAAC;YACtG,IAAIyD,IAAI,GAAG,CAAC,CAAC;YACb,IAAI+M,MAAM,GAAG/I,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,QAAQ,EAAEqD,WAAW,CAAC;YACzD,IAAIkL,QAAQ,GAAGvK,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,UAAU,EAAEqD,WAAW,CAAC;YAC7De,oBAAoB,CAACqK,MAAM,EAAEzO,IAAI,EAAG,qCAAoC+E,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,EAAC,CAAC;YAC/F,IAAIwQ,MAAM,IAAI,IAAI,EAChBT,QAAQ,CAACS,MAAM,CAAC9L,IAAI,CAAC,GAAGoO,gBAAgB,CAACtC,MAAM,EAAE,QAAQ,EAAEkB,OAAO,EAAE1R,IAAI,CAAC,CAAC;YAC5E,IAAIgS,QAAQ,IAAI,IAAI,EAClBjC,QAAQ,CAACiC,QAAQ,CAACtN,IAAI,CAAC,GAAGoO,gBAAgB,CAACd,QAAQ,EAAE,UAAU,EAAEN,OAAO,EAAE1R,IAAI,CAAC,CAAC;UACpF;QACF,CAAC,CAAC,OAAOuB,CAAC,EAAE;UACVwO,QAAQ,CAACS,MAAM,CAAC9L,IAAI,CAAC+L,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAEiD,OAAO,EAAE6B,IAAI,IAAIA,IAAI,EAAE,EAAEvT,IAAI,CAAC,CAAC;QACzF;MACF,CAAC,CAAC,CAAC,CAAC;MACJmQ,YAAY,CAACxM,EAAE,EAAEoM,QAAQ,CAAC;IAC5B,CAAC,CAAC;IACFQ,gBAAgB,CAAC,YAAY,CAAC,GAAG,CAAC5M,EAAE,EAAE0M,OAAO,KAAKxP,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,aAAa;MACnF,IAAIkP,QAAQ,GAAG,CAAC,CAAC;QAAE/P,IAAI,GAAG,EAAE;QAAE8P,QAAQ;QAAEyD,IAAI;MAC5C,KAAK,IAAIuE,GAAG,IAAIzH,OAAO,CAAC0H,GAAG,EAAE;QAC3B,IAAI;UACF,CAAC;YAAE/X,IAAI;YAAE8P,QAAQ;YAAEyD;UAAK,CAAC,GAAG8C,kBAAkB,CAACyB,GAAG,CAAC;UACnD,IAAI5F,MAAM,GAAG,MAAMpC,QAAQ,CAAC;YAC1BjC,IAAI,EAAEwC,OAAO,CAACxC,IAAI;YAClBiJ,QAAQ,EAAEzG,OAAO,CAACyG,QAAQ;YAC1BC,SAAS,EAAE1G,OAAO,CAAC0G,SAAS;YAC5B7I,UAAU,EAAEmC,OAAO,CAACnC,UAAU;YAC9B6E,IAAI,EAAE1C,OAAO,CAAC0C,IAAI;YAClBiE,UAAU,EAAEtF,OAAO,CAACgB,IAAI,CAACrC,OAAO,CAAC2G,UAAU;UAC7C,CAAC,CAAC;UACF,IAAI9E,MAAM,IAAI,IAAI,EAAE;YAClB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAC5B,MAAM,IAAIvN,KAAK,CAAE,2CAA0C6D,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,sBAAqB,CAAC;YACxG,IAAIyD,IAAI,GAAG,CAAC,CAAC;YACb,IAAI6P,UAAU,GAAG7L,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;YAClE,IAAIoH,IAAI,GAAGpG,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,MAAM,EAAEgD,YAAY,CAAC;YACtD,IAAIsQ,SAAS,GAAGtP,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,WAAW,EAAEgD,YAAY,CAAC;YAChE,IAAI2Q,MAAM,GAAG3P,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;YAC1D,IAAIgG,QAAQ,GAAGhF,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,UAAU,EAAE6C,aAAa,CAAC;YAC/D,IAAI6Q,WAAW,GAAG1P,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,aAAa,EAAE6C,aAAa,CAAC;YACrE,IAAI0Q,UAAU,GAAGvP,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAE4C,aAAa,CAAC;YACnE,IAAImK,MAAM,GAAG/I,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,QAAQ,EAAEqD,WAAW,CAAC;YACzD,IAAIkL,QAAQ,GAAGvK,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,UAAU,EAAEqD,WAAW,CAAC;YAC7D,IAAIkR,UAAU,GAAGvQ,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAEqD,WAAW,CAAC;YACjE,IAAImR,SAAS,GAAGxQ,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,WAAW,EAAEqD,WAAW,CAAC;YAC/De,oBAAoB,CAACqK,MAAM,EAAEzO,IAAI,EAAG,uCAAsC+E,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,EAAC,CAAC;YACjG+P,QAAQ,CAACpM,EAAE,GAAGmU,GAAG;YACjB,IAAIxE,UAAU,IAAI,IAAI,EACpBvD,QAAQ,CAACuD,UAAU,GAAGA,UAAU;YAClC,IAAIzF,IAAI,IAAI,IAAI,EACdkC,QAAQ,CAAClC,IAAI,GAAGA,IAAI;YACtB,IAAIkJ,SAAS,IAAI,IAAI,EACnBhH,QAAQ,CAACgH,SAAS,GAAGA,SAAS;YAChC,IAAIK,MAAM,IAAI,IAAI,EAChBrH,QAAQ,CAACqH,MAAM,GAAGA,MAAM;YAC1B,IAAI3K,QAAQ,IAAI,IAAI,EAClBsD,QAAQ,CAACtD,QAAQ,GAAGA,QAAQ;YAC9B,IAAI0K,WAAW,IAAI,IAAI,EACrBpH,QAAQ,CAACoH,WAAW,GAAGA,WAAW;YACpC,IAAIH,UAAU,IAAI,IAAI,EACpBjH,QAAQ,CAACiH,UAAU,GAAGtF,OAAO,CAACwF,KAAK,CAACF,UAAU,CAAC;YACjD,IAAIxG,MAAM,IAAI,IAAI,EAChBT,QAAQ,CAACS,MAAM,GAAGsC,gBAAgB,CAACtC,MAAM,EAAE,QAAQ,EAAEkB,OAAO,EAAE1R,IAAI,CAAC;YACrE,IAAIgS,QAAQ,IAAI,IAAI,EAClBjC,QAAQ,CAACiC,QAAQ,GAAGc,gBAAgB,CAACd,QAAQ,EAAE,UAAU,EAAEN,OAAO,EAAE1R,IAAI,CAAC;YAC3E,IAAIgY,UAAU,IAAI,IAAI,EACpBjI,QAAQ,CAACiI,UAAU,GAAGE,mBAAmB,CAACF,UAAU,EAAE,YAAY,CAAC;YACrE,IAAIC,SAAS,IAAI,IAAI,EACnBlI,QAAQ,CAACkI,SAAS,GAAGC,mBAAmB,CAACD,SAAS,EAAE,WAAW,CAAC;YAClE;UACF;QACF,CAAC,CAAC,OAAO1W,CAAC,EAAE;UACVwO,QAAQ,GAAG;YAAEpM,EAAE,EAAEmU,GAAG;YAAEtH,MAAM,EAAE,CAACC,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAEiD,OAAO,EAAE6B,IAAI,IAAIA,IAAI,EAAE,EAAEvT,IAAI,CAAC;UAAE,CAAC;UACnG;QACF;MACF;MACAmQ,YAAY,CAACxM,EAAE,EAAEoM,QAAQ,CAAC;IAC5B,CAAC,CAAC;IACFQ,gBAAgB,CAAC,SAAS,CAAC,GAAG,CAAC5M,EAAE,EAAE0M,OAAO,KAAKxP,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,aAAa;MAChF,IAAIkP,QAAQ,GAAG,CAAC,CAAC;QAAE/P,IAAI,GAAG,EAAE;QAAE8P,QAAQ;QAAEyD,IAAI;MAC5C,KAAK,IAAIuE,GAAG,IAAIzH,OAAO,CAAC0H,GAAG,EAAE;QAC3B,IAAI;UACF,CAAC;YAAE/X,IAAI;YAAE8P,QAAQ;YAAEyD;UAAK,CAAC,GAAG+C,eAAe,CAACwB,GAAG,CAAC;UAChD,IAAI5F,MAAM,GAAG,MAAMpC,QAAQ,CAAC;YAC1BjC,IAAI,EAAEwC,OAAO,CAACxC,IAAI;YAClBkJ,SAAS,EAAE1G,OAAO,CAAC0G,SAAS;YAC5BK,MAAM,EAAE/G,OAAO,CAAC+G,MAAM;YACtBJ,UAAU,EAAEtF,OAAO,CAACgB,IAAI,CAACrC,OAAO,CAAC2G,UAAU;UAC7C,CAAC,CAAC;UACF,IAAI9E,MAAM,IAAI,IAAI,EAAE;YAClB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAC5B,MAAM,IAAIvN,KAAK,CAAE,wCAAuC6D,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,sBAAqB,CAAC;YACrG,IAAIyD,IAAI,GAAG,CAAC,CAAC;YACb,IAAI6P,UAAU,GAAG7L,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;YAClE,IAAIwH,QAAQ,GAAGxG,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,UAAU,EAAE+D,wBAAwB,CAAC;YAC1E,IAAI0G,UAAU,GAAGzG,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;YAClE,IAAIuQ,UAAU,GAAGvP,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAE4C,aAAa,CAAC;YACnE,IAAIqG,MAAM,GAAGjF,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,QAAQ,EAAEgD,YAAY,CAAC;YAC1D,IAAI+J,MAAM,GAAG/I,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,QAAQ,EAAEqD,WAAW,CAAC;YACzD,IAAIkL,QAAQ,GAAGvK,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,UAAU,EAAEqD,WAAW,CAAC;YAC7D,IAAIkR,UAAU,GAAGvQ,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,YAAY,EAAEqD,WAAW,CAAC;YACjE,IAAImR,SAAS,GAAGxQ,OAAO,CAACyK,MAAM,EAAEzO,IAAI,EAAE,WAAW,EAAEqD,WAAW,CAAC;YAC/De,oBAAoB,CAACqK,MAAM,EAAEzO,IAAI,EAAG,oCAAmC+E,IAAI,CAACC,SAAS,CAACzI,IAAI,CAAE,EAAC,CAAC;YAC9F+P,QAAQ,CAACpM,EAAE,GAAGmU,GAAG;YACjB,IAAIxE,UAAU,IAAI,IAAI,EACpBvD,QAAQ,CAACuD,UAAU,GAAGA,UAAU;YAClC,IAAIrF,QAAQ,YAAY5K,UAAU,EAChC0M,QAAQ,CAAC9B,QAAQ,GAAGA,QAAQ,CAAC,KAC1B,IAAIA,QAAQ,IAAI,IAAI,EACvB8B,QAAQ,CAAC9B,QAAQ,GAAG7K,UAAU,CAAC6K,QAAQ,CAAC;YAC1C,IAAIC,UAAU,IAAI,IAAI,EACpB6B,QAAQ,CAAC7B,UAAU,GAAGA,UAAU;YAClC,IAAI8I,UAAU,IAAI,IAAI,EACpBjH,QAAQ,CAACiH,UAAU,GAAGtF,OAAO,CAACwF,KAAK,CAACF,UAAU,CAAC;YACjD,IAAItK,MAAM,IAAI,IAAI,EAChBqD,QAAQ,CAACrD,MAAM,GAAGA,MAAM;YAC1B,IAAI8D,MAAM,IAAI,IAAI,EAChBT,QAAQ,CAACS,MAAM,GAAGsC,gBAAgB,CAACtC,MAAM,EAAE,QAAQ,EAAEkB,OAAO,EAAE1R,IAAI,CAAC;YACrE,IAAIgS,QAAQ,IAAI,IAAI,EAClBjC,QAAQ,CAACiC,QAAQ,GAAGc,gBAAgB,CAACd,QAAQ,EAAE,UAAU,EAAEN,OAAO,EAAE1R,IAAI,CAAC;YAC3E,IAAIgY,UAAU,IAAI,IAAI,EACpBjI,QAAQ,CAACiI,UAAU,GAAGE,mBAAmB,CAACF,UAAU,EAAE,YAAY,CAAC;YACrE,IAAIC,SAAS,IAAI,IAAI,EACnBlI,QAAQ,CAACkI,SAAS,GAAGC,mBAAmB,CAACD,SAAS,EAAE,WAAW,CAAC;YAClE;UACF;QACF,CAAC,CAAC,OAAO1W,CAAC,EAAE;UACVwO,QAAQ,GAAG;YAAEpM,EAAE,EAAEmU,GAAG;YAAEtH,MAAM,EAAE,CAACC,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAEiD,OAAO,EAAE6B,IAAI,IAAIA,IAAI,EAAE,EAAEvT,IAAI,CAAC;UAAE,CAAC;UACnG;QACF;MACF;MACAmQ,YAAY,CAACxM,EAAE,EAAEoM,QAAQ,CAAC;IAC5B,CAAC,CAAC;IACF,IAAI+D,iBAAiB,GAAG,CAAC5B,MAAM,EAAEmB,cAAc,EAAE1R,IAAI,KAAKA,IAAI,EAAE;IAChE,IAAIyU,cAAc,CAAC7S,MAAM,GAAG,CAAC,EAAE;MAC7BuQ,iBAAiB,GAAG,CAAC5B,MAAM,EAAEmB,cAAc,EAAE1R,IAAI,KAAK;QACpD,CAAC,MAAMd,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,aAAa;UACxC,KAAK,MAAM;YAAEb,IAAI;YAAE8P,QAAQ;YAAEyD;UAAK,CAAC,IAAI6C,cAAc,EAAE;YACrD,IAAI;cACF,MAAMtG,QAAQ,CAACoC,MAAM,CAAC;YACxB,CAAC,CAAC,OAAO3Q,CAAC,EAAE;cACV2Q,MAAM,CAAC1B,MAAM,CAAC9L,IAAI,CAAC,MAAM,IAAIzD,OAAO,CAAEC,OAAO,IAAKmS,cAAc,CAAC9R,CAAC,EAAEvB,IAAI,EAAEuT,IAAI,IAAIA,IAAI,EAAE,EAAErS,OAAO,CAAC,CAAC,CAAC;YACtG;UACF;QACF,CAAC,CAAC,GAAG,CAACU,IAAI,CAACD,IAAI,CAAC;MAClB,CAAC;IACH;IACA6U,WAAW,GAAG,IAAI;IAClB,OAAO;MACL7C,EAAE,EAAE,IAAI;MACRE,cAAc;MACdC;IACF,CAAC;EACH,CAAC,CAAC;EACF,SAASnC,iBAAiB,GAAG;IAC3B,MAAM7G,GAAG,GAAG,eAAgB,IAAIqN,GAAG,EAAE;IACrC,IAAIC,MAAM,GAAG,CAAC;IACd,OAAO;MACL1F,IAAI,CAAC/O,EAAE,EAAE;QACP,OAAOmH,GAAG,CAAC7K,GAAG,CAAC0D,EAAE,CAAC;MACpB,CAAC;MACDuT,KAAK,CAACtW,KAAK,EAAE;QACX,IAAIA,KAAK,KAAK,KAAK,CAAC,EAClB,OAAO,CAAC,CAAC;QACX,MAAM+C,EAAE,GAAGyU,MAAM,EAAE;QACnBtN,GAAG,CAAC7F,GAAG,CAACtB,EAAE,EAAE/C,KAAK,CAAC;QAClB,OAAO+C,EAAE;MACX;IACF,CAAC;EACH;EACA,SAAS8T,eAAe,CAAClW,CAAC,EAAEkN,QAAQ,EAAE4J,KAAK,EAAE;IAC3C,IAAI9E,IAAI;IACR,IAAI+E,KAAK,GAAG,KAAK;IACjB,OAAO,MAAM;MACX,IAAIA,KAAK,EACP,OAAO/E,IAAI;MACb+E,KAAK,GAAG,IAAI;MACZ,IAAI;QACF,IAAIC,KAAK,GAAG,CAAChX,CAAC,CAACiX,KAAK,GAAG,EAAE,EAAEC,KAAK,CAAC,IAAI,CAAC;QACtCF,KAAK,CAACG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;QAClB,IAAIxD,QAAQ,GAAGyD,iBAAiB,CAAClK,QAAQ,EAAE8J,KAAK,EAAEF,KAAK,CAAC;QACxD,IAAInD,QAAQ,EAAE;UACZ3B,IAAI,GAAG;YAAE9N,IAAI,EAAElE,CAAC,CAACoO,OAAO;YAAEuF;UAAS,CAAC;UACpC,OAAO3B,IAAI;QACb;MACF,CAAC,CAAC,OAAOf,EAAE,EAAE,CACb;IACF,CAAC;EACH;EACA,SAAS/B,qBAAqB,CAAClP,CAAC,EAAEkN,QAAQ,EAAEmK,KAAK,EAAErF,IAAI,EAAED,UAAU,EAAE;IACnE,IAAI7N,IAAI,GAAG,gBAAgB;IAC3B,IAAIyP,QAAQ,GAAG,IAAI;IACnB,IAAI;MACFzP,IAAI,GAAG,CAAClE,CAAC,IAAIA,CAAC,CAACoO,OAAO,IAAIpO,CAAC,IAAI,EAAE;IACnC,CAAC,CAAC,OAAOiR,EAAE,EAAE,CACb;IACA,IAAI;MACF0C,QAAQ,GAAGyD,iBAAiB,CAAClK,QAAQ,EAAE,CAAClN,CAAC,CAACiX,KAAK,GAAG,EAAE,EAAEC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC;IACxE,CAAC,CAAC,OAAOjG,EAAE,EAAE,CACb;IACA,OAAO;MAAE7O,EAAE,EAAE,EAAE;MAAE2P,UAAU;MAAE7N,IAAI;MAAEyP,QAAQ;MAAEC,KAAK,EAAE5B,IAAI,GAAG,CAACA,IAAI,CAAC,GAAG,EAAE;MAAEd,MAAM,EAAEmG,KAAK,GAAGA,KAAK,CAAC1B,KAAK,CAAC3V,CAAC,CAAC,GAAG,CAAC;IAAE,CAAC;EAC/G;EACA,SAASoX,iBAAiB,CAAClK,QAAQ,EAAE8J,KAAK,EAAEF,KAAK,EAAE;IACjD,IAAIQ,EAAE,GAAG,SAAS;IAClB,IAAIpK,QAAQ,CAACqK,YAAY,IAAI,CAACP,KAAK,CAAC,CAAC,CAAC,CAACQ,UAAU,CAACF,EAAE,CAAC,IAAIN,KAAK,CAAC,CAAC,CAAC,CAACQ,UAAU,CAACF,EAAE,CAAC,EAAE;MAChF,KAAK,IAAIpU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8T,KAAK,CAAChV,MAAM,EAAEkB,CAAC,EAAE,EAAE;QACrC,IAAIuU,IAAI,GAAGT,KAAK,CAAC9T,CAAC,CAAC;QACnB,IAAI,CAACuU,IAAI,CAACD,UAAU,CAACF,EAAE,CAAC,EACtB;QACFG,IAAI,GAAGA,IAAI,CAACC,KAAK,CAACJ,EAAE,CAACtV,MAAM,CAAC;QAC5B,OAAO,IAAI,EAAE;UACX,IAAI2V,KAAK,GAAG,gCAAgC,CAACC,IAAI,CAACH,IAAI,CAAC;UACvD,IAAIE,KAAK,EAAE;YACTF,IAAI,GAAGE,KAAK,CAAC,CAAC,CAAC;YACf;UACF;UACAA,KAAK,GAAG,0CAA0C,CAACC,IAAI,CAACH,IAAI,CAAC;UAC7D,IAAIE,KAAK,EAAE;YACTF,IAAI,GAAGE,KAAK,CAAC,CAAC,CAAC;YACf;UACF;UACAA,KAAK,GAAG,qBAAqB,CAACC,IAAI,CAACH,IAAI,CAAC;UACxC,IAAIE,KAAK,EAAE;YACT,IAAIjL,QAAQ;YACZ,IAAI;cACFA,QAAQ,GAAGQ,QAAQ,CAACqK,YAAY,CAACI,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC;YACpD,CAAC,CAAC,OAAO3X,CAAC,EAAE;cACV;YACF;YACA,IAAI6X,QAAQ,GAAGnL,QAAQ,CAACwK,KAAK,CAAC,0BAA0B,CAAC,CAAC,CAACS,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE;YAC9E,IAAIG,MAAM,GAAG,CAACH,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;YAC1B,IAAI3V,MAAM,GAAG6V,QAAQ,CAACH,KAAK,CAACI,MAAM,EAAEA,MAAM,GAAGhB,KAAK,CAAC9U,MAAM,CAAC,KAAK8U,KAAK,GAAGA,KAAK,CAAC9U,MAAM,GAAG,CAAC;YACvF,OAAO;cACL+V,IAAI,EAAEJ,KAAK,CAAC,CAAC,CAAC;cACdnC,SAAS,EAAE,MAAM;cACjBiC,IAAI,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC;cACfG,MAAM,EAAEjW,UAAU,CAACgW,QAAQ,CAACH,KAAK,CAAC,CAAC,EAAEI,MAAM,CAAC,CAAC,CAAC9V,MAAM;cACpDA,MAAM,EAAEH,UAAU,CAACgW,QAAQ,CAACH,KAAK,CAACI,MAAM,EAAEA,MAAM,GAAG9V,MAAM,CAAC,CAAC,CAACA,MAAM;cAClE6V,QAAQ,EAAEA,QAAQ,GAAG,IAAI,GAAGb,KAAK,CAACU,KAAK,CAAC,CAAC,CAAC,CAAClO,IAAI,CAAC,IAAI,CAAC;cACrDwO,UAAU,EAAE;YACd,CAAC;UACH;UACA;QACF;MACF;IACF;IACA,OAAO,IAAI;EACb;EACA,SAASnH,mBAAmB,CAAC3M,IAAI,EAAE+K,MAAM,EAAEwB,QAAQ,EAAE;IACnD,IAAI3C,KAAK,GAAG,CAAC;IACb,IAAImK,OAAO,GAAGhJ,MAAM,CAACjN,MAAM,GAAG,CAAC,GAAG,EAAE,GAAI,SAAQiN,MAAM,CAACjN,MAAO,SAAQiN,MAAM,CAACjN,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,GAAI,GAAE,GAAGiN,MAAM,CAACyI,KAAK,CAAC,CAAC,EAAE5J,KAAK,GAAG,CAAC,CAAC,CAACvE,GAAG,CAAC,CAACvJ,CAAC,EAAEkD,CAAC,KAAK;MAC/I,IAAIA,CAAC,KAAK4K,KAAK,EACb,OAAO,OAAO;MAChB,IAAI,CAAC9N,CAAC,CAAC2T,QAAQ,EACb,OAAQ;AACd,SAAS3T,CAAC,CAACkE,IAAK,EAAC;MACb,IAAI;QAAE6T,IAAI;QAAEN,IAAI;QAAEK;MAAO,CAAC,GAAG9X,CAAC,CAAC2T,QAAQ;MACvC,IAAIuE,UAAU,GAAGlY,CAAC,CAAC+R,UAAU,GAAI,YAAW/R,CAAC,CAAC+R,UAAW,IAAG,GAAG,EAAE;MACjE,OAAQ;AACZ,EAAEgG,IAAK,IAAGN,IAAK,IAAGK,MAAO,YAAWI,UAAW,GAAElY,CAAC,CAACkE,IAAK,EAAC;IACvD,CAAC,CAAC,CAACsF,IAAI,CAAC,EAAE,CAAC;IACX,IAAI2E,KAAK,GAAG,IAAI/K,KAAK,CAAE,GAAEc,IAAK,GAAE+T,OAAQ,EAAC,CAAC;IAC1C9J,KAAK,CAACc,MAAM,GAAGA,MAAM;IACrBd,KAAK,CAACsC,QAAQ,GAAGA,QAAQ;IACzB,OAAOtC,KAAK;EACd;EACA,SAASqC,wBAAwB,CAACc,QAAQ,EAAE+F,KAAK,EAAE;IACjD,KAAK,MAAMjJ,OAAO,IAAIkD,QAAQ,EAAE;MAC9BlD,OAAO,CAAC8C,MAAM,GAAGmG,KAAK,CAAClG,IAAI,CAAC/C,OAAO,CAAC8C,MAAM,CAAC;IAC7C;IACA,OAAOI,QAAQ;EACjB;EACA,SAAS6G,gBAAgB,CAACxE,QAAQ,EAAEpN,KAAK,EAAE;IACzC,IAAIoN,QAAQ,IAAI,IAAI,EAClB,OAAO,IAAI;IACb,IAAIzR,IAAI,GAAG,CAAC,CAAC;IACb,IAAI6V,IAAI,GAAG7R,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,MAAM,EAAEgD,YAAY,CAAC;IACxD,IAAIsQ,SAAS,GAAGtP,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,WAAW,EAAEgD,YAAY,CAAC;IAClE,IAAIuS,IAAI,GAAGvR,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,MAAM,EAAEmD,aAAa,CAAC;IACzD,IAAIyS,MAAM,GAAG5R,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,QAAQ,EAAEmD,aAAa,CAAC;IAC7D,IAAIrD,MAAM,GAAGkE,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,QAAQ,EAAEmD,aAAa,CAAC;IAC7D,IAAIwS,QAAQ,GAAG3R,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,UAAU,EAAEgD,YAAY,CAAC;IAChE,IAAI8S,UAAU,GAAG9R,OAAO,CAACyN,QAAQ,EAAEzR,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;IACpEoB,oBAAoB,CAACqN,QAAQ,EAAEzR,IAAI,EAAEqE,KAAK,CAAC;IAC3C,OAAO;MACLwR,IAAI,EAAEA,IAAI,IAAI,EAAE;MAChBvC,SAAS,EAAEA,SAAS,IAAI,EAAE;MAC1BiC,IAAI,EAAEA,IAAI,IAAI,CAAC;MACfK,MAAM,EAAEA,MAAM,IAAI,CAAC;MACnB9V,MAAM,EAAEA,MAAM,IAAI,CAAC;MACnB6V,QAAQ,EAAEA,QAAQ,IAAI,EAAE;MACxBG,UAAU,EAAEA,UAAU,IAAI;IAC5B,CAAC;EACH;EACA,SAASzG,gBAAgB,CAACD,QAAQ,EAAE8G,QAAQ,EAAEf,KAAK,EAAEgB,kBAAkB,EAAE;IACvE,IAAIC,aAAa,GAAG,EAAE;IACtB,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,MAAMnK,OAAO,IAAIkD,QAAQ,EAAE;MAC9B,IAAIpP,IAAI,GAAG,CAAC,CAAC;MACb,IAAIE,EAAE,GAAG8D,OAAO,CAACkI,OAAO,EAAElM,IAAI,EAAE,IAAI,EAAEgD,YAAY,CAAC;MACnD,IAAI6M,UAAU,GAAG7L,OAAO,CAACkI,OAAO,EAAElM,IAAI,EAAE,YAAY,EAAEgD,YAAY,CAAC;MACnE,IAAIhB,IAAI,GAAGgC,OAAO,CAACkI,OAAO,EAAElM,IAAI,EAAE,MAAM,EAAEgD,YAAY,CAAC;MACvD,IAAIyO,QAAQ,GAAGzN,OAAO,CAACkI,OAAO,EAAElM,IAAI,EAAE,UAAU,EAAE2D,kBAAkB,CAAC;MACrE,IAAI+N,KAAK,GAAG1N,OAAO,CAACkI,OAAO,EAAElM,IAAI,EAAE,OAAO,EAAEqD,WAAW,CAAC;MACxD,IAAI2L,MAAM,GAAGhL,OAAO,CAACkI,OAAO,EAAElM,IAAI,EAAE,QAAQ,EAAE4C,aAAa,CAAC;MAC5D,IAAIyB,KAAK,GAAI,cAAagS,KAAM,QAAOH,QAAS,GAAE;MAClD9R,oBAAoB,CAAC8H,OAAO,EAAElM,IAAI,EAAEqE,KAAK,CAAC;MAC1C,IAAIiS,UAAU,GAAG,EAAE;MACnB,IAAI5E,KAAK,EAAE;QACT,KAAK,MAAM5B,IAAI,IAAI4B,KAAK,EAAE;UACxB,IAAI6E,QAAQ,GAAG,CAAC,CAAC;UACjB,IAAIC,QAAQ,GAAGxS,OAAO,CAAC8L,IAAI,EAAEyG,QAAQ,EAAE,MAAM,EAAEvT,YAAY,CAAC;UAC5D,IAAIyT,YAAY,GAAGzS,OAAO,CAAC8L,IAAI,EAAEyG,QAAQ,EAAE,UAAU,EAAE5S,kBAAkB,CAAC;UAC1ES,oBAAoB,CAAC0L,IAAI,EAAEyG,QAAQ,EAAElS,KAAK,CAAC;UAC3CiS,UAAU,CAACrV,IAAI,CAAC;YACde,IAAI,EAAEwU,QAAQ,IAAI,EAAE;YACpB/E,QAAQ,EAAEwE,gBAAgB,CAACQ,YAAY,EAAEpS,KAAK;UAChD,CAAC,CAAC;QACJ;MACF;MACA+R,aAAa,CAACnV,IAAI,CAAC;QACjBf,EAAE,EAAEA,EAAE,IAAI,EAAE;QACZ2P,UAAU,EAAEA,UAAU,IAAIsG,kBAAkB;QAC5CnU,IAAI,EAAEA,IAAI,IAAI,EAAE;QAChByP,QAAQ,EAAEwE,gBAAgB,CAACxE,QAAQ,EAAEpN,KAAK,CAAC;QAC3CqN,KAAK,EAAE4E,UAAU;QACjBtH,MAAM,EAAEmG,KAAK,GAAGA,KAAK,CAAC1B,KAAK,CAACzE,MAAM,CAAC,GAAG,CAAC;MACzC,CAAC,CAAC;MACFqH,KAAK,EAAE;IACT;IACA,OAAOD,aAAa;EACtB;EACA,SAAS3B,mBAAmB,CAACvK,MAAM,EAAEgM,QAAQ,EAAE;IAC7C,MAAMzH,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMtR,KAAK,IAAI+M,MAAM,EAAE;MAC1B,IAAI,OAAO/M,KAAK,KAAK,QAAQ,EAC3B,MAAM,IAAI+D,KAAK,CAAE,GAAE6D,IAAI,CAACC,SAAS,CAACkR,QAAQ,CAAE,8BAA6B,CAAC;MAC5EzH,MAAM,CAACxN,IAAI,CAAC9D,KAAK,CAAC;IACpB;IACA,OAAOsR,MAAM;EACf;EACA,SAASqC,kBAAkB,CAAC;IAAE1G,IAAI;IAAEI;EAAS,CAAC,EAAE;IAC9C,IAAIxI,IAAI,GAAG,IAAI;IACf,OAAO;MACLoI,IAAI;MACJI,QAAQ;MACR,IAAIxI,IAAI,GAAG;QACT,MAAM0U,MAAM,GAAG,IAAI,CAAClM,QAAQ;QAC5B,IAAIxI,IAAI,KAAK,IAAI,IAAI0U,MAAM,KAAKlM,QAAQ,EAAE;UACxCA,QAAQ,GAAGkM,MAAM;UACjB1U,IAAI,GAAGpB,UAAU,CAAC8V,MAAM,CAAC;QAC3B;QACA,OAAO1U,IAAI;MACb;IACF,CAAC;EACH;;EAEA;EACA,IAAI9C,OAAO,GAAG,SAAS;EACvB,IAAIV,KAAK,GAAI+F,OAAO,IAAKoS,sBAAsB,EAAE,CAACnY,KAAK,CAAC+F,OAAO,CAAC;EAChE,IAAIxF,KAAK,GAAG,MAAM;IAChB,MAAM,IAAImC,KAAK,CAAE,oCAAmC,CAAC;EACvD,CAAC;EACD,IAAIlC,SAAS,GAAG,CAAC+O,KAAK,EAAExJ,OAAO,KAAKoS,sBAAsB,EAAE,CAAC3X,SAAS,CAAC+O,KAAK,EAAExJ,OAAO,CAAC;EACtF,IAAI3F,cAAc,GAAG,CAACwQ,QAAQ,EAAE7K,OAAO,KAAKoS,sBAAsB,EAAE,CAAC/X,cAAc,CAACwQ,QAAQ,EAAE7K,OAAO,CAAC;EACtG,IAAIjG,eAAe,GAAG,CAACiK,QAAQ,EAAEhE,OAAO,KAAKoS,sBAAsB,EAAE,CAACrY,eAAe,CAACiK,QAAQ,EAAEhE,OAAO,CAAC;EACxG,IAAI9F,SAAS,GAAG,MAAM;IACpB,MAAM,IAAIyC,KAAK,CAAE,wCAAuC,CAAC;EAC3D,CAAC;EACD,IAAIjC,aAAa,GAAG,MAAM;IACxB,MAAM,IAAIiC,KAAK,CAAE,4CAA2C,CAAC;EAC/D,CAAC;EACD,IAAIrC,kBAAkB,GAAG,MAAM;IAC7B,MAAM,IAAIqC,KAAK,CAAE,iDAAgD,CAAC;EACpE,CAAC;EACD,IAAI3C,mBAAmB,GAAG,MAAM;IAC9B,MAAM,IAAI2C,KAAK,CAAE,kDAAiD,CAAC;EACrE,CAAC;EACD,IAAI0V,iBAAiB;EACrB,IAAIC,gBAAgB;EACpB,IAAIF,sBAAsB,GAAG,MAAM;IACjC,IAAIE,gBAAgB,EAClB,OAAOA,gBAAgB;IACzB,IAAID,iBAAiB,EACnB,MAAM,IAAI1V,KAAK,CAAC,gGAAgG,CAAC;IACnH,MAAM,IAAIA,KAAK,CAAC,mDAAmD,CAAC;EACtE,CAAC;EACD,IAAIpC,UAAU,GAAIyF,OAAO,IAAK;IAC5BA,OAAO,GAAGD,yBAAyB,CAACC,OAAO,IAAI,CAAC,CAAC,CAAC;IAClD,IAAIE,OAAO,GAAGF,OAAO,CAACE,OAAO;IAC7B,IAAIC,UAAU,GAAGH,OAAO,CAACG,UAAU;IACnC,IAAIoS,SAAS,GAAGvS,OAAO,CAACI,MAAM,KAAK,KAAK;IACxC,IAAI,CAACF,OAAO,IAAI,CAACC,UAAU,EACzB,MAAM,IAAIxD,KAAK,CAAC,qEAAqE,CAAC;IACxF,IAAI0V,iBAAiB,EACnB,MAAM,IAAI1V,KAAK,CAAC,yCAAyC,CAAC;IAC5D0V,iBAAiB,GAAGG,mBAAmB,CAACtS,OAAO,IAAI,EAAE,EAAEC,UAAU,EAAEoS,SAAS,CAAC;IAC7EF,iBAAiB,CAACI,KAAK,CAAC,MAAM;MAC5BJ,iBAAiB,GAAG,KAAK,CAAC;IAC5B,CAAC,CAAC;IACF,OAAOA,iBAAiB;EAC1B,CAAC;EACD,IAAIG,mBAAmB,GAAG,CAACtS,OAAO,EAAEC,UAAU,EAAEoS,SAAS,KAAK1Z,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,aAAa;IAC/F,IAAI6Z,IAAI;IACR,IAAIvS,UAAU,EAAE;MACduS,IAAI,GAAGvS,UAAU;IACnB,CAAC,MAAM;MACL,IAAImJ,GAAG,GAAG,MAAMqJ,KAAK,CAACzS,OAAO,CAAC;MAC9B,IAAI,CAACoJ,GAAG,CAACqC,EAAE,EACT,MAAM,IAAIhP,KAAK,CAAE,sBAAqB6D,IAAI,CAACC,SAAS,CAACP,OAAO,CAAE,EAAC,CAAC;MAClEwS,IAAI,GAAG,MAAMpJ,GAAG,CAACsJ,WAAW,EAAE;IAChC;IACA,IAAIxS,MAAM;IACV,IAAImS,SAAS,EAAE;MACb,IAAIM,IAAI,GAAG,IAAIC,IAAI,CAAC,CAAE,aAAY,u+tBAAw+tB,eAAc,CAAC,EAAE;QAAElN,IAAI,EAAE;MAAkB,CAAC,CAAC;MACvjuBxF,MAAM,GAAG,IAAI2S,MAAM,CAACC,GAAG,CAACC,eAAe,CAACJ,IAAI,CAAC,CAAC;IAChD,CAAC,MAAM;MACL,IAAIK,SAAS,GAAG,CAAEC,WAAW,IAAK;QAChC;QACA;QACA;QACA,IAAIta,OAAO,GAAG,CAACC,MAAM,EAAEC,WAAW,EAAEC,SAAS,KAAK;UAChD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;YACtC,IAAIC,SAAS,GAAIR,KAAK,IAAK;cACzB,IAAI;gBACFS,IAAI,CAACL,SAAS,CAACM,IAAI,CAACV,KAAK,CAAC,CAAC;cAC7B,CAAC,CAAC,OAAOW,CAAC,EAAE;gBACVJ,MAAM,CAACI,CAAC,CAAC;cACX;YACF,CAAC;YACD,IAAIC,QAAQ,GAAIZ,KAAK,IAAK;cACxB,IAAI;gBACFS,IAAI,CAACL,SAAS,CAACS,KAAK,CAACb,KAAK,CAAC,CAAC;cAC9B,CAAC,CAAC,OAAOW,CAAC,EAAE;gBACVJ,MAAM,CAACI,CAAC,CAAC;cACX;YACF,CAAC;YACD,IAAIF,IAAI,GAAIK,CAAC,IAAKA,CAAC,CAACC,IAAI,GAAGT,OAAO,CAACQ,CAAC,CAACd,KAAK,CAAC,GAAGK,OAAO,CAACC,OAAO,CAACQ,CAAC,CAACd,KAAK,CAAC,CAACgB,IAAI,CAACR,SAAS,EAAEI,QAAQ,CAAC;YAChGH,IAAI,CAAC,CAACL,SAAS,GAAGA,SAAS,CAACa,KAAK,CAACf,MAAM,EAAEC,WAAW,CAAC,EAAEO,IAAI,EAAE,CAAC;UACjE,CAAC,CAAC;QACJ,CAAC;QACD,IAAI4Z,SAAS;QACb,IAAIE,UAAU,GAAG,CAAC,CAAC;QACnB,KAAK,IAAIC,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAEA,CAAC,GAAGjc,MAAM,CAACmc,cAAc,CAACF,CAAC,CAAC,EAChD,KAAK,IAAIG,CAAC,IAAIpc,MAAM,CAACK,mBAAmB,CAAC4b,CAAC,CAAC,EACzC,IAAI,EAAEG,CAAC,IAAIJ,UAAU,CAAC,EACpBhc,MAAM,CAACC,cAAc,CAAC+b,UAAU,EAAEI,CAAC,EAAE;UAAEvb,GAAG,EAAE,MAAMqb,IAAI,CAACE,CAAC;QAAE,CAAC,CAAC;QAClE,YAAY;QACZ,CAAC,MAAM;UACL,MAAMC,MAAM,GAAG,MAAM;YACnB,MAAMpK,GAAG,GAAG,IAAI1M,KAAK,CAAC,iBAAiB,CAAC;YACxC0M,GAAG,CAACc,IAAI,GAAG,QAAQ;YACnB,OAAOd,GAAG;UACZ,CAAC;UACD,IAAI,CAAC+J,UAAU,CAAC3J,EAAE,EAAE;YAClB,IAAIiK,SAAS,GAAG,EAAE;YAClBN,UAAU,CAAC3J,EAAE,GAAG;cACdkK,SAAS,EAAE;gBAAEC,QAAQ,EAAE,CAAC,CAAC;gBAAEC,MAAM,EAAE,CAAC,CAAC;gBAAEC,OAAO,EAAE,CAAC,CAAC;gBAAEC,OAAO,EAAE,CAAC,CAAC;gBAAEC,QAAQ,EAAE,CAAC,CAAC;gBAAEC,MAAM,EAAE,CAAC;cAAE,CAAC;cAC3FC,SAAS,CAACC,EAAE,EAAErY,GAAG,EAAE;gBACjB4X,SAAS,IAAIlW,OAAO,CAACG,MAAM,CAAC7B,GAAG,CAAC;gBAChC,MAAMsY,EAAE,GAAGV,SAAS,CAACW,WAAW,CAAC,IAAI,CAAC;gBACtC,IAAID,EAAE,IAAI,CAAC,CAAC,EAAE;kBACZ1H,OAAO,CAACC,GAAG,CAAC+G,SAAS,CAACY,MAAM,CAAC,CAAC,EAAEF,EAAE,CAAC,CAAC;kBACpCV,SAAS,GAAGA,SAAS,CAACY,MAAM,CAACF,EAAE,GAAG,CAAC,CAAC;gBACtC;gBACA,OAAOtY,GAAG,CAACP,MAAM;cACnB,CAAC;cACDJ,KAAK,CAACgZ,EAAE,EAAErY,GAAG,EAAEoB,MAAM,EAAE3B,MAAM,EAAEgZ,QAAQ,EAAEzM,QAAQ,EAAE;gBACjD,IAAI5K,MAAM,KAAK,CAAC,IAAI3B,MAAM,KAAKO,GAAG,CAACP,MAAM,IAAIgZ,QAAQ,KAAK,IAAI,EAAE;kBAC9DzM,QAAQ,CAAC2L,MAAM,EAAE,CAAC;kBAClB;gBACF;gBACA,MAAMe,CAAC,GAAG,IAAI,CAACN,SAAS,CAACC,EAAE,EAAErY,GAAG,CAAC;gBACjCgM,QAAQ,CAAC,IAAI,EAAE0M,CAAC,CAAC;cACnB,CAAC;cACDC,KAAK,CAAC5O,IAAI,EAAE6O,IAAI,EAAE5M,QAAQ,EAAE;gBAC1BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDkB,KAAK,CAAC9O,IAAI,EAAE+O,GAAG,EAAEC,GAAG,EAAE/M,QAAQ,EAAE;gBAC9BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDqB,KAAK,CAACX,EAAE,EAAErM,QAAQ,EAAE;gBAClBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDsB,MAAM,CAACZ,EAAE,EAAEO,IAAI,EAAE5M,QAAQ,EAAE;gBACzBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDuB,MAAM,CAACb,EAAE,EAAES,GAAG,EAAEC,GAAG,EAAE/M,QAAQ,EAAE;gBAC7BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDwB,KAAK,CAACd,EAAE,EAAErM,QAAQ,EAAE;gBAClBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDyB,KAAK,CAACf,EAAE,EAAErM,QAAQ,EAAE;gBAClBA,QAAQ,CAAC,IAAI,CAAC;cAChB,CAAC;cACDqN,SAAS,CAAChB,EAAE,EAAE5Y,MAAM,EAAEuM,QAAQ,EAAE;gBAC9BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACD2B,MAAM,CAACvP,IAAI,EAAE+O,GAAG,EAAEC,GAAG,EAAE/M,QAAQ,EAAE;gBAC/BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACD4B,IAAI,CAACxP,IAAI,EAAEwP,IAAI,EAAEvN,QAAQ,EAAE;gBACzBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACD6B,KAAK,CAACzP,IAAI,EAAEiC,QAAQ,EAAE;gBACpBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACD8B,KAAK,CAAC1P,IAAI,EAAE2P,IAAI,EAAE1N,QAAQ,EAAE;gBAC1BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDgC,IAAI,CAAC5P,IAAI,EAAElF,KAAK,EAAE+T,IAAI,EAAE5M,QAAQ,EAAE;gBAChCA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDnX,IAAI,CAAC6X,EAAE,EAAEtW,MAAM,EAAEX,MAAM,EAAE3B,MAAM,EAAEgZ,QAAQ,EAAEzM,QAAQ,EAAE;gBACnDA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDiC,OAAO,CAAC7P,IAAI,EAAEiC,QAAQ,EAAE;gBACtBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDkC,QAAQ,CAAC9P,IAAI,EAAEiC,QAAQ,EAAE;gBACvBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDmC,MAAM,CAACvd,IAAI,EAAED,EAAE,EAAE0P,QAAQ,EAAE;gBACzBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDoC,KAAK,CAAChQ,IAAI,EAAEiC,QAAQ,EAAE;gBACpBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDqC,IAAI,CAACjQ,IAAI,EAAEiC,QAAQ,EAAE;gBACnBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDsC,OAAO,CAAClQ,IAAI,EAAEwP,IAAI,EAAEvN,QAAQ,EAAE;gBAC5BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDuC,QAAQ,CAACnQ,IAAI,EAAEtK,MAAM,EAAEuM,QAAQ,EAAE;gBAC/BA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDwC,MAAM,CAACpQ,IAAI,EAAEiC,QAAQ,EAAE;gBACrBA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB,CAAC;cACDyC,MAAM,CAACrQ,IAAI,EAAEsQ,KAAK,EAAEC,KAAK,EAAEtO,QAAQ,EAAE;gBACnCA,QAAQ,CAAC2L,MAAM,EAAE,CAAC;cACpB;YACF,CAAC;UACH;UACA,IAAI,CAACL,UAAU,CAACiD,OAAO,EAAE;YACvBjD,UAAU,CAACiD,OAAO,GAAG;cACnBC,MAAM,GAAG;gBACP,OAAO,CAAC,CAAC;cACX,CAAC;cACDC,MAAM,GAAG;gBACP,OAAO,CAAC,CAAC;cACX,CAAC;cACDC,OAAO,GAAG;gBACR,OAAO,CAAC,CAAC;cACX,CAAC;cACDC,OAAO,GAAG;gBACR,OAAO,CAAC,CAAC;cACX,CAAC;cACDC,SAAS,GAAG;gBACV,MAAMjD,MAAM,EAAE;cAChB,CAAC;cACDkD,GAAG,EAAE,CAAC,CAAC;cACPC,IAAI,EAAE,CAAC,CAAC;cACRC,KAAK,GAAG;gBACN,MAAMpD,MAAM,EAAE;cAChB,CAAC;cACDqD,GAAG,GAAG;gBACJ,MAAMrD,MAAM,EAAE;cAChB,CAAC;cACDsD,KAAK,GAAG;gBACN,MAAMtD,MAAM,EAAE;cAChB;YACF,CAAC;UACH;UACA,IAAI,CAACL,UAAU,CAAC4D,MAAM,EAAE;YACtB,MAAM,IAAIra,KAAK,CAAC,qFAAqF,CAAC;UACxG;UACA,IAAI,CAACyW,UAAU,CAAC6D,WAAW,EAAE;YAC3B,MAAM,IAAIta,KAAK,CAAC,mFAAmF,CAAC;UACtG;UACA,IAAI,CAACyW,UAAU,CAAC/V,WAAW,EAAE;YAC3B,MAAM,IAAIV,KAAK,CAAC,4DAA4D,CAAC;UAC/E;UACA,IAAI,CAACyW,UAAU,CAAC9V,WAAW,EAAE;YAC3B,MAAM,IAAIX,KAAK,CAAC,4DAA4D,CAAC;UAC/E;UACA,MAAMY,OAAO,GAAG,IAAIF,WAAW,CAAC,OAAO,CAAC;UACxC,MAAMG,OAAO,GAAG,IAAIF,WAAW,CAAC,OAAO,CAAC;UACxC8V,UAAU,CAAC8D,EAAE,GAAG,MAAM;YACpBra,WAAW,GAAG;cACZ,IAAI,CAACsa,IAAI,GAAG,CAAC,IAAI,CAAC;cAClB,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC;cACb,IAAI,CAACC,IAAI,GAAIlN,IAAI,IAAK;gBACpB,IAAIA,IAAI,KAAK,CAAC,EAAE;kBACduC,OAAO,CAAC4K,IAAI,CAAC,YAAY,EAAEnN,IAAI,CAAC;gBAClC;cACF,CAAC;cACD,IAAI,CAACoN,YAAY,GAAG,IAAIte,OAAO,CAAEC,OAAO,IAAK;gBAC3C,IAAI,CAACse,mBAAmB,GAAGte,OAAO;cACpC,CAAC,CAAC;cACF,IAAI,CAACue,aAAa,GAAG,IAAI;cACzB,IAAI,CAACC,kBAAkB,GAAG,eAAgB,IAAIvH,GAAG,EAAE;cACnD,IAAI,CAACwH,sBAAsB,GAAG,CAAC;cAC/B,MAAMC,QAAQ,GAAG,CAACC,IAAI,EAAEC,CAAC,KAAK;gBAC5B,IAAI,CAACC,GAAG,CAACC,SAAS,CAACH,IAAI,GAAG,CAAC,EAAEC,CAAC,EAAE,IAAI,CAAC;gBACrC,IAAI,CAACC,GAAG,CAACC,SAAS,CAACH,IAAI,GAAG,CAAC,EAAEI,IAAI,CAACC,KAAK,CAACJ,CAAC,GAAG,UAAU,CAAC,EAAE,IAAI,CAAC;cAChE,CAAC;cACD,MAAMK,QAAQ,GAAIN,IAAI,IAAK;gBACzB,MAAMO,GAAG,GAAG,IAAI,CAACL,GAAG,CAACM,SAAS,CAACR,IAAI,GAAG,CAAC,EAAE,IAAI,CAAC;gBAC9C,MAAMS,IAAI,GAAG,IAAI,CAACP,GAAG,CAACQ,QAAQ,CAACV,IAAI,GAAG,CAAC,EAAE,IAAI,CAAC;gBAC9C,OAAOO,GAAG,GAAGE,IAAI,GAAG,UAAU;cAChC,CAAC;cACD,MAAME,SAAS,GAAIX,IAAI,IAAK;gBAC1B,MAAMY,CAAC,GAAG,IAAI,CAACV,GAAG,CAACW,UAAU,CAACb,IAAI,EAAE,IAAI,CAAC;gBACzC,IAAIY,CAAC,KAAK,CAAC,EAAE;kBACX,OAAO,KAAK,CAAC;gBACf;gBACA,IAAI,CAACE,KAAK,CAACF,CAAC,CAAC,EAAE;kBACb,OAAOA,CAAC;gBACV;gBACA,MAAM9c,EAAE,GAAG,IAAI,CAACoc,GAAG,CAACM,SAAS,CAACR,IAAI,EAAE,IAAI,CAAC;gBACzC,OAAO,IAAI,CAACe,OAAO,CAACjd,EAAE,CAAC;cACzB,CAAC;cACD,MAAMkd,UAAU,GAAG,CAAChB,IAAI,EAAEC,CAAC,KAAK;gBAC9B,MAAMgB,OAAO,GAAG,UAAU;gBAC1B,IAAI,OAAOhB,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,CAAC,EAAE;kBACpC,IAAIa,KAAK,CAACb,CAAC,CAAC,EAAE;oBACZ,IAAI,CAACC,GAAG,CAACC,SAAS,CAACH,IAAI,GAAG,CAAC,EAAEiB,OAAO,EAAE,IAAI,CAAC;oBAC3C,IAAI,CAACf,GAAG,CAACC,SAAS,CAACH,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC;oBACjC;kBACF;kBACA,IAAI,CAACE,GAAG,CAACgB,UAAU,CAAClB,IAAI,EAAEC,CAAC,EAAE,IAAI,CAAC;kBAClC;gBACF;gBACA,IAAIA,CAAC,KAAK,KAAK,CAAC,EAAE;kBAChB,IAAI,CAACC,GAAG,CAACgB,UAAU,CAAClB,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC;kBAClC;gBACF;gBACA,IAAIlc,EAAE,GAAG,IAAI,CAACqd,IAAI,CAAC/gB,GAAG,CAAC6f,CAAC,CAAC;gBACzB,IAAInc,EAAE,KAAK,KAAK,CAAC,EAAE;kBACjBA,EAAE,GAAG,IAAI,CAACsd,OAAO,CAACC,GAAG,EAAE;kBACvB,IAAIvd,EAAE,KAAK,KAAK,CAAC,EAAE;oBACjBA,EAAE,GAAG,IAAI,CAACid,OAAO,CAACrd,MAAM;kBAC1B;kBACA,IAAI,CAACqd,OAAO,CAACjd,EAAE,CAAC,GAAGmc,CAAC;kBACpB,IAAI,CAACqB,YAAY,CAACxd,EAAE,CAAC,GAAG,CAAC;kBACzB,IAAI,CAACqd,IAAI,CAAC/b,GAAG,CAAC6a,CAAC,EAAEnc,EAAE,CAAC;gBACtB;gBACA,IAAI,CAACwd,YAAY,CAACxd,EAAE,CAAC,EAAE;gBACvB,IAAIyd,QAAQ,GAAG,CAAC;gBAChB,QAAQ,OAAOtB,CAAC;kBACd,KAAK,QAAQ;oBACX,IAAIA,CAAC,KAAK,IAAI,EAAE;sBACdsB,QAAQ,GAAG,CAAC;oBACd;oBACA;kBACF,KAAK,QAAQ;oBACXA,QAAQ,GAAG,CAAC;oBACZ;kBACF,KAAK,QAAQ;oBACXA,QAAQ,GAAG,CAAC;oBACZ;kBACF,KAAK,UAAU;oBACbA,QAAQ,GAAG,CAAC;oBACZ;gBAAM;gBAEV,IAAI,CAACrB,GAAG,CAACC,SAAS,CAACH,IAAI,GAAG,CAAC,EAAEiB,OAAO,GAAGM,QAAQ,EAAE,IAAI,CAAC;gBACtD,IAAI,CAACrB,GAAG,CAACC,SAAS,CAACH,IAAI,EAAElc,EAAE,EAAE,IAAI,CAAC;cACpC,CAAC;cACD,MAAM0d,SAAS,GAAIxB,IAAI,IAAK;gBAC1B,MAAMyB,KAAK,GAAGnB,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC;gBAChC,MAAM9b,GAAG,GAAGoc,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC;gBAC9B,OAAO,IAAIxc,UAAU,CAAC,IAAI,CAACke,KAAK,CAAC3e,OAAO,CAACmd,GAAG,CAACla,MAAM,EAAEyb,KAAK,EAAEvd,GAAG,CAAC;cAClE,CAAC;cACD,MAAMyd,iBAAiB,GAAI3B,IAAI,IAAK;gBAClC,MAAMyB,KAAK,GAAGnB,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC;gBAChC,MAAM9b,GAAG,GAAGoc,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC;gBAC9B,MAAM4B,CAAC,GAAG,IAAIne,KAAK,CAACS,GAAG,CAAC;gBACxB,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,GAAG,EAAEU,CAAC,EAAE,EAAE;kBAC5Bgd,CAAC,CAAChd,CAAC,CAAC,GAAG+b,SAAS,CAACc,KAAK,GAAG7c,CAAC,GAAG,CAAC,CAAC;gBACjC;gBACA,OAAOgd,CAAC;cACV,CAAC;cACD,MAAMC,UAAU,GAAI7B,IAAI,IAAK;gBAC3B,MAAM8B,KAAK,GAAGxB,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC;gBAChC,MAAM9b,GAAG,GAAGoc,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC;gBAC9B,OAAOra,OAAO,CAACG,MAAM,CAAC,IAAIic,QAAQ,CAAC,IAAI,CAACL,KAAK,CAAC3e,OAAO,CAACmd,GAAG,CAACla,MAAM,EAAE8b,KAAK,EAAE5d,GAAG,CAAC,CAAC;cAChF,CAAC;cACD,MAAM8d,UAAU,GAAGC,IAAI,CAACC,GAAG,EAAE,GAAG9C,WAAW,CAAC8C,GAAG,EAAE;cACjD,IAAI,CAACC,YAAY,GAAG;gBAClBC,EAAE,EAAE;kBACF,kBAAkB,EAAGC,EAAE,IAAK;oBAC1BA,EAAE,MAAM,CAAC;oBACT,MAAM/P,IAAI,GAAG,IAAI,CAAC4N,GAAG,CAACQ,QAAQ,CAAC2B,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;oBAC5C,IAAI,CAACC,MAAM,GAAG,IAAI;oBAClB,OAAO,IAAI,CAACZ,KAAK;oBACjB,OAAO,IAAI,CAACX,OAAO;oBACnB,OAAO,IAAI,CAACO,YAAY;oBACxB,OAAO,IAAI,CAACH,IAAI;oBAChB,OAAO,IAAI,CAACC,OAAO;oBACnB,IAAI,CAAC5B,IAAI,CAAClN,IAAI,CAAC;kBACjB,CAAC;kBACD,mBAAmB,EAAG+P,EAAE,IAAK;oBAC3BA,EAAE,MAAM,CAAC;oBACT,MAAM/F,EAAE,GAAGgE,QAAQ,CAAC+B,EAAE,GAAG,CAAC,CAAC;oBAC3B,MAAME,CAAC,GAAGjC,QAAQ,CAAC+B,EAAE,GAAG,EAAE,CAAC;oBAC3B,MAAM1F,CAAC,GAAG,IAAI,CAACuD,GAAG,CAACQ,QAAQ,CAAC2B,EAAE,GAAG,EAAE,EAAE,IAAI,CAAC;oBAC1C9G,UAAU,CAAC3J,EAAE,CAACyK,SAAS,CAACC,EAAE,EAAE,IAAI9Y,UAAU,CAAC,IAAI,CAACke,KAAK,CAAC3e,OAAO,CAACmd,GAAG,CAACla,MAAM,EAAEuc,CAAC,EAAE5F,CAAC,CAAC,CAAC;kBAClF,CAAC;kBACD,6BAA6B,EAAG0F,EAAE,IAAK;oBACrCA,EAAE,MAAM,CAAC;oBACT,IAAI,CAACnC,GAAG,GAAG,IAAI6B,QAAQ,CAAC,IAAI,CAACL,KAAK,CAAC3e,OAAO,CAACmd,GAAG,CAACla,MAAM,CAAC;kBACxD,CAAC;kBACD,mBAAmB,EAAGqc,EAAE,IAAK;oBAC3BA,EAAE,MAAM,CAAC;oBACTtC,QAAQ,CAACsC,EAAE,GAAG,CAAC,EAAE,CAACL,UAAU,GAAG5C,WAAW,CAAC8C,GAAG,EAAE,IAAI,GAAG,CAAC;kBAC1D,CAAC;kBACD,kBAAkB,EAAGG,EAAE,IAAK;oBAC1BA,EAAE,MAAM,CAAC;oBACT,MAAMG,IAAI,GAAG,IAAIP,IAAI,EAAE,CAACQ,OAAO,EAAE;oBACjC1C,QAAQ,CAACsC,EAAE,GAAG,CAAC,EAAEG,IAAI,GAAG,GAAG,CAAC;oBAC5B,IAAI,CAACtC,GAAG,CAACwC,QAAQ,CAACL,EAAE,GAAG,EAAE,EAAEG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC;kBACpD,CAAC;kBACD,8BAA8B,EAAGH,EAAE,IAAK;oBACtCA,EAAE,MAAM,CAAC;oBACT,MAAMve,EAAE,GAAG,IAAI,CAACgc,sBAAsB;oBACtC,IAAI,CAACA,sBAAsB,EAAE;oBAC7B,IAAI,CAACD,kBAAkB,CAACza,GAAG,CAACtB,EAAE,EAAE6e,UAAU,CACxC,MAAM;sBACJ,IAAI,CAACC,OAAO,EAAE;sBACd,OAAO,IAAI,CAAC/C,kBAAkB,CAACgD,GAAG,CAAC/e,EAAE,CAAC,EAAE;wBACtC+Q,OAAO,CAAC4K,IAAI,CAAC,4CAA4C,CAAC;wBAC1D,IAAI,CAACmD,OAAO,EAAE;sBAChB;oBACF,CAAC,EACDtC,QAAQ,CAAC+B,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CACrB,CAAC;oBACF,IAAI,CAACnC,GAAG,CAACwC,QAAQ,CAACL,EAAE,GAAG,EAAE,EAAEve,EAAE,EAAE,IAAI,CAAC;kBACtC,CAAC;kBACD,2BAA2B,EAAGue,EAAE,IAAK;oBACnCA,EAAE,MAAM,CAAC;oBACT,MAAMve,EAAE,GAAG,IAAI,CAACoc,GAAG,CAACQ,QAAQ,CAAC2B,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;oBAC1CS,YAAY,CAAC,IAAI,CAACjD,kBAAkB,CAACzf,GAAG,CAAC0D,EAAE,CAAC,CAAC;oBAC7C,IAAI,CAAC+b,kBAAkB,CAACkD,MAAM,CAACjf,EAAE,CAAC;kBACpC,CAAC;kBACD,uBAAuB,EAAGue,EAAE,IAAK;oBAC/BA,EAAE,MAAM,CAAC;oBACTlD,MAAM,CAAC6D,eAAe,CAACxB,SAAS,CAACa,EAAE,GAAG,CAAC,CAAC,CAAC;kBAC3C,CAAC;kBACD,wBAAwB,EAAGA,EAAE,IAAK;oBAChCA,EAAE,MAAM,CAAC;oBACT,MAAMve,EAAE,GAAG,IAAI,CAACoc,GAAG,CAACM,SAAS,CAAC6B,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;oBAC3C,IAAI,CAACf,YAAY,CAACxd,EAAE,CAAC,EAAE;oBACvB,IAAI,IAAI,CAACwd,YAAY,CAACxd,EAAE,CAAC,KAAK,CAAC,EAAE;sBAC/B,MAAMmc,CAAC,GAAG,IAAI,CAACc,OAAO,CAACjd,EAAE,CAAC;sBAC1B,IAAI,CAACid,OAAO,CAACjd,EAAE,CAAC,GAAG,IAAI;sBACvB,IAAI,CAACqd,IAAI,CAAC4B,MAAM,CAAC9C,CAAC,CAAC;sBACnB,IAAI,CAACmB,OAAO,CAACvc,IAAI,CAACf,EAAE,CAAC;oBACvB;kBACF,CAAC;kBACD,sBAAsB,EAAGue,EAAE,IAAK;oBAC9BA,EAAE,MAAM,CAAC;oBACTrB,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAER,UAAU,CAACQ,EAAE,GAAG,CAAC,CAAC,CAAC;kBACzC,CAAC;kBACD,qBAAqB,EAAGA,EAAE,IAAK;oBAC7BA,EAAE,MAAM,CAAC;oBACT,MAAMhQ,MAAM,GAAG4Q,OAAO,CAAC7iB,GAAG,CAACugB,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,EAAER,UAAU,CAACQ,EAAE,GAAG,EAAE,CAAC,CAAC;oBAClEA,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;oBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAEhQ,MAAM,CAAC;kBAC7B,CAAC;kBACD,qBAAqB,EAAGgQ,EAAE,IAAK;oBAC7BA,EAAE,MAAM,CAAC;oBACTY,OAAO,CAAC7d,GAAG,CAACub,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,EAAER,UAAU,CAACQ,EAAE,GAAG,EAAE,CAAC,EAAE1B,SAAS,CAAC0B,EAAE,GAAG,EAAE,CAAC,CAAC;kBACzE,CAAC;kBACD,wBAAwB,EAAGA,EAAE,IAAK;oBAChCA,EAAE,MAAM,CAAC;oBACTY,OAAO,CAACE,cAAc,CAACxC,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,EAAER,UAAU,CAACQ,EAAE,GAAG,EAAE,CAAC,CAAC;kBAChE,CAAC;kBACD,uBAAuB,EAAGA,EAAE,IAAK;oBAC/BA,EAAE,MAAM,CAAC;oBACTrB,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAEY,OAAO,CAAC7iB,GAAG,CAACugB,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,EAAE/B,QAAQ,CAAC+B,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;kBACxE,CAAC;kBACD,0BAA0B,EAAGA,EAAE,IAAK;oBAClCA,EAAE,MAAM,CAAC;oBACTY,OAAO,CAAC7d,GAAG,CAACub,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,EAAE/B,QAAQ,CAAC+B,EAAE,GAAG,EAAE,CAAC,EAAE1B,SAAS,CAAC0B,EAAE,GAAG,EAAE,CAAC,CAAC;kBACvE,CAAC;kBACD,sBAAsB,EAAGA,EAAE,IAAK;oBAC9BA,EAAE,MAAM,CAAC;oBACT,IAAI;sBACF,MAAMpC,CAAC,GAAGU,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC;sBAC3B,MAAMe,CAAC,GAAGH,OAAO,CAAC7iB,GAAG,CAAC6f,CAAC,EAAE4B,UAAU,CAACQ,EAAE,GAAG,EAAE,CAAC,CAAC;sBAC7C,MAAMxM,IAAI,GAAG8L,iBAAiB,CAACU,EAAE,GAAG,EAAE,CAAC;sBACvC,MAAMhQ,MAAM,GAAG4Q,OAAO,CAACjhB,KAAK,CAACohB,CAAC,EAAEnD,CAAC,EAAEpK,IAAI,CAAC;sBACxCwM,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;sBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAEhQ,MAAM,CAAC;sBAC3B,IAAI,CAAC6N,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;oBAC/B,CAAC,CAAC,OAAO7Q,GAAG,EAAE;sBACZ6Q,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;sBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAE7Q,GAAG,CAAC;sBACxB,IAAI,CAAC0O,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;oBAC/B;kBACF,CAAC;kBACD,wBAAwB,EAAGA,EAAE,IAAK;oBAChCA,EAAE,MAAM,CAAC;oBACT,IAAI;sBACF,MAAMpC,CAAC,GAAGU,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC;sBAC3B,MAAMxM,IAAI,GAAG8L,iBAAiB,CAACU,EAAE,GAAG,EAAE,CAAC;sBACvC,MAAMhQ,MAAM,GAAG4Q,OAAO,CAACjhB,KAAK,CAACie,CAAC,EAAE,KAAK,CAAC,EAAEpK,IAAI,CAAC;sBAC7CwM,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;sBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAEhQ,MAAM,CAAC;sBAC3B,IAAI,CAAC6N,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;oBAC/B,CAAC,CAAC,OAAO7Q,GAAG,EAAE;sBACZ6Q,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;sBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAE7Q,GAAG,CAAC;sBACxB,IAAI,CAAC0O,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;oBAC/B;kBACF,CAAC;kBACD,qBAAqB,EAAGA,EAAE,IAAK;oBAC7BA,EAAE,MAAM,CAAC;oBACT,IAAI;sBACF,MAAMpC,CAAC,GAAGU,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC;sBAC3B,MAAMxM,IAAI,GAAG8L,iBAAiB,CAACU,EAAE,GAAG,EAAE,CAAC;sBACvC,MAAMhQ,MAAM,GAAG4Q,OAAO,CAACK,SAAS,CAACrD,CAAC,EAAEpK,IAAI,CAAC;sBACzCwM,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;sBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAEhQ,MAAM,CAAC;sBAC3B,IAAI,CAAC6N,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;oBAC/B,CAAC,CAAC,OAAO7Q,GAAG,EAAE;sBACZ6Q,EAAE,GAAG,IAAI,CAACX,KAAK,CAAC3e,OAAO,CAACmgB,KAAK,EAAE,KAAK,CAAC;sBACrClC,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAE7Q,GAAG,CAAC;sBACxB,IAAI,CAAC0O,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;oBAC/B;kBACF,CAAC;kBACD,wBAAwB,EAAGA,EAAE,IAAK;oBAChCA,EAAE,MAAM,CAAC;oBACTtC,QAAQ,CAACsC,EAAE,GAAG,EAAE,EAAEkB,QAAQ,CAAC5C,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,CAAC3e,MAAM,CAAC,CAAC;kBACvD,CAAC;kBACD,+BAA+B,EAAG2e,EAAE,IAAK;oBACvCA,EAAE,MAAM,CAAC;oBACT,MAAMmB,GAAG,GAAG9d,OAAO,CAACG,MAAM,CAACkL,MAAM,CAAC4P,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;oBACrDrB,UAAU,CAACqB,EAAE,GAAG,EAAE,EAAEmB,GAAG,CAAC;oBACxBzD,QAAQ,CAACsC,EAAE,GAAG,EAAE,EAAEmB,GAAG,CAAC9f,MAAM,CAAC;kBAC/B,CAAC;kBACD,4BAA4B,EAAG2e,EAAE,IAAK;oBACpCA,EAAE,MAAM,CAAC;oBACT,MAAMmB,GAAG,GAAG7C,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC;oBAC7Bb,SAAS,CAACa,EAAE,GAAG,EAAE,CAAC,CAACjd,GAAG,CAACoe,GAAG,CAAC;kBAC7B,CAAC;kBACD,4BAA4B,EAAGnB,EAAE,IAAK;oBACpCA,EAAE,MAAM,CAAC;oBACT,IAAI,CAACnC,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE1B,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC,YAAY1B,SAAS,CAAC0B,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;kBACrF,CAAC;kBACD,0BAA0B,EAAGA,EAAE,IAAK;oBAClCA,EAAE,MAAM,CAAC;oBACT,MAAMoB,GAAG,GAAGjC,SAAS,CAACa,EAAE,GAAG,CAAC,CAAC;oBAC7B,MAAMqB,GAAG,GAAG/C,SAAS,CAAC0B,EAAE,GAAG,EAAE,CAAC;oBAC9B,IAAI,EAAEqB,GAAG,YAAYlgB,UAAU,IAAIkgB,GAAG,YAAYC,iBAAiB,CAAC,EAAE;sBACpE,IAAI,CAACzD,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;sBAC7B;oBACF;oBACA,MAAMuB,MAAM,GAAGF,GAAG,CAACvf,QAAQ,CAAC,CAAC,EAAEsf,GAAG,CAAC/f,MAAM,CAAC;oBAC1C+f,GAAG,CAACre,GAAG,CAACwe,MAAM,CAAC;oBACf7D,QAAQ,CAACsC,EAAE,GAAG,EAAE,EAAEuB,MAAM,CAAClgB,MAAM,CAAC;oBAChC,IAAI,CAACwc,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;kBAC/B,CAAC;kBACD,0BAA0B,EAAGA,EAAE,IAAK;oBAClCA,EAAE,MAAM,CAAC;oBACT,MAAMoB,GAAG,GAAG9C,SAAS,CAAC0B,EAAE,GAAG,CAAC,CAAC;oBAC7B,MAAMqB,GAAG,GAAGlC,SAAS,CAACa,EAAE,GAAG,EAAE,CAAC;oBAC9B,IAAI,EAAEoB,GAAG,YAAYjgB,UAAU,IAAIigB,GAAG,YAAYE,iBAAiB,CAAC,EAAE;sBACpE,IAAI,CAACzD,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;sBAC7B;oBACF;oBACA,MAAMuB,MAAM,GAAGF,GAAG,CAACvf,QAAQ,CAAC,CAAC,EAAEsf,GAAG,CAAC/f,MAAM,CAAC;oBAC1C+f,GAAG,CAACre,GAAG,CAACwe,MAAM,CAAC;oBACf7D,QAAQ,CAACsC,EAAE,GAAG,EAAE,EAAEuB,MAAM,CAAClgB,MAAM,CAAC;oBAChC,IAAI,CAACwc,GAAG,CAACmD,QAAQ,CAAChB,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;kBAC/B,CAAC;kBACD,OAAO,EAAGthB,KAAK,IAAK;oBAClB8T,OAAO,CAACC,GAAG,CAAC/T,KAAK,CAAC;kBACpB;gBACF;cACF,CAAC;YACH;YACA8iB,GAAG,CAACC,QAAQ,EAAE;cACZ,OAAO9iB,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,aAAa;gBACtC,IAAI,EAAE8iB,QAAQ,YAAY1c,WAAW,CAAC2c,QAAQ,CAAC,EAAE;kBAC/C,MAAM,IAAIjf,KAAK,CAAC,uCAAuC,CAAC;gBAC1D;gBACA,IAAI,CAAC4c,KAAK,GAAGoC,QAAQ;gBACrB,IAAI,CAAC5D,GAAG,GAAG,IAAI6B,QAAQ,CAAC,IAAI,CAACL,KAAK,CAAC3e,OAAO,CAACmd,GAAG,CAACla,MAAM,CAAC;gBACtD,IAAI,CAAC+a,OAAO,GAAG,CACbiD,GAAG,EACH,CAAC,EACD,IAAI,EACJ,IAAI,EACJ,KAAK,EACLzI,UAAU,EACV,IAAI,CACL;gBACD,IAAI,CAAC+F,YAAY,GAAG,IAAI7d,KAAK,CAAC,IAAI,CAACsd,OAAO,CAACrd,MAAM,CAAC,CAACugB,IAAI,CAACC,QAAQ,CAAC;gBACjE,IAAI,CAAC/C,IAAI,GAAG,eAAgB,IAAI7I,GAAG,CAAC,CAClC,CAAC,CAAC,EAAE,CAAC,CAAC,EACN,CAAC,IAAI,EAAE,CAAC,CAAC,EACT,CAAC,IAAI,EAAE,CAAC,CAAC,EACT,CAAC,KAAK,EAAE,CAAC,CAAC,EACV,CAACiD,UAAU,EAAE,CAAC,CAAC,EACf,CAAC,IAAI,EAAE,CAAC,CAAC,CACV,CAAC;gBACF,IAAI,CAAC6F,OAAO,GAAG,EAAE;gBACjB,IAAI,CAACkB,MAAM,GAAG,KAAK;gBACnB,IAAIjd,MAAM,GAAG,IAAI;gBACjB,MAAM8e,MAAM,GAAIX,GAAG,IAAK;kBACtB,MAAMze,GAAG,GAAGM,MAAM;kBAClB,MAAMhB,KAAK,GAAGqB,OAAO,CAACG,MAAM,CAAC2d,GAAG,GAAG,IAAI,CAAC;kBACxC,IAAIhgB,UAAU,CAAC,IAAI,CAAC0c,GAAG,CAACla,MAAM,EAAEX,MAAM,EAAEhB,KAAK,CAACX,MAAM,CAAC,CAAC0B,GAAG,CAACf,KAAK,CAAC;kBAChEgB,MAAM,IAAIhB,KAAK,CAACX,MAAM;kBACtB,IAAI2B,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;oBACpBA,MAAM,IAAI,CAAC,GAAGA,MAAM,GAAG,CAAC;kBAC1B;kBACA,OAAON,GAAG;gBACZ,CAAC;gBACD,MAAMqf,IAAI,GAAG,IAAI,CAAC9E,IAAI,CAAC5b,MAAM;gBAC7B,MAAM2gB,QAAQ,GAAG,EAAE;gBACnB,IAAI,CAAC/E,IAAI,CAACgF,OAAO,CAAEC,GAAG,IAAK;kBACzBF,QAAQ,CAACxf,IAAI,CAACsf,MAAM,CAACI,GAAG,CAAC,CAAC;gBAC5B,CAAC,CAAC;gBACFF,QAAQ,CAACxf,IAAI,CAAC,CAAC,CAAC;gBAChB,MAAMjB,IAAI,GAAGrE,MAAM,CAACqE,IAAI,CAAC,IAAI,CAAC2b,GAAG,CAAC,CAACiF,IAAI,EAAE;gBACzC5gB,IAAI,CAAC0gB,OAAO,CAAE3jB,GAAG,IAAK;kBACpB0jB,QAAQ,CAACxf,IAAI,CAACsf,MAAM,CAAE,GAAExjB,GAAI,IAAG,IAAI,CAAC4e,GAAG,CAAC5e,GAAG,CAAE,EAAC,CAAC,CAAC;gBAClD,CAAC,CAAC;gBACF0jB,QAAQ,CAACxf,IAAI,CAAC,CAAC,CAAC;gBAChB,MAAMya,IAAI,GAAGja,MAAM;gBACnBgf,QAAQ,CAACC,OAAO,CAAEvf,GAAG,IAAK;kBACxB,IAAI,CAACmb,GAAG,CAACC,SAAS,CAAC9a,MAAM,EAAEN,GAAG,EAAE,IAAI,CAAC;kBACrC,IAAI,CAACmb,GAAG,CAACC,SAAS,CAAC9a,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC;kBACvCA,MAAM,IAAI,CAAC;gBACb,CAAC,CAAC;gBACF,MAAMof,eAAe,GAAG,IAAI,GAAG,IAAI;gBACnC,IAAIpf,MAAM,IAAIof,eAAe,EAAE;kBAC7B,MAAM,IAAI3f,KAAK,CAAC,sEAAsE,CAAC;gBACzF;gBACA,IAAI,CAAC4c,KAAK,CAAC3e,OAAO,CAAC8gB,GAAG,CAACO,IAAI,EAAE9E,IAAI,CAAC;gBAClC,IAAI,IAAI,CAACgD,MAAM,EAAE;kBACf,IAAI,CAAC3C,mBAAmB,EAAE;gBAC5B;gBACA,MAAM,IAAI,CAACD,YAAY;cACzB,CAAC,CAAC;YACJ;YACAkD,OAAO,GAAG;cACR,IAAI,IAAI,CAACN,MAAM,EAAE;gBACf,MAAM,IAAIxd,KAAK,CAAC,+BAA+B,CAAC;cAClD;cACA,IAAI,CAAC4c,KAAK,CAAC3e,OAAO,CAAC2hB,MAAM,EAAE;cAC3B,IAAI,IAAI,CAACpC,MAAM,EAAE;gBACf,IAAI,CAAC3C,mBAAmB,EAAE;cAC5B;YACF;YACAgF,gBAAgB,CAAC7gB,EAAE,EAAE;cACnB,MAAMse,EAAE,GAAG,IAAI;cACf,OAAO,YAAW;gBAChB,MAAMwC,KAAK,GAAG;kBAAE9gB,EAAE;kBAAE+gB,IAAI,EAAE,IAAI;kBAAEhP,IAAI,EAAEiP;gBAAU,CAAC;gBACjD1C,EAAE,CAACxC,aAAa,GAAGgF,KAAK;gBACxBxC,EAAE,CAACQ,OAAO,EAAE;gBACZ,OAAOgC,KAAK,CAACvS,MAAM;cACrB,CAAC;YACH;UACF,CAAC;QACH,CAAC,GAAG;QACJgJ,SAAS,GAAG,CAAC;UAAE0J,IAAI,EAAElK;QAAK,CAAC,KAAK;UAC9B,IAAIlV,OAAO,GAAG,IAAIF,WAAW,EAAE;UAC/B,IAAImM,EAAE,GAAG2J,UAAU,CAAC3J,EAAE;UACtB,IAAIoT,MAAM,GAAG,EAAE;UACfpT,EAAE,CAACyK,SAAS,GAAG,CAACC,EAAE,EAAEtW,MAAM,KAAK;YAC7B,IAAIsW,EAAE,KAAK,CAAC,EAAE;cACZhB,WAAW,CAACtV,MAAM,CAAC;YACrB,CAAC,MAAM,IAAIsW,EAAE,KAAK,CAAC,EAAE;cACnB0I,MAAM,IAAIrf,OAAO,CAACG,MAAM,CAACE,MAAM,CAAC;cAChC,IAAIif,KAAK,GAAGD,MAAM,CAACpM,KAAK,CAAC,IAAI,CAAC;cAC9B,IAAIqM,KAAK,CAACvhB,MAAM,GAAG,CAAC,EAClBmR,OAAO,CAACC,GAAG,CAACmQ,KAAK,CAAC7L,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAClO,IAAI,CAAC,IAAI,CAAC,CAAC;cAC5C8Z,MAAM,GAAGC,KAAK,CAACA,KAAK,CAACvhB,MAAM,GAAG,CAAC,CAAC;YAClC,CAAC,MAAM;cACL,MAAM,IAAIoB,KAAK,CAAC,WAAW,CAAC;YAC9B;YACA,OAAOkB,MAAM,CAACtC,MAAM;UACtB,CAAC;UACD,IAAI8J,KAAK,GAAG,EAAE;UACd,IAAI0X,WAAW;UACf,IAAIC,QAAQ,GAAG,CAAC;UAChB9J,SAAS,GAAG,CAAC;YAAE0J;UAAK,CAAC,KAAK;YACxB,IAAIA,IAAI,CAACrhB,MAAM,GAAG,CAAC,EAAE;cACnB8J,KAAK,CAAC3I,IAAI,CAACkgB,IAAI,CAAC;cAChB,IAAIG,WAAW,EACbA,WAAW,EAAE;YACjB;UACF,CAAC;UACDtT,EAAE,CAACnN,IAAI,GAAG,CAAC6X,EAAE,EAAEtW,MAAM,EAAEX,MAAM,EAAE3B,MAAM,EAAEgZ,QAAQ,EAAEzM,QAAQ,KAAK;YAC5D,IAAIqM,EAAE,KAAK,CAAC,IAAIjX,MAAM,KAAK,CAAC,IAAI3B,MAAM,KAAKsC,MAAM,CAACtC,MAAM,IAAIgZ,QAAQ,KAAK,IAAI,EAAE;cAC7E,MAAM,IAAI5X,KAAK,CAAC,UAAU,CAAC;YAC7B;YACA,IAAI0I,KAAK,CAAC9J,MAAM,KAAK,CAAC,EAAE;cACtBwhB,WAAW,GAAG,MAAMtT,EAAE,CAACnN,IAAI,CAAC6X,EAAE,EAAEtW,MAAM,EAAEX,MAAM,EAAE3B,MAAM,EAAEgZ,QAAQ,EAAEzM,QAAQ,CAAC;cAC3E;YACF;YACA,IAAImV,KAAK,GAAG5X,KAAK,CAAC,CAAC,CAAC;YACpB,IAAI9I,KAAK,GAAG0b,IAAI,CAACiF,GAAG,CAAC,CAAC,EAAEjF,IAAI,CAACkF,GAAG,CAAC5hB,MAAM,EAAE0hB,KAAK,CAAC1hB,MAAM,GAAGyhB,QAAQ,CAAC,CAAC;YAClEnf,MAAM,CAACZ,GAAG,CAACggB,KAAK,CAACjhB,QAAQ,CAACghB,QAAQ,EAAEA,QAAQ,GAAGzgB,KAAK,CAAC,EAAEW,MAAM,CAAC;YAC9D8f,QAAQ,IAAIzgB,KAAK;YACjB,IAAIygB,QAAQ,KAAKC,KAAK,CAAC1hB,MAAM,EAAE;cAC7B8J,KAAK,CAAC+X,KAAK,EAAE;cACbJ,QAAQ,GAAG,CAAC;YACd;YACAlV,QAAQ,CAAC,IAAI,EAAEvL,KAAK,CAAC;UACvB,CAAC;UACD,IAAI0d,EAAE,GAAG,IAAI7G,UAAU,CAAC8D,EAAE,EAAE;UAC5B+C,EAAE,CAAC9C,IAAI,GAAG,CAAC,EAAE,EAAG,aAAY,SAAU,EAAC,CAAC;UACxC,IAAIzE,IAAI,YAAYzT,WAAW,CAACC,MAAM,EAAE;YACtCD,WAAW,CAACoe,WAAW,CAAC3K,IAAI,EAAEuH,EAAE,CAACD,YAAY,CAAC,CAACpgB,IAAI,CAAE+hB,QAAQ,IAAK1B,EAAE,CAACyB,GAAG,CAACC,QAAQ,CAAC,CAAC;UACrF,CAAC,MAAM;YACL1c,WAAW,CAACoe,WAAW,CAAC3K,IAAI,EAAEuH,EAAE,CAACD,YAAY,CAAC,CAACpgB,IAAI,CAAC,CAAC;cAAE+hB;YAAS,CAAC,KAAK1B,EAAE,CAACyB,GAAG,CAACC,QAAQ,CAAC,CAAC;UACzF;QACF,CAAC;QACD,OAAQV,CAAC,IAAK/H,SAAS,CAAC+H,CAAC,CAAC;MAC5B,CAAC,EAAG2B,IAAI,IAAKxc,MAAM,CAAC8S,SAAS,CAAC;QAAE0J;MAAK,CAAC,CAAC,CAAC;MACxCxc,MAAM,GAAG;QACP8S,SAAS,EAAE,IAAI;QACfC,WAAW,EAAGyJ,IAAI,IAAKpC,UAAU,CAAC,MAAMtH,SAAS,CAAC;UAAE0J;QAAK,CAAC,CAAC,CAAC;QAC5DU,SAAS,GAAG,CACZ;MACF,CAAC;IACH;IACAld,MAAM,CAAC+S,WAAW,CAACT,IAAI,CAAC;IACxBtS,MAAM,CAAC8S,SAAS,GAAG,CAAC;MAAE0J;IAAK,CAAC,KAAKzV,cAAc,CAACyV,IAAI,CAAC;IACrD,IAAI;MAAEzV,cAAc;MAAEiE;IAAQ,CAAC,GAAG5E,aAAa,CAAC;MAC9C0B,YAAY,CAAChM,KAAK,EAAE;QAClBkE,MAAM,CAAC+S,WAAW,CAACjX,KAAK,CAAC;MAC3B,CAAC;MACDuP,MAAM,EAAE,KAAK;MACbO,kBAAkB,EAAE,IAAI;MACxB4D,OAAO,EAAE9V;IACX,CAAC,CAAC;IACFwY,gBAAgB,GAAG;MACjBrY,KAAK,EAAG+F,OAAO,IAAK,IAAI/G,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAKiS,OAAO,CAACtC,YAAY,CAAC;QACxE1F,QAAQ,EAAE,OAAO;QACjByE,IAAI,EAAE,IAAI;QACVkB,YAAY,EAAE,IAAI;QAClB/I,OAAO;QACPY,KAAK,EAAE,KAAK;QACZoI,SAAS,EAAE,GAAG;QACdlB,QAAQ,EAAE,CAACuB,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGlQ,MAAM,CAACkQ,GAAG,CAAC,GAAGnQ,OAAO,CAACoQ,GAAG;MACzD,CAAC,CAAC,CAAC;MACH7O,SAAS,EAAE,CAAC+O,KAAK,EAAExJ,OAAO,KAAK,IAAI/G,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAKiS,OAAO,CAAC3Q,SAAS,CAAC;QAChF2I,QAAQ,EAAE,WAAW;QACrByE,IAAI,EAAE,IAAI;QACV2B,KAAK;QACLxJ,OAAO,EAAEA,OAAO,IAAI,CAAC,CAAC;QACtBY,KAAK,EAAE,KAAK;QACZ6I,EAAE,EAAE;UACFa,QAAQ,CAACiT,CAAC,EAAEzV,QAAQ,EAAE;YACpBA,QAAQ,CAAC,IAAInL,KAAK,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC;UAC7C,CAAC;UACDgO,SAAS,CAAC4S,CAAC,EAAEzV,QAAQ,EAAE;YACrBA,QAAQ,CAAC,IAAI,CAAC;UAChB;QACF,CAAC;QACDA,QAAQ,EAAE,CAACuB,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGlQ,MAAM,CAACkQ,GAAG,CAAC,GAAGnQ,OAAO,CAACoQ,GAAG;MACzD,CAAC,CAAC,CAAC;MACHjP,cAAc,EAAE,CAACwQ,QAAQ,EAAE7K,OAAO,KAAK,IAAI/G,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAKiS,OAAO,CAAC/Q,cAAc,CAAC;QAC7F+I,QAAQ,EAAE,gBAAgB;QAC1ByE,IAAI,EAAE,IAAI;QACVgD,QAAQ;QACR7K,OAAO;QACP8H,QAAQ,EAAE,CAACuB,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGlQ,MAAM,CAACkQ,GAAG,CAAC,GAAGnQ,OAAO,CAACoQ,GAAG;MACzD,CAAC,CAAC,CAAC;MACHvP,eAAe,EAAE,CAACiK,QAAQ,EAAEhE,OAAO,KAAK,IAAI/G,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAKiS,OAAO,CAACrR,eAAe,CAAC;QAC/FqJ,QAAQ,EAAE,iBAAiB;QAC3ByE,IAAI,EAAE,IAAI;QACV7D,QAAQ,EAAE,OAAOA,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAGxD,IAAI,CAACC,SAAS,CAACuD,QAAQ,CAAC;QAC5EhE,OAAO;QACP8H,QAAQ,EAAE,CAACuB,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGlQ,MAAM,CAACkQ,GAAG,CAAC,GAAGnQ,OAAO,CAACoQ,GAAG;MACzD,CAAC,CAAC;IACJ,CAAC;EACH,CAAC,CAAC;EACF,IAAIlP,eAAe,GAAGN,eAAe;AACrC,CAAC,EAAE,OAAO5C,MAAM,KAAG,QAAQ,GAACA,MAAM,GAAC;EAAC,IAAI0D,OAAO,CAAClB,CAAC,EAAC;IAAC,CAAC,OAAO4Z,IAAI,KAAG,WAAW,GAACA,IAAI,GAAC,IAAI,EAAE1D,OAAO,GAAClW,CAAC;EAAA;AAAC,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}