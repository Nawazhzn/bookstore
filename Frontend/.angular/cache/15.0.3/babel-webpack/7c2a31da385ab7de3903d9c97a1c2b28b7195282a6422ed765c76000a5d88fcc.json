{"ast":null,"code":"var Module = require('./module');\nvar autoAnnotate = require('./annotation').parse;\nvar Injector = function (modules, parent) {\n  parent = parent || {\n    get: function (name) {\n      currentlyResolving.push(name);\n      throw error('No provider for \"' + name + '\"!');\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  instances.injector = this;\n  var error = function (msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n  var get = function (name) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n      return pivot;\n    }\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Can not resolve circular dependency!');\n      }\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n    return parent.get(name);\n  };\n  var instantiate = function (Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n    return typeof returned === 'object' ? returned : instance;\n  };\n  var invoke = function (fn, context) {\n    if (typeof fn !== 'function') {\n      throw error('Can not invoke \"' + fn + '\". Expected a function!');\n    }\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function (dep) {\n      return get(dep);\n    });\n\n    // TODO(vojta): optimize without apply\n    return fn.apply(context, dependencies);\n  };\n  var createChild = function (modules, providersFromParent) {\n    if (providersFromParent && providersFromParent.length) {\n      var fromParentModule = Object.create(null);\n      providersFromParent.forEach(function (name) {\n        if (!providers[name]) {\n          throw new Error('No provider for \"' + name + '\". Can not use provider from the parent!');\n        }\n        fromParentModule[name] = [providers[name][2], providers[name][1]];\n      });\n      modules.unshift(fromParentModule);\n    }\n    return new Injector(modules, this);\n  };\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function (value) {\n      return value;\n    }\n  };\n  modules.forEach(function (module) {\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n        providers[name] = [factoryMap[type], value, type];\n      });\n    } else if (typeof module === 'object') {\n      Object.keys(module).forEach(function (name) {\n        var type = module[name][0];\n        var value = module[name][1];\n        providers[name] = [factoryMap[type], value, type];\n      });\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\nmodule.exports = Injector;","map":{"version":3,"names":["Module","require","autoAnnotate","parse","Injector","modules","parent","get","name","currentlyResolving","push","error","providers","_providers","Object","create","instances","_instances","injector","msg","stack","join","length","Error","indexOf","parts","split","pivot","shift","hasOwnProperty","call","pop","instantiate","Type","instance","prototype","returned","invoke","fn","context","inject","$inject","dependencies","map","dep","apply","createChild","providersFromParent","fromParentModule","forEach","unshift","factoryMap","factory","type","value","module","provider","keys","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/di/lib/injector.js"],"sourcesContent":["var Module = require('./module');\nvar autoAnnotate = require('./annotation').parse;\n\n\nvar Injector = function(modules, parent) {\n  parent = parent || {\n    get: function(name) {\n      currentlyResolving.push(name);\n      throw error('No provider for \"' + name + '\"!');\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  var get = function(name) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while(parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Can not resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name);\n  };\n\n  var instantiate = function(Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function(fn, context) {\n    if (typeof fn !== 'function') {\n      throw error('Can not invoke \"' + fn + '\". Expected a function!');\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function(dep) {\n      return get(dep);\n    });\n\n    // TODO(vojta): optimize without apply\n    return fn.apply(context, dependencies);\n  };\n\n  var createChild = function(modules, providersFromParent) {\n    if (providersFromParent && providersFromParent.length) {\n      var fromParentModule = Object.create(null);\n\n      providersFromParent.forEach(function(name) {\n        if (!providers[name]) {\n          throw new Error('No provider for \"' + name + '\". Can not use provider from the parent!');\n        }\n\n        fromParentModule[name] = [providers[name][2], providers[name][1]];\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, this);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], value, type];\n      });\n    } else if (typeof module === 'object') {\n      Object.keys(module).forEach(function(name) {\n        var type = module[name][0];\n        var value = module[name][1];\n\n        providers[name] = [factoryMap[type], value, type];\n      });\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}