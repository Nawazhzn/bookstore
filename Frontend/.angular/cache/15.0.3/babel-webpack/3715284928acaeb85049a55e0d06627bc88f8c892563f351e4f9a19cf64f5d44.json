{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BuilderWatchPlugin = void 0;\nclass TimeInfoMap extends Map {\n  update(path, timestamp) {\n    this.set(path, Object.freeze({\n      safeTime: timestamp,\n      timestamp\n    }));\n  }\n  toTimestamps() {\n    const timestamps = new Map();\n    for (const [file, entry] of this) {\n      timestamps.set(file, entry.timestamp);\n    }\n    return timestamps;\n  }\n}\nclass BuilderWatchFileSystem {\n  constructor(watcherFactory, inputFileSystem) {\n    this.watcherFactory = watcherFactory;\n    this.inputFileSystem = inputFileSystem;\n  }\n  watch(files, directories, missing, startTime, _options, callback, callbackUndelayed) {\n    const watchedFiles = new Set(files);\n    const watchedDirectories = new Set(directories);\n    const watchedMissing = new Set(missing);\n    const timeInfo = new TimeInfoMap();\n    for (const file of files) {\n      timeInfo.update(file, startTime);\n    }\n    for (const directory of directories) {\n      timeInfo.update(directory, startTime);\n    }\n    const watcher = this.watcherFactory.watch(files, directories, events => {\n      if (events.length === 0) {\n        return;\n      }\n      if (callbackUndelayed) {\n        process.nextTick(() => {\n          var _a;\n          return callbackUndelayed(events[0].path, (_a = events[0].time) !== null && _a !== void 0 ? _a : Date.now());\n        });\n      }\n      process.nextTick(() => {\n        var _a, _b, _c;\n        const removals = new Set();\n        const fileChanges = new Set();\n        const directoryChanges = new Set();\n        const missingChanges = new Set();\n        for (const event of events) {\n          (_b = (_a = this.inputFileSystem).purge) === null || _b === void 0 ? void 0 : _b.call(_a, event.path);\n          if (event.type === 'deleted') {\n            timeInfo.delete(event.path);\n            removals.add(event.path);\n          } else {\n            timeInfo.update(event.path, (_c = event.time) !== null && _c !== void 0 ? _c : Date.now());\n            if (watchedFiles.has(event.path)) {\n              fileChanges.add(event.path);\n            } else if (watchedDirectories.has(event.path)) {\n              directoryChanges.add(event.path);\n            } else if (watchedMissing.has(event.path)) {\n              missingChanges.add(event.path);\n            }\n          }\n        }\n        const timeInfoMap = new Map(timeInfo);\n        callback(undefined, timeInfoMap, timeInfoMap, new Set([...fileChanges, ...directoryChanges, ...missingChanges]), removals);\n      });\n    });\n    return {\n      close() {\n        watcher.close();\n      },\n      pause() {},\n      getFileTimeInfoEntries() {\n        return new Map(timeInfo);\n      },\n      getContextTimeInfoEntries() {\n        return new Map(timeInfo);\n      }\n    };\n  }\n}\nclass BuilderWatchPlugin {\n  constructor(watcherFactory) {\n    this.watcherFactory = watcherFactory;\n  }\n  apply(compiler) {\n    compiler.hooks.environment.tap('BuilderWatchPlugin', () => {\n      compiler.watchFileSystem = new BuilderWatchFileSystem(this.watcherFactory, compiler.inputFileSystem);\n    });\n  }\n}\nexports.BuilderWatchPlugin = BuilderWatchPlugin;","map":{"version":3,"names":["Object","defineProperty","exports","value","BuilderWatchPlugin","TimeInfoMap","Map","update","path","timestamp","set","freeze","safeTime","toTimestamps","timestamps","file","entry","BuilderWatchFileSystem","constructor","watcherFactory","inputFileSystem","watch","files","directories","missing","startTime","_options","callback","callbackUndelayed","watchedFiles","Set","watchedDirectories","watchedMissing","timeInfo","directory","watcher","events","length","process","nextTick","_a","time","Date","now","_b","_c","removals","fileChanges","directoryChanges","missingChanges","event","purge","call","type","delete","add","has","timeInfoMap","undefined","close","pause","getFileTimeInfoEntries","getContextTimeInfoEntries","apply","compiler","hooks","environment","tap","watchFileSystem"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@angular-devkit/build-angular/src/webpack/plugins/builder-watch-plugin.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BuilderWatchPlugin = void 0;\nclass TimeInfoMap extends Map {\n    update(path, timestamp) {\n        this.set(path, Object.freeze({ safeTime: timestamp, timestamp }));\n    }\n    toTimestamps() {\n        const timestamps = new Map();\n        for (const [file, entry] of this) {\n            timestamps.set(file, entry.timestamp);\n        }\n        return timestamps;\n    }\n}\nclass BuilderWatchFileSystem {\n    constructor(watcherFactory, inputFileSystem) {\n        this.watcherFactory = watcherFactory;\n        this.inputFileSystem = inputFileSystem;\n    }\n    watch(files, directories, missing, startTime, _options, callback, callbackUndelayed) {\n        const watchedFiles = new Set(files);\n        const watchedDirectories = new Set(directories);\n        const watchedMissing = new Set(missing);\n        const timeInfo = new TimeInfoMap();\n        for (const file of files) {\n            timeInfo.update(file, startTime);\n        }\n        for (const directory of directories) {\n            timeInfo.update(directory, startTime);\n        }\n        const watcher = this.watcherFactory.watch(files, directories, (events) => {\n            if (events.length === 0) {\n                return;\n            }\n            if (callbackUndelayed) {\n                process.nextTick(() => { var _a; return callbackUndelayed(events[0].path, (_a = events[0].time) !== null && _a !== void 0 ? _a : Date.now()); });\n            }\n            process.nextTick(() => {\n                var _a, _b, _c;\n                const removals = new Set();\n                const fileChanges = new Set();\n                const directoryChanges = new Set();\n                const missingChanges = new Set();\n                for (const event of events) {\n                    (_b = (_a = this.inputFileSystem).purge) === null || _b === void 0 ? void 0 : _b.call(_a, event.path);\n                    if (event.type === 'deleted') {\n                        timeInfo.delete(event.path);\n                        removals.add(event.path);\n                    }\n                    else {\n                        timeInfo.update(event.path, (_c = event.time) !== null && _c !== void 0 ? _c : Date.now());\n                        if (watchedFiles.has(event.path)) {\n                            fileChanges.add(event.path);\n                        }\n                        else if (watchedDirectories.has(event.path)) {\n                            directoryChanges.add(event.path);\n                        }\n                        else if (watchedMissing.has(event.path)) {\n                            missingChanges.add(event.path);\n                        }\n                    }\n                }\n                const timeInfoMap = new Map(timeInfo);\n                callback(undefined, timeInfoMap, timeInfoMap, new Set([...fileChanges, ...directoryChanges, ...missingChanges]), removals);\n            });\n        });\n        return {\n            close() {\n                watcher.close();\n            },\n            pause() { },\n            getFileTimeInfoEntries() {\n                return new Map(timeInfo);\n            },\n            getContextTimeInfoEntries() {\n                return new Map(timeInfo);\n            },\n        };\n    }\n}\nclass BuilderWatchPlugin {\n    constructor(watcherFactory) {\n        this.watcherFactory = watcherFactory;\n    }\n    apply(compiler) {\n        compiler.hooks.environment.tap('BuilderWatchPlugin', () => {\n            compiler.watchFileSystem = new BuilderWatchFileSystem(this.watcherFactory, compiler.inputFileSystem);\n        });\n    }\n}\nexports.BuilderWatchPlugin = BuilderWatchPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}