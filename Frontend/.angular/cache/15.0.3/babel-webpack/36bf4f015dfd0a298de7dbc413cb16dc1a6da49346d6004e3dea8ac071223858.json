{"ast":null,"code":"\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst valueParser = require(\"postcss-value-parser\");\nconst {\n  extractICSS\n} = require(\"icss-utils\");\nconst isSpacing = node => node.type === \"combinator\" && node.value === \" \";\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n  nodes.forEach(x => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(item => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n    let newNodes;\n    switch (node.type) {\n      case \"root\":\n        {\n          let resultingGlobal;\n          context.hasPureGlobals = false;\n          newNodes = node.nodes.map(n => {\n            const nContext = {\n              global: context.global,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: false\n            };\n            n = transform(n, nContext);\n            if (typeof resultingGlobal === \"undefined\") {\n              resultingGlobal = nContext.global;\n            } else if (resultingGlobal !== nContext.global) {\n              throw new Error('Inconsistent rule global/local result in rule \"' + node + '\" (multiple selectors must result in the same mode for the rule)');\n            }\n            if (!nContext.hasLocals) {\n              context.hasPureGlobals = true;\n            }\n            return n;\n          });\n          context.global = resultingGlobal;\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n      case \"selector\":\n        {\n          newNodes = node.map(childNode => transform(childNode, context));\n          node = node.clone();\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n      case \"combinator\":\n        {\n          if (isSpacing(node)) {\n            if (context.ignoreNextSpacing) {\n              context.ignoreNextSpacing = false;\n              context.lastWasSpacing = false;\n              context.enforceNoSpacing = false;\n              return null;\n            }\n            context.lastWasSpacing = true;\n            return node;\n          }\n          break;\n        }\n      case \"pseudo\":\n        {\n          let childContext;\n          const isNested = !!node.length;\n          const isScoped = node.value === \":local\" || node.value === \":global\";\n          const isImportExport = node.value === \":import\" || node.value === \":export\";\n          if (isImportExport) {\n            context.hasLocals = true;\n            // :local(.foo)\n          } else if (isNested) {\n            if (isScoped) {\n              if (node.nodes.length === 0) {\n                throw new Error(`${node.value}() can't be empty`);\n              }\n              if (context.inside) {\n                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n              }\n              childContext = {\n                global: node.value === \":global\",\n                inside: node.value,\n                hasLocals: false,\n                explicit: true\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);\n              if (newNodes.length) {\n                const {\n                  before,\n                  after\n                } = node.spaces;\n                const first = newNodes[0];\n                const last = newNodes[newNodes.length - 1];\n                first.spaces = {\n                  before,\n                  after: first.spaces.after\n                };\n                last.spaces = {\n                  before: last.spaces.before,\n                  after\n                };\n              }\n              node = newNodes;\n              break;\n            } else {\n              childContext = {\n                global: context.global,\n                inside: context.inside,\n                lastWasSpacing: true,\n                hasLocals: false,\n                explicit: context.explicit\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext));\n              node = node.clone();\n              node.nodes = normalizeNodeArray(newNodes);\n              if (childContext.hasLocals) {\n                context.hasLocals = true;\n              }\n            }\n            break;\n\n            //:local .foo .bar\n          } else if (isScoped) {\n            if (context.inside) {\n              throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n            }\n            const addBackSpacing = !!node.spaces.before;\n            context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;\n            context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;\n            context.global = node.value === \":global\";\n            context.explicit = true;\n\n            // because this node has spacing that is lost when we remove it\n            // we make up for it by adding an extra combinator in since adding\n            // spacing on the parent selector doesn't work\n            return addBackSpacing ? selectorParser.combinator({\n              value: \" \"\n            }) : null;\n          }\n          break;\n        }\n      case \"id\":\n      case \"class\":\n        {\n          if (!node.value) {\n            throw new Error(\"Invalid class or id selector syntax\");\n          }\n          if (context.global) {\n            break;\n          }\n          const isImportedValue = localAliasMap.has(node.value);\n          const isImportedWithExplicitScope = isImportedValue && context.explicit;\n          if (!isImportedValue || isImportedWithExplicitScope) {\n            const innerNode = node.clone();\n            innerNode.spaces = {\n              before: \"\",\n              after: \"\"\n            };\n            node = selectorParser.pseudo({\n              value: \":local\",\n              nodes: [innerNode],\n              spaces: node.spaces\n            });\n            context.hasLocals = true;\n          }\n          break;\n        }\n    }\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n    return node;\n  };\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false\n  };\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, {\n    updateSelector: false,\n    lossless: true\n  });\n  return rootContext;\n}\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n    case \"function\":\n      if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === \"url\") {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n          let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode ? functionNode.nodes.some(functionNodeChild => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;\n}\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  declaration.value = valueNodes.toString();\n}\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n  if (isAnimation) {\n    const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n       animation: infinite infinite;\n       The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      $backwards: 1,\n      $both: 1,\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-in-out\": 1,\n      \"$ease-out\": 1,\n      $forwards: 1,\n      $infinite: 1,\n      $linear: 1,\n      $none: Infinity,\n      // No matter how many times you write none, it will never be an animation name\n      $normal: 1,\n      $paused: 1,\n      $reverse: 1,\n      $running: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity\n    };\n    const didParseAnimationName = false;\n    let parsedAnimationKeywords = {};\n    let stepsFunctionNode = null;\n    const valueNodes = valueParser(declaration.value).walk(node => {\n      /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n      }\n      if (node.type === \"function\" && node.value.toLowerCase() === \"steps\") {\n        stepsFunctionNode = node;\n      }\n      const value = node.type === \"word\" && !isWordAFunctionArgument(node, stepsFunctionNode) ? node.value.toLowerCase() : null;\n      let shouldParseAnimationName = false;\n      if (!didParseAnimationName && value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] = \"$\" + value in parsedAnimationKeywords ? parsedAnimationKeywords[\"$\" + value] + 1 : 0;\n          shouldParseAnimationName = parsedAnimationKeywords[\"$\" + value] >= animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap\n      };\n      return localizeDeclNode(node, subContext);\n    });\n    declaration.value = valueNodes.toString();\n    return;\n  }\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n  const hasUrl = /url\\(/i.test(declaration.value);\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\nmodule.exports = (options = {}) => {\n  if (options && options.mode && options.mode !== \"global\" && options.mode !== \"local\" && options.mode !== \"pure\") {\n    throw new Error('options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")');\n  }\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n      return {\n        Once(root) {\n          const {\n            icssImports\n          } = extractICSS(root, false);\n          Object.keys(icssImports).forEach(key => {\n            Object.keys(icssImports[key]).forEach(prop => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n          root.walkAtRules(atRule => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atRule.params);\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atRule.params);\n              let globalKeyframes = globalMode;\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\"@keyframes :global(...) is not allowed in pure mode\");\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (!globalMode) {\n                if (atRule.params && !localAliasMap.has(atRule.params)) {\n                  atRule.params = \":local(\" + atRule.params + \")\";\n                }\n              }\n              atRule.walkDecls(declaration => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes\n                });\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach(declaration => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode\n                  });\n                }\n              });\n            }\n          });\n          root.walkRules(rule => {\n            if (rule.parent && rule.parent.type === \"atrule\" && /keyframes$/i.test(rule.parent.name)) {\n              // ignore keyframe rules\n              return;\n            }\n            const context = localizeNode(rule, options.mode, localAliasMap);\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error('Selector \"' + rule.selector + '\" is not pure ' + \"(pure selectors must contain at least one local class or id)\");\n            }\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach(declaration => localizeDeclaration(declaration, context));\n            }\n          });\n        }\n      };\n    }\n  };\n};\nmodule.exports.postcss = true;","map":{"version":3,"names":["selectorParser","require","valueParser","extractICSS","isSpacing","node","type","value","normalizeNodeArray","nodes","array","forEach","x","Array","isArray","item","push","length","pop","localizeNode","rule","mode","localAliasMap","transform","context","ignoreNextSpacing","Error","enforceNoSpacing","newNodes","resultingGlobal","hasPureGlobals","map","n","nContext","global","lastWasSpacing","hasLocals","explicit","childNode","clone","childContext","isNested","isScoped","isImportExport","inside","reduce","acc","next","concat","before","after","spaces","first","last","addBackSpacing","combinator","isImportedValue","has","isImportedWithExplicitScope","innerNode","pseudo","rootContext","selector","root","processSync","updateSelector","lossless","localizeDeclNode","localizeNextItem","options","rewriteUrl","toLowerCase","nestedNode","newUrl","quote","replace","isWordAFunctionArgument","wordNode","functionNode","some","functionNodeChild","sourceIndex","localizeDeclarationValues","localize","declaration","valueNodes","walk","index","subContext","toString","localizeDeclaration","isAnimation","test","prop","validIdent","animationKeywords","$alternate","$backwards","$both","$ease","$forwards","$infinite","$linear","$none","Infinity","$normal","$paused","$reverse","$running","$initial","$inherit","$unset","didParseAnimationName","parsedAnimationKeywords","stepsFunctionNode","shouldParseAnimationName","isAnimationName","hasUrl","module","exports","pureMode","globalMode","postcssPlugin","prepare","Map","Once","icssImports","Object","keys","key","set","walkAtRules","atRule","name","globalMatch","exec","params","localMatch","globalKeyframes","error","walkDecls","walkRules","parent","postcss"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/postcss-modules-local-by-default/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst valueParser = require(\"postcss-value-parser\");\nconst { extractICSS } = require(\"icss-utils\");\n\nconst isSpacing = (node) => node.type === \"combinator\" && node.value === \" \";\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach((x) => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach((item) => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case \"root\": {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map((n) => {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === \"undefined\") {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"selector\": {\n        newNodes = node.map((childNode) => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"combinator\": {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case \"pseudo\": {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = node.value === \":local\" || node.value === \":global\";\n        const isImportExport =\n          node.value === \":import\" || node.value === \":export\";\n\n        if (isImportExport) {\n          context.hasLocals = true;\n          // :local(.foo)\n        } else if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === \":global\",\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map((childNode) => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map((childNode) =>\n              transform(childNode, childContext)\n            );\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === \":global\";\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser.combinator({ value: \" \" })\n            : null;\n        }\n        break;\n      }\n      case \"id\":\n      case \"class\": {\n        if (!node.value) {\n          throw new Error(\"Invalid class or id selector syntax\");\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: \"\", after: \"\" };\n\n          node = selectorParser.pseudo({\n            value: \":local\",\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser((root) => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case \"function\":\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === \"url\"\n      ) {\n        node.nodes.map((nestedNode) => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode\n    ? functionNode.nodes.some(\n        (functionNodeChild) =>\n          functionNodeChild.sourceIndex === wordNode.sourceIndex\n      )\n    : false;\n}\n\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n\n  declaration.value = valueNodes.toString();\n}\n\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n\n  if (isAnimation) {\n    const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n  \n    animation: infinite infinite;\n  \n    The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      $backwards: 1,\n      $both: 1,\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-in-out\": 1,\n      \"$ease-out\": 1,\n      $forwards: 1,\n      $infinite: 1,\n      $linear: 1,\n      $none: Infinity, // No matter how many times you write none, it will never be an animation name\n      $normal: 1,\n      $paused: 1,\n      $reverse: 1,\n      $running: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity,\n    };\n\n    const didParseAnimationName = false;\n    let parsedAnimationKeywords = {};\n    let stepsFunctionNode = null;\n    const valueNodes = valueParser(declaration.value).walk((node) => {\n      /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n      }\n      if (node.type === \"function\" && node.value.toLowerCase() === \"steps\") {\n        stepsFunctionNode = node;\n      }\n      const value =\n        node.type === \"word\" &&\n        !isWordAFunctionArgument(node, stepsFunctionNode)\n          ? node.value.toLowerCase()\n          : null;\n\n      let shouldParseAnimationName = false;\n\n      if (!didParseAnimationName && value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] =\n            \"$\" + value in parsedAnimationKeywords\n              ? parsedAnimationKeywords[\"$\" + value] + 1\n              : 0;\n\n          shouldParseAnimationName =\n            parsedAnimationKeywords[\"$\" + value] >=\n            animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap,\n      };\n      return localizeDeclNode(node, subContext);\n    });\n\n    declaration.value = valueNodes.toString();\n\n    return;\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n\n  const hasUrl = /url\\(/i.test(declaration.value);\n\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\n\nmodule.exports = (options = {}) => {\n  if (\n    options &&\n    options.mode &&\n    options.mode !== \"global\" &&\n    options.mode !== \"local\" &&\n    options.mode !== \"pure\"\n  ) {\n    throw new Error(\n      'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n    );\n  }\n\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n\n      return {\n        Once(root) {\n          const { icssImports } = extractICSS(root, false);\n\n          Object.keys(icssImports).forEach((key) => {\n            Object.keys(icssImports[key]).forEach((prop) => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n\n          root.walkAtRules((atRule) => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n\n              let globalKeyframes = globalMode;\n\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\n                    \"@keyframes :global(...) is not allowed in pure mode\"\n                  );\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (!globalMode) {\n                if (atRule.params && !localAliasMap.has(atRule.params)) {\n                  atRule.params = \":local(\" + atRule.params + \")\";\n                }\n              }\n\n              atRule.walkDecls((declaration) => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes,\n                });\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            }\n          });\n\n          root.walkRules((rule) => {\n            if (\n              rule.parent &&\n              rule.parent.type === \"atrule\" &&\n              /keyframes$/i.test(rule.parent.name)\n            ) {\n              // ignore keyframe rules\n              return;\n            }\n\n            const context = localizeNode(rule, options.mode, localAliasMap);\n\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error(\n                'Selector \"' +\n                  rule.selector +\n                  '\" is not pure ' +\n                  \"(pure selectors must contain at least one local class or id)\"\n              );\n            }\n\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach((declaration) =>\n                localizeDeclaration(declaration, context)\n              );\n            }\n          });\n        },\n      };\n    },\n  };\n};\nmodule.exports.postcss = true;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}