{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nconst {\n  isReadableStream\n} = require('./utils');\nconst TextDecoder = require('./text-decoder');\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\nfunction adjustPosition(error, parser) {\n  if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n    error.message = error.message.replace(/at position (\\d+)/, (_, pos) => 'at position ' + (Number(pos) + parser.jsonParseOffset));\n  }\n  return error;\n}\nfunction append(array, elements) {\n  // Note: Avoid to use array.push(...elements) since it may lead to\n  // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n  const initialLength = array.length;\n  array.length += elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    array[initialLength + i] = elements[i];\n  }\n}\nmodule.exports = function (chunkEmitter) {\n  let parser = new ChunkParser();\n  if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n    return new Promise((resolve, reject) => {\n      chunkEmitter.on('data', chunk => {\n        try {\n          parser.push(chunk);\n        } catch (e) {\n          reject(adjustPosition(e, parser));\n          parser = null;\n        }\n      }).on('error', e => {\n        parser = null;\n        reject(e);\n      }).on('end', () => {\n        try {\n          resolve(parser.finish());\n        } catch (e) {\n          reject(adjustPosition(e, parser));\n        } finally {\n          parser = null;\n        }\n      });\n    });\n  }\n  if (typeof chunkEmitter === 'function') {\n    const iterator = chunkEmitter();\n    if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          try {\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n            var _iteratorError;\n            try {\n              for (var _iterator = _asyncIterator(iterator), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                const chunk = _step.value;\n                {\n                  parser.push(chunk);\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n            resolve(parser.finish());\n          } catch (e) {\n            reject(adjustPosition(e, parser));\n          } finally {\n            parser = null;\n          }\n        });\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n  throw new Error('Chunk emitter should be readable stream, generator, ' + 'async generator or function returning an iterable object');\n};\nclass ChunkParser {\n  constructor() {\n    this.value = undefined;\n    this.valueStack = null;\n    this.stack = new Array(100);\n    this.lastFlushDepth = 0;\n    this.flushDepth = 0;\n    this.stateString = false;\n    this.stateStringEscape = false;\n    this.pendingByteSeq = null;\n    this.pendingChunk = null;\n    this.chunkOffset = 0;\n    this.jsonParseOffset = 0;\n  }\n  parseAndAppend(fragment, wrap) {\n    // Append new entries or elements\n    if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n      if (wrap) {\n        this.jsonParseOffset--;\n        fragment = '{' + fragment + '}';\n      }\n      Object.assign(this.valueStack.value, JSON.parse(fragment));\n    } else {\n      if (wrap) {\n        this.jsonParseOffset--;\n        fragment = '[' + fragment + ']';\n      }\n      append(this.valueStack.value, JSON.parse(fragment));\n    }\n  }\n  prepareAddition(fragment) {\n    const {\n      value\n    } = this.valueStack;\n    const expectComma = Array.isArray(value) ? value.length !== 0 : Object.keys(value).length !== 0;\n    if (expectComma) {\n      // Skip a comma at the beginning of fragment, otherwise it would\n      // fail to parse\n      if (fragment[0] === ',') {\n        this.jsonParseOffset++;\n        return fragment.slice(1);\n      }\n\n      // When value (an object or array) is not empty and a fragment\n      // doesn't start with a comma, a single valid fragment starting\n      // is a closing bracket. If it's not, a prefix is adding to fail\n      // parsing. Otherwise, the sequence of chunks can be successfully\n      // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n      if (fragment[0] !== '}' && fragment[0] !== ']') {\n        this.jsonParseOffset -= 3;\n        return '[[]' + fragment;\n      }\n    }\n    return fragment;\n  }\n  flush(chunk, start, end) {\n    let fragment = chunk.slice(start, end);\n\n    // Save position correction an error in JSON.parse() if any\n    this.jsonParseOffset = this.chunkOffset + start;\n\n    // Prepend pending chunk if any\n    if (this.pendingChunk !== null) {\n      fragment = this.pendingChunk + fragment;\n      this.jsonParseOffset -= this.pendingChunk.length;\n      this.pendingChunk = null;\n    }\n    if (this.flushDepth === this.lastFlushDepth) {\n      // Depth didn't changed, so it's a root value or entry/element set\n      if (this.flushDepth > 0) {\n        this.parseAndAppend(this.prepareAddition(fragment), true);\n      } else {\n        // That's an entire value on a top level\n        this.value = JSON.parse(fragment);\n        this.valueStack = {\n          value: this.value,\n          prev: null\n        };\n      }\n    } else if (this.flushDepth > this.lastFlushDepth) {\n      // Add missed closing brackets/parentheses\n      for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n        fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n      }\n      if (this.lastFlushDepth === 0) {\n        // That's a root value\n        this.value = JSON.parse(fragment);\n        this.valueStack = {\n          value: this.value,\n          prev: null\n        };\n      } else {\n        this.parseAndAppend(this.prepareAddition(fragment), true);\n      }\n\n      // Move down to the depths to the last object/array, which is current now\n      for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n        let value = this.valueStack.value;\n        if (this.stack[i - 1] === STACK_OBJECT) {\n          // find last entry\n          let key;\n          // eslint-disable-next-line curly\n          for (key in value);\n          value = value[key];\n        } else {\n          // last element\n          value = value[value.length - 1];\n        }\n        this.valueStack = {\n          value,\n          prev: this.valueStack\n        };\n      }\n    } else /* this.flushDepth < this.lastFlushDepth */{\n        fragment = this.prepareAddition(fragment);\n\n        // Add missed opening brackets/parentheses\n        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n          this.jsonParseOffset--;\n          fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n        }\n        this.parseAndAppend(fragment, false);\n        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n          this.valueStack = this.valueStack.prev;\n        }\n      }\n    this.lastFlushDepth = this.flushDepth;\n  }\n  push(chunk) {\n    if (typeof chunk !== 'string') {\n      // Suppose chunk is Buffer or Uint8Array\n\n      // Prepend uncompleted byte sequence if any\n      if (this.pendingByteSeq !== null) {\n        const origRawChunk = chunk;\n        chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n        chunk.set(this.pendingByteSeq);\n        chunk.set(origRawChunk, this.pendingByteSeq.length);\n        this.pendingByteSeq = null;\n      }\n\n      // In case Buffer/Uint8Array, an input is encoded in UTF8\n      // Seek for parts of uncompleted UTF8 symbol on the ending\n      // This makes sense only if we expect more chunks and last char is not multi-bytes\n      if (chunk[chunk.length - 1] > 127) {\n        for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n          const byte = chunk[chunk.length - 1 - seqLength];\n\n          // 10xxxxxx - 2nd, 3rd or 4th byte\n          // 110xxxxx – first byte of 2-byte sequence\n          // 1110xxxx - first byte of 3-byte sequence\n          // 11110xxx - first byte of 4-byte sequence\n          if (byte >> 6 === 3) {\n            seqLength++;\n\n            // If the sequence is really incomplete, then preserve it\n            // for the future chunk and cut off it from the current chunk\n            if (seqLength !== 4 && byte >> 3 === 0b11110 || seqLength !== 3 && byte >> 4 === 0b1110 || seqLength !== 2 && byte >> 5 === 0b110) {\n              this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n              chunk = chunk.slice(0, -seqLength);\n            }\n            break;\n          }\n        }\n      }\n\n      // Convert chunk to a string, since single decode per chunk\n      // is much effective than decode multiple small substrings\n      chunk = decoder.decode(chunk);\n    }\n    const chunkLength = chunk.length;\n    let lastFlushPoint = 0;\n    let flushPoint = 0;\n\n    // Main scan loop\n    scan: for (let i = 0; i < chunkLength; i++) {\n      if (this.stateString) {\n        for (; i < chunkLength; i++) {\n          if (this.stateStringEscape) {\n            this.stateStringEscape = false;\n          } else {\n            switch (chunk.charCodeAt(i)) {\n              case 0x22:\n                /* \" */\n                this.stateString = false;\n                continue scan;\n              case 0x5C:\n                /* \\ */\n                this.stateStringEscape = true;\n            }\n          }\n        }\n        break;\n      }\n      switch (chunk.charCodeAt(i)) {\n        case 0x22:\n          /* \" */\n          this.stateString = true;\n          this.stateStringEscape = false;\n          break;\n        case 0x2C:\n          /* , */\n          flushPoint = i;\n          break;\n        case 0x7B:\n          /* { */\n          // Open an object\n          flushPoint = i + 1;\n          this.stack[this.flushDepth++] = STACK_OBJECT;\n          break;\n        case 0x5B:\n          /* [ */\n          // Open an array\n          flushPoint = i + 1;\n          this.stack[this.flushDepth++] = STACK_ARRAY;\n          break;\n        case 0x5D: /* ] */\n        case 0x7D:\n          /* } */\n          // Close an object or array\n          flushPoint = i + 1;\n          this.flushDepth--;\n          if (this.flushDepth < this.lastFlushDepth) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n            lastFlushPoint = flushPoint;\n          }\n          break;\n        case 0x09: /* \\t */\n        case 0x0A: /* \\n */\n        case 0x0D: /* \\r */\n        case 0x20:\n          /* space */\n          // Move points forward when they points on current position and it's a whitespace\n          if (lastFlushPoint === i) {\n            lastFlushPoint++;\n          }\n          if (flushPoint === i) {\n            flushPoint++;\n          }\n          break;\n      }\n    }\n    if (flushPoint > lastFlushPoint) {\n      this.flush(chunk, lastFlushPoint, flushPoint);\n    }\n\n    // Produce pendingChunk if something left\n    if (flushPoint < chunkLength) {\n      if (this.pendingChunk !== null) {\n        // When there is already a pending chunk then no flush happened,\n        // appending entire chunk to pending one\n        this.pendingChunk += chunk;\n      } else {\n        // Create a pending chunk, it will start with non-whitespace since\n        // flushPoint was moved forward away from whitespaces on scan\n        this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n      }\n    }\n    this.chunkOffset += chunkLength;\n  }\n  finish() {\n    if (this.pendingChunk !== null) {\n      this.flush('', 0, 0);\n      this.pendingChunk = null;\n    }\n    return this.value;\n  }\n}\n;","map":{"version":3,"names":["isReadableStream","require","TextDecoder","STACK_OBJECT","STACK_ARRAY","decoder","isObject","value","adjustPosition","error","parser","name","jsonParseOffset","message","replace","_","pos","Number","append","array","elements","initialLength","length","i","module","exports","chunkEmitter","ChunkParser","Promise","resolve","reject","on","chunk","push","e","finish","iterator","Symbol","asyncIterator","Error","constructor","undefined","valueStack","stack","Array","lastFlushDepth","flushDepth","stateString","stateStringEscape","pendingByteSeq","pendingChunk","chunkOffset","parseAndAppend","fragment","wrap","Object","assign","JSON","parse","prepareAddition","expectComma","isArray","keys","slice","flush","start","end","prev","key","origRawChunk","Uint8Array","set","seqLength","byte","decode","chunkLength","lastFlushPoint","flushPoint","scan","charCodeAt"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@discoveryjs/json-ext/src/parse-chunked.js"],"sourcesContent":["const { isReadableStream } = require('./utils');\nconst TextDecoder = require('./text-decoder');\n\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\nfunction adjustPosition(error, parser) {\n    if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n        error.message = error.message.replace(/at position (\\d+)/, (_, pos) =>\n            'at position ' + (Number(pos) + parser.jsonParseOffset)\n        );\n    }\n\n    return error;\n}\n\nfunction append(array, elements) {\n    // Note: Avoid to use array.push(...elements) since it may lead to\n    // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n    const initialLength = array.length;\n    array.length += elements.length;\n\n    for (let i = 0; i < elements.length; i++) {\n        array[initialLength + i] = elements[i];\n    }\n}\n\nmodule.exports = function(chunkEmitter) {\n    let parser = new ChunkParser();\n\n    if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n        return new Promise((resolve, reject) => {\n            chunkEmitter\n                .on('data', chunk => {\n                    try {\n                        parser.push(chunk);\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                        parser = null;\n                    }\n                })\n                .on('error', (e) => {\n                    parser = null;\n                    reject(e);\n                })\n                .on('end', () => {\n                    try {\n                        resolve(parser.finish());\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                    } finally {\n                        parser = null;\n                    }\n                });\n        });\n    }\n\n    if (typeof chunkEmitter === 'function') {\n        const iterator = chunkEmitter();\n\n        if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n            return new Promise(async (resolve, reject) => {\n                try {\n                    for await (const chunk of iterator) {\n                        parser.push(chunk);\n                    }\n\n                    resolve(parser.finish());\n                } catch (e) {\n                    reject(adjustPosition(e, parser));\n                } finally {\n                    parser = null;\n                }\n            });\n        }\n    }\n\n    throw new Error(\n        'Chunk emitter should be readable stream, generator, ' +\n        'async generator or function returning an iterable object'\n    );\n};\n\nclass ChunkParser {\n    constructor() {\n        this.value = undefined;\n        this.valueStack = null;\n\n        this.stack = new Array(100);\n        this.lastFlushDepth = 0;\n        this.flushDepth = 0;\n        this.stateString = false;\n        this.stateStringEscape = false;\n        this.pendingByteSeq = null;\n        this.pendingChunk = null;\n        this.chunkOffset = 0;\n        this.jsonParseOffset = 0;\n    }\n\n    parseAndAppend(fragment, wrap) {\n        // Append new entries or elements\n        if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '{' + fragment + '}';\n            }\n\n            Object.assign(this.valueStack.value, JSON.parse(fragment));\n        } else {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '[' + fragment + ']';\n            }\n\n            append(this.valueStack.value, JSON.parse(fragment));\n        }\n    }\n\n    prepareAddition(fragment) {\n        const { value } = this.valueStack;\n        const expectComma = Array.isArray(value)\n            ? value.length !== 0\n            : Object.keys(value).length !== 0;\n\n        if (expectComma) {\n            // Skip a comma at the beginning of fragment, otherwise it would\n            // fail to parse\n            if (fragment[0] === ',') {\n                this.jsonParseOffset++;\n                return fragment.slice(1);\n            }\n\n            // When value (an object or array) is not empty and a fragment\n            // doesn't start with a comma, a single valid fragment starting\n            // is a closing bracket. If it's not, a prefix is adding to fail\n            // parsing. Otherwise, the sequence of chunks can be successfully\n            // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n            if (fragment[0] !== '}' && fragment[0] !== ']') {\n                this.jsonParseOffset -= 3;\n                return '[[]' + fragment;\n            }\n        }\n\n        return fragment;\n    }\n\n    flush(chunk, start, end) {\n        let fragment = chunk.slice(start, end);\n\n        // Save position correction an error in JSON.parse() if any\n        this.jsonParseOffset = this.chunkOffset + start;\n\n        // Prepend pending chunk if any\n        if (this.pendingChunk !== null) {\n            fragment = this.pendingChunk + fragment;\n            this.jsonParseOffset -= this.pendingChunk.length;\n            this.pendingChunk = null;\n        }\n\n        if (this.flushDepth === this.lastFlushDepth) {\n            // Depth didn't changed, so it's a root value or entry/element set\n            if (this.flushDepth > 0) {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            } else {\n                // That's an entire value on a top level\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            }\n        } else if (this.flushDepth > this.lastFlushDepth) {\n            // Add missed closing brackets/parentheses\n            for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n                fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n            }\n\n            if (this.lastFlushDepth === 0) {\n                // That's a root value\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            } else {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            }\n\n            // Move down to the depths to the last object/array, which is current now\n            for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n                let value = this.valueStack.value;\n\n                if (this.stack[i - 1] === STACK_OBJECT) {\n                    // find last entry\n                    let key;\n                    // eslint-disable-next-line curly\n                    for (key in value);\n                    value = value[key];\n                } else {\n                    // last element\n                    value = value[value.length - 1];\n                }\n\n                this.valueStack = {\n                    value,\n                    prev: this.valueStack\n                };\n            }\n        } else /* this.flushDepth < this.lastFlushDepth */ {\n            fragment = this.prepareAddition(fragment);\n\n            // Add missed opening brackets/parentheses\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.jsonParseOffset--;\n                fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n            }\n\n            this.parseAndAppend(fragment, false);\n\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.valueStack = this.valueStack.prev;\n            }\n        }\n\n        this.lastFlushDepth = this.flushDepth;\n    }\n\n    push(chunk) {\n        if (typeof chunk !== 'string') {\n            // Suppose chunk is Buffer or Uint8Array\n\n            // Prepend uncompleted byte sequence if any\n            if (this.pendingByteSeq !== null) {\n                const origRawChunk = chunk;\n                chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n                chunk.set(this.pendingByteSeq);\n                chunk.set(origRawChunk, this.pendingByteSeq.length);\n                this.pendingByteSeq = null;\n            }\n\n            // In case Buffer/Uint8Array, an input is encoded in UTF8\n            // Seek for parts of uncompleted UTF8 symbol on the ending\n            // This makes sense only if we expect more chunks and last char is not multi-bytes\n            if (chunk[chunk.length - 1] > 127) {\n                for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n                    const byte = chunk[chunk.length - 1 - seqLength];\n\n                    // 10xxxxxx - 2nd, 3rd or 4th byte\n                    // 110xxxxx – first byte of 2-byte sequence\n                    // 1110xxxx - first byte of 3-byte sequence\n                    // 11110xxx - first byte of 4-byte sequence\n                    if (byte >> 6 === 3) {\n                        seqLength++;\n\n                        // If the sequence is really incomplete, then preserve it\n                        // for the future chunk and cut off it from the current chunk\n                        if ((seqLength !== 4 && byte >> 3 === 0b11110) ||\n                            (seqLength !== 3 && byte >> 4 === 0b1110) ||\n                            (seqLength !== 2 && byte >> 5 === 0b110)) {\n                            this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n                            chunk = chunk.slice(0, -seqLength);\n                        }\n\n                        break;\n                    }\n                }\n            }\n\n            // Convert chunk to a string, since single decode per chunk\n            // is much effective than decode multiple small substrings\n            chunk = decoder.decode(chunk);\n        }\n\n        const chunkLength = chunk.length;\n        let lastFlushPoint = 0;\n        let flushPoint = 0;\n\n        // Main scan loop\n        scan: for (let i = 0; i < chunkLength; i++) {\n            if (this.stateString) {\n                for (; i < chunkLength; i++) {\n                    if (this.stateStringEscape) {\n                        this.stateStringEscape = false;\n                    } else {\n                        switch (chunk.charCodeAt(i)) {\n                            case 0x22: /* \" */\n                                this.stateString = false;\n                                continue scan;\n\n                            case 0x5C: /* \\ */\n                                this.stateStringEscape = true;\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            switch (chunk.charCodeAt(i)) {\n                case 0x22: /* \" */\n                    this.stateString = true;\n                    this.stateStringEscape = false;\n                    break;\n\n                case 0x2C: /* , */\n                    flushPoint = i;\n                    break;\n\n                case 0x7B: /* { */\n                    // Open an object\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_OBJECT;\n                    break;\n\n                case 0x5B: /* [ */\n                    // Open an array\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_ARRAY;\n                    break;\n\n                case 0x5D: /* ] */\n                case 0x7D: /* } */\n                    // Close an object or array\n                    flushPoint = i + 1;\n                    this.flushDepth--;\n\n                    if (this.flushDepth < this.lastFlushDepth) {\n                        this.flush(chunk, lastFlushPoint, flushPoint);\n                        lastFlushPoint = flushPoint;\n                    }\n\n                    break;\n\n                case 0x09: /* \\t */\n                case 0x0A: /* \\n */\n                case 0x0D: /* \\r */\n                case 0x20: /* space */\n                    // Move points forward when they points on current position and it's a whitespace\n                    if (lastFlushPoint === i) {\n                        lastFlushPoint++;\n                    }\n\n                    if (flushPoint === i) {\n                        flushPoint++;\n                    }\n\n                    break;\n            }\n        }\n\n        if (flushPoint > lastFlushPoint) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n        }\n\n        // Produce pendingChunk if something left\n        if (flushPoint < chunkLength) {\n            if (this.pendingChunk !== null) {\n                // When there is already a pending chunk then no flush happened,\n                // appending entire chunk to pending one\n                this.pendingChunk += chunk;\n            } else {\n                // Create a pending chunk, it will start with non-whitespace since\n                // flushPoint was moved forward away from whitespaces on scan\n                this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n            }\n        }\n\n        this.chunkOffset += chunkLength;\n    }\n\n    finish() {\n        if (this.pendingChunk !== null) {\n            this.flush('', 0, 0);\n            this.pendingChunk = null;\n        }\n\n        return this.value;\n    }\n};\n"],"mappings":";;AAAA,MAAM;EAAEA;AAAiB,CAAC,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC/C,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAE7C,MAAME,YAAY,GAAG,CAAC;AACtB,MAAMC,WAAW,GAAG,CAAC;AACrB,MAAMC,OAAO,GAAG,IAAIH,WAAW,EAAE;AAEjC,SAASI,QAAQ,CAACC,KAAK,EAAE;EACrB,OAAOA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ;AACtD;AAEA,SAASC,cAAc,CAACC,KAAK,EAAEC,MAAM,EAAE;EACnC,IAAID,KAAK,CAACE,IAAI,KAAK,aAAa,IAAID,MAAM,CAACE,eAAe,EAAE;IACxDH,KAAK,CAACI,OAAO,GAAGJ,KAAK,CAACI,OAAO,CAACC,OAAO,CAAC,mBAAmB,EAAE,CAACC,CAAC,EAAEC,GAAG,KAC9D,cAAc,IAAIC,MAAM,CAACD,GAAG,CAAC,GAAGN,MAAM,CAACE,eAAe,CAAC,CAC1D;EACL;EAEA,OAAOH,KAAK;AAChB;AAEA,SAASS,MAAM,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC7B;EACA;EACA,MAAMC,aAAa,GAAGF,KAAK,CAACG,MAAM;EAClCH,KAAK,CAACG,MAAM,IAAIF,QAAQ,CAACE,MAAM;EAE/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAACE,MAAM,EAAEC,CAAC,EAAE,EAAE;IACtCJ,KAAK,CAACE,aAAa,GAAGE,CAAC,CAAC,GAAGH,QAAQ,CAACG,CAAC,CAAC;EAC1C;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAG,UAASC,YAAY,EAAE;EACpC,IAAIhB,MAAM,GAAG,IAAIiB,WAAW,EAAE;EAE9B,IAAIrB,QAAQ,CAACoB,YAAY,CAAC,IAAI1B,gBAAgB,CAAC0B,YAAY,CAAC,EAAE;IAC1D,OAAO,IAAIE,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpCJ,YAAY,CACPK,EAAE,CAAC,MAAM,EAAEC,KAAK,IAAI;QACjB,IAAI;UACAtB,MAAM,CAACuB,IAAI,CAACD,KAAK,CAAC;QACtB,CAAC,CAAC,OAAOE,CAAC,EAAE;UACRJ,MAAM,CAACtB,cAAc,CAAC0B,CAAC,EAAExB,MAAM,CAAC,CAAC;UACjCA,MAAM,GAAG,IAAI;QACjB;MACJ,CAAC,CAAC,CACDqB,EAAE,CAAC,OAAO,EAAGG,CAAC,IAAK;QAChBxB,MAAM,GAAG,IAAI;QACboB,MAAM,CAACI,CAAC,CAAC;MACb,CAAC,CAAC,CACDH,EAAE,CAAC,KAAK,EAAE,MAAM;QACb,IAAI;UACAF,OAAO,CAACnB,MAAM,CAACyB,MAAM,EAAE,CAAC;QAC5B,CAAC,CAAC,OAAOD,CAAC,EAAE;UACRJ,MAAM,CAACtB,cAAc,CAAC0B,CAAC,EAAExB,MAAM,CAAC,CAAC;QACrC,CAAC,SAAS;UACNA,MAAM,GAAG,IAAI;QACjB;MACJ,CAAC,CAAC;IACV,CAAC,CAAC;EACN;EAEA,IAAI,OAAOgB,YAAY,KAAK,UAAU,EAAE;IACpC,MAAMU,QAAQ,GAAGV,YAAY,EAAE;IAE/B,IAAIpB,QAAQ,CAAC8B,QAAQ,CAAC,KAAKC,MAAM,CAACD,QAAQ,IAAIA,QAAQ,IAAIC,MAAM,CAACC,aAAa,IAAIF,QAAQ,CAAC,EAAE;MACzF,OAAO,IAAIR,OAAO;QAAA,6BAAC,WAAOC,OAAO,EAAEC,MAAM,EAAK;UAC1C,IAAI;YAAA;YAAA;YAAA;YAAA;cACA,oCAA0BM,QAAQ,iHAAE;gBAAA,MAAnBJ,KAAK;gBAAA;kBAClBtB,MAAM,CAACuB,IAAI,CAACD,KAAK,CAAC;gBAAC;cACvB;YAAC;cAAA;cAAA;YAAA;cAAA;gBAAA;kBAAA;gBAAA;cAAA;gBAAA;kBAAA;gBAAA;cAAA;YAAA;YAEDH,OAAO,CAACnB,MAAM,CAACyB,MAAM,EAAE,CAAC;UAC5B,CAAC,CAAC,OAAOD,CAAC,EAAE;YACRJ,MAAM,CAACtB,cAAc,CAAC0B,CAAC,EAAExB,MAAM,CAAC,CAAC;UACrC,CAAC,SAAS;YACNA,MAAM,GAAG,IAAI;UACjB;QACJ,CAAC;QAAA;UAAA;QAAA;MAAA,IAAC;IACN;EACJ;EAEA,MAAM,IAAI6B,KAAK,CACX,sDAAsD,GACtD,0DAA0D,CAC7D;AACL,CAAC;AAED,MAAMZ,WAAW,CAAC;EACda,WAAW,GAAG;IACV,IAAI,CAACjC,KAAK,GAAGkC,SAAS;IACtB,IAAI,CAACC,UAAU,GAAG,IAAI;IAEtB,IAAI,CAACC,KAAK,GAAG,IAAIC,KAAK,CAAC,GAAG,CAAC;IAC3B,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACvC,eAAe,GAAG,CAAC;EAC5B;EAEAwC,cAAc,CAACC,QAAQ,EAAEC,IAAI,EAAE;IAC3B;IACA,IAAI,IAAI,CAACX,KAAK,CAAC,IAAI,CAACE,cAAc,GAAG,CAAC,CAAC,KAAK1C,YAAY,EAAE;MACtD,IAAImD,IAAI,EAAE;QACN,IAAI,CAAC1C,eAAe,EAAE;QACtByC,QAAQ,GAAG,GAAG,GAAGA,QAAQ,GAAG,GAAG;MACnC;MAEAE,MAAM,CAACC,MAAM,CAAC,IAAI,CAACd,UAAU,CAACnC,KAAK,EAAEkD,IAAI,CAACC,KAAK,CAACL,QAAQ,CAAC,CAAC;IAC9D,CAAC,MAAM;MACH,IAAIC,IAAI,EAAE;QACN,IAAI,CAAC1C,eAAe,EAAE;QACtByC,QAAQ,GAAG,GAAG,GAAGA,QAAQ,GAAG,GAAG;MACnC;MAEAnC,MAAM,CAAC,IAAI,CAACwB,UAAU,CAACnC,KAAK,EAAEkD,IAAI,CAACC,KAAK,CAACL,QAAQ,CAAC,CAAC;IACvD;EACJ;EAEAM,eAAe,CAACN,QAAQ,EAAE;IACtB,MAAM;MAAE9C;IAAM,CAAC,GAAG,IAAI,CAACmC,UAAU;IACjC,MAAMkB,WAAW,GAAGhB,KAAK,CAACiB,OAAO,CAACtD,KAAK,CAAC,GAClCA,KAAK,CAACe,MAAM,KAAK,CAAC,GAClBiC,MAAM,CAACO,IAAI,CAACvD,KAAK,CAAC,CAACe,MAAM,KAAK,CAAC;IAErC,IAAIsC,WAAW,EAAE;MACb;MACA;MACA,IAAIP,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACrB,IAAI,CAACzC,eAAe,EAAE;QACtB,OAAOyC,QAAQ,CAACU,KAAK,CAAC,CAAC,CAAC;MAC5B;;MAEA;MACA;MACA;MACA;MACA;MACA,IAAIV,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5C,IAAI,CAACzC,eAAe,IAAI,CAAC;QACzB,OAAO,KAAK,GAAGyC,QAAQ;MAC3B;IACJ;IAEA,OAAOA,QAAQ;EACnB;EAEAW,KAAK,CAAChC,KAAK,EAAEiC,KAAK,EAAEC,GAAG,EAAE;IACrB,IAAIb,QAAQ,GAAGrB,KAAK,CAAC+B,KAAK,CAACE,KAAK,EAAEC,GAAG,CAAC;;IAEtC;IACA,IAAI,CAACtD,eAAe,GAAG,IAAI,CAACuC,WAAW,GAAGc,KAAK;;IAE/C;IACA,IAAI,IAAI,CAACf,YAAY,KAAK,IAAI,EAAE;MAC5BG,QAAQ,GAAG,IAAI,CAACH,YAAY,GAAGG,QAAQ;MACvC,IAAI,CAACzC,eAAe,IAAI,IAAI,CAACsC,YAAY,CAAC5B,MAAM;MAChD,IAAI,CAAC4B,YAAY,GAAG,IAAI;IAC5B;IAEA,IAAI,IAAI,CAACJ,UAAU,KAAK,IAAI,CAACD,cAAc,EAAE;MACzC;MACA,IAAI,IAAI,CAACC,UAAU,GAAG,CAAC,EAAE;QACrB,IAAI,CAACM,cAAc,CAAC,IAAI,CAACO,eAAe,CAACN,QAAQ,CAAC,EAAE,IAAI,CAAC;MAC7D,CAAC,MAAM;QACH;QACA,IAAI,CAAC9C,KAAK,GAAGkD,IAAI,CAACC,KAAK,CAACL,QAAQ,CAAC;QACjC,IAAI,CAACX,UAAU,GAAG;UACdnC,KAAK,EAAE,IAAI,CAACA,KAAK;UACjB4D,IAAI,EAAE;QACV,CAAC;MACL;IACJ,CAAC,MAAM,IAAI,IAAI,CAACrB,UAAU,GAAG,IAAI,CAACD,cAAc,EAAE;MAC9C;MACA,KAAK,IAAItB,CAAC,GAAG,IAAI,CAACuB,UAAU,GAAG,CAAC,EAAEvB,CAAC,IAAI,IAAI,CAACsB,cAAc,EAAEtB,CAAC,EAAE,EAAE;QAC7D8B,QAAQ,IAAI,IAAI,CAACV,KAAK,CAACpB,CAAC,CAAC,KAAKpB,YAAY,GAAG,GAAG,GAAG,GAAG;MAC1D;MAEA,IAAI,IAAI,CAAC0C,cAAc,KAAK,CAAC,EAAE;QAC3B;QACA,IAAI,CAACtC,KAAK,GAAGkD,IAAI,CAACC,KAAK,CAACL,QAAQ,CAAC;QACjC,IAAI,CAACX,UAAU,GAAG;UACdnC,KAAK,EAAE,IAAI,CAACA,KAAK;UACjB4D,IAAI,EAAE;QACV,CAAC;MACL,CAAC,MAAM;QACH,IAAI,CAACf,cAAc,CAAC,IAAI,CAACO,eAAe,CAACN,QAAQ,CAAC,EAAE,IAAI,CAAC;MAC7D;;MAEA;MACA,KAAK,IAAI9B,CAAC,GAAG,IAAI,CAACsB,cAAc,IAAI,CAAC,EAAEtB,CAAC,GAAG,IAAI,CAACuB,UAAU,EAAEvB,CAAC,EAAE,EAAE;QAC7D,IAAIhB,KAAK,GAAG,IAAI,CAACmC,UAAU,CAACnC,KAAK;QAEjC,IAAI,IAAI,CAACoC,KAAK,CAACpB,CAAC,GAAG,CAAC,CAAC,KAAKpB,YAAY,EAAE;UACpC;UACA,IAAIiE,GAAG;UACP;UACA,KAAKA,GAAG,IAAI7D,KAAK,CAAC;UAClBA,KAAK,GAAGA,KAAK,CAAC6D,GAAG,CAAC;QACtB,CAAC,MAAM;UACH;UACA7D,KAAK,GAAGA,KAAK,CAACA,KAAK,CAACe,MAAM,GAAG,CAAC,CAAC;QACnC;QAEA,IAAI,CAACoB,UAAU,GAAG;UACdnC,KAAK;UACL4D,IAAI,EAAE,IAAI,CAACzB;QACf,CAAC;MACL;IACJ,CAAC,MAAM,2CAA4C;QAC/CW,QAAQ,GAAG,IAAI,CAACM,eAAe,CAACN,QAAQ,CAAC;;QAEzC;QACA,KAAK,IAAI9B,CAAC,GAAG,IAAI,CAACsB,cAAc,GAAG,CAAC,EAAEtB,CAAC,IAAI,IAAI,CAACuB,UAAU,EAAEvB,CAAC,EAAE,EAAE;UAC7D,IAAI,CAACX,eAAe,EAAE;UACtByC,QAAQ,GAAG,CAAC,IAAI,CAACV,KAAK,CAACpB,CAAC,CAAC,KAAKpB,YAAY,GAAG,GAAG,GAAG,GAAG,IAAIkD,QAAQ;QACtE;QAEA,IAAI,CAACD,cAAc,CAACC,QAAQ,EAAE,KAAK,CAAC;QAEpC,KAAK,IAAI9B,CAAC,GAAG,IAAI,CAACsB,cAAc,GAAG,CAAC,EAAEtB,CAAC,IAAI,IAAI,CAACuB,UAAU,EAAEvB,CAAC,EAAE,EAAE;UAC7D,IAAI,CAACmB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACyB,IAAI;QAC1C;MACJ;IAEA,IAAI,CAACtB,cAAc,GAAG,IAAI,CAACC,UAAU;EACzC;EAEAb,IAAI,CAACD,KAAK,EAAE;IACR,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B;;MAEA;MACA,IAAI,IAAI,CAACiB,cAAc,KAAK,IAAI,EAAE;QAC9B,MAAMoB,YAAY,GAAGrC,KAAK;QAC1BA,KAAK,GAAG,IAAIsC,UAAU,CAAC,IAAI,CAACrB,cAAc,CAAC3B,MAAM,GAAG+C,YAAY,CAAC/C,MAAM,CAAC;QACxEU,KAAK,CAACuC,GAAG,CAAC,IAAI,CAACtB,cAAc,CAAC;QAC9BjB,KAAK,CAACuC,GAAG,CAACF,YAAY,EAAE,IAAI,CAACpB,cAAc,CAAC3B,MAAM,CAAC;QACnD,IAAI,CAAC2B,cAAc,GAAG,IAAI;MAC9B;;MAEA;MACA;MACA;MACA,IAAIjB,KAAK,CAACA,KAAK,CAACV,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,EAAE;QAC/B,KAAK,IAAIkD,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGxC,KAAK,CAACV,MAAM,EAAEkD,SAAS,EAAE,EAAE;UAC3D,MAAMC,IAAI,GAAGzC,KAAK,CAACA,KAAK,CAACV,MAAM,GAAG,CAAC,GAAGkD,SAAS,CAAC;;UAEhD;UACA;UACA;UACA;UACA,IAAIC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;YACjBD,SAAS,EAAE;;YAEX;YACA;YACA,IAAKA,SAAS,KAAK,CAAC,IAAIC,IAAI,IAAI,CAAC,KAAK,OAAO,IACxCD,SAAS,KAAK,CAAC,IAAIC,IAAI,IAAI,CAAC,KAAK,MAAO,IACxCD,SAAS,KAAK,CAAC,IAAIC,IAAI,IAAI,CAAC,KAAK,KAAM,EAAE;cAC1C,IAAI,CAACxB,cAAc,GAAGjB,KAAK,CAAC+B,KAAK,CAAC/B,KAAK,CAACV,MAAM,GAAGkD,SAAS,CAAC;cAC3DxC,KAAK,GAAGA,KAAK,CAAC+B,KAAK,CAAC,CAAC,EAAE,CAACS,SAAS,CAAC;YACtC;YAEA;UACJ;QACJ;MACJ;;MAEA;MACA;MACAxC,KAAK,GAAG3B,OAAO,CAACqE,MAAM,CAAC1C,KAAK,CAAC;IACjC;IAEA,MAAM2C,WAAW,GAAG3C,KAAK,CAACV,MAAM;IAChC,IAAIsD,cAAc,GAAG,CAAC;IACtB,IAAIC,UAAU,GAAG,CAAC;;IAElB;IACAC,IAAI,EAAE,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoD,WAAW,EAAEpD,CAAC,EAAE,EAAE;MACxC,IAAI,IAAI,CAACwB,WAAW,EAAE;QAClB,OAAOxB,CAAC,GAAGoD,WAAW,EAAEpD,CAAC,EAAE,EAAE;UACzB,IAAI,IAAI,CAACyB,iBAAiB,EAAE;YACxB,IAAI,CAACA,iBAAiB,GAAG,KAAK;UAClC,CAAC,MAAM;YACH,QAAQhB,KAAK,CAAC+C,UAAU,CAACxD,CAAC,CAAC;cACvB,KAAK,IAAI;gBAAE;gBACP,IAAI,CAACwB,WAAW,GAAG,KAAK;gBACxB,SAAS+B,IAAI;cAEjB,KAAK,IAAI;gBAAE;gBACP,IAAI,CAAC9B,iBAAiB,GAAG,IAAI;YAAC;UAE1C;QACJ;QAEA;MACJ;MAEA,QAAQhB,KAAK,CAAC+C,UAAU,CAACxD,CAAC,CAAC;QACvB,KAAK,IAAI;UAAE;UACP,IAAI,CAACwB,WAAW,GAAG,IAAI;UACvB,IAAI,CAACC,iBAAiB,GAAG,KAAK;UAC9B;QAEJ,KAAK,IAAI;UAAE;UACP6B,UAAU,GAAGtD,CAAC;UACd;QAEJ,KAAK,IAAI;UAAE;UACP;UACAsD,UAAU,GAAGtD,CAAC,GAAG,CAAC;UAClB,IAAI,CAACoB,KAAK,CAAC,IAAI,CAACG,UAAU,EAAE,CAAC,GAAG3C,YAAY;UAC5C;QAEJ,KAAK,IAAI;UAAE;UACP;UACA0E,UAAU,GAAGtD,CAAC,GAAG,CAAC;UAClB,IAAI,CAACoB,KAAK,CAAC,IAAI,CAACG,UAAU,EAAE,CAAC,GAAG1C,WAAW;UAC3C;QAEJ,KAAK,IAAI,CAAC,CAAC;QACX,KAAK,IAAI;UAAE;UACP;UACAyE,UAAU,GAAGtD,CAAC,GAAG,CAAC;UAClB,IAAI,CAACuB,UAAU,EAAE;UAEjB,IAAI,IAAI,CAACA,UAAU,GAAG,IAAI,CAACD,cAAc,EAAE;YACvC,IAAI,CAACmB,KAAK,CAAChC,KAAK,EAAE4C,cAAc,EAAEC,UAAU,CAAC;YAC7CD,cAAc,GAAGC,UAAU;UAC/B;UAEA;QAEJ,KAAK,IAAI,CAAC,CAAC;QACX,KAAK,IAAI,CAAC,CAAC;QACX,KAAK,IAAI,CAAC,CAAC;QACX,KAAK,IAAI;UAAE;UACP;UACA,IAAID,cAAc,KAAKrD,CAAC,EAAE;YACtBqD,cAAc,EAAE;UACpB;UAEA,IAAIC,UAAU,KAAKtD,CAAC,EAAE;YAClBsD,UAAU,EAAE;UAChB;UAEA;MAAM;IAElB;IAEA,IAAIA,UAAU,GAAGD,cAAc,EAAE;MAC7B,IAAI,CAACZ,KAAK,CAAChC,KAAK,EAAE4C,cAAc,EAAEC,UAAU,CAAC;IACjD;;IAEA;IACA,IAAIA,UAAU,GAAGF,WAAW,EAAE;MAC1B,IAAI,IAAI,CAACzB,YAAY,KAAK,IAAI,EAAE;QAC5B;QACA;QACA,IAAI,CAACA,YAAY,IAAIlB,KAAK;MAC9B,CAAC,MAAM;QACH;QACA;QACA,IAAI,CAACkB,YAAY,GAAGlB,KAAK,CAAC+B,KAAK,CAACc,UAAU,EAAEF,WAAW,CAAC;MAC5D;IACJ;IAEA,IAAI,CAACxB,WAAW,IAAIwB,WAAW;EACnC;EAEAxC,MAAM,GAAG;IACL,IAAI,IAAI,CAACe,YAAY,KAAK,IAAI,EAAE;MAC5B,IAAI,CAACc,KAAK,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;MACpB,IAAI,CAACd,YAAY,GAAG,IAAI;IAC5B;IAEA,OAAO,IAAI,CAAC3C,KAAK;EACrB;AACJ;AAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}