{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  promisify\n} = require('util');\nconst mm = require('minimatch');\nconst Glob = require('glob').Glob;\nconst fs = require('graceful-fs');\nconst statAsync = promisify(fs.stat.bind(fs));\nconst pathLib = require('path');\nconst _ = require('lodash');\nconst File = require('./file');\nconst Url = require('./url');\nconst helper = require('./helper');\nconst log = require('./logger').create('filelist');\nconst createPatternObject = require('./config').createPatternObject;\nclass FileList {\n  constructor(patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    this._emitter = emitter;\n    this._preprocess = preprocess;\n    this.buckets = new Map();\n\n    // A promise that is pending if and only if we are active in this.refresh_()\n    this._refreshing = null;\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files);\n    };\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay);\n    this._emitModified = immediate => {\n      immediate ? emit() : debouncedEmit();\n    };\n  }\n  _findExcluded(path) {\n    return this._excludes.find(pattern => mm(path, pattern));\n  }\n  _findIncluded(path) {\n    return this._patterns.find(pattern => mm(path, pattern.pattern));\n  }\n  _findFile(path, pattern) {\n    if (!path || !pattern) return;\n    return this._getFilesByPattern(pattern.pattern).find(file => file.originalPath === path);\n  }\n  _exists(path) {\n    return !!this._patterns.find(pattern => mm(path, pattern.pattern) && this._findFile(path, pattern));\n  }\n  _getFilesByPattern(pattern) {\n    return this.buckets.get(pattern) || [];\n  }\n  _refresh() {\n    var _this = this;\n    const matchedFiles = new Set();\n    let lastCompletedRefresh = this._refreshing;\n    lastCompletedRefresh = Promise.all(this._patterns.map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        pattern,\n        type,\n        nocache,\n        isBinary,\n        integrity\n      }) {\n        if (helper.isUrlAbsolute(pattern)) {\n          _this.buckets.set(pattern, [new Url(pattern, type, integrity)]);\n          return;\n        }\n        const mg = new Glob(pathLib.normalize(pattern), {\n          cwd: '/',\n          follow: true,\n          nodir: true,\n          sync: true\n        });\n        const files = mg.found.filter(path => {\n          if (_this._findExcluded(path)) {\n            log.debug(`Excluded file \"${path}\"`);\n            return false;\n          } else if (matchedFiles.has(path)) {\n            return false;\n          } else {\n            matchedFiles.add(path);\n            return true;\n          }\n        }).map(path => new File(path, mg.statCache[path].mtime, nocache, type, isBinary));\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`);\n        } else {\n          yield Promise.all(files.map(file => _this._preprocess(file)));\n        }\n        _this.buckets.set(pattern, files);\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`);\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`);\n        }\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }())).then(() => {\n      // When we return from this function the file processing chain will be\n      // complete. In the case of two fast refresh() calls, the second call\n      // will overwrite this._refreshing, and we want the status to reflect\n      // the second call and skip the modification event from the first call.\n      if (this._refreshing !== lastCompletedRefresh) {\n        return this._refreshing;\n      }\n      this._emitModified(true);\n      return this.files;\n    });\n    return lastCompletedRefresh;\n  }\n  get files() {\n    const served = [];\n    const included = {};\n    const lookup = {};\n    this._patterns.forEach(p => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p);\n      }\n      const files = this._getFilesByPattern(p.pattern);\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1;\n        if (a.path < b.path) return -1;\n        return 0;\n      });\n      if (p.served) {\n        served.push(...files);\n      }\n      files.forEach(file => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return;\n        lookup[file.path] = p;\n        if (p.included) {\n          included[file.path] = file;\n        } else {\n          delete included[file.path];\n        }\n      });\n    });\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    };\n  }\n  refresh() {\n    this._refreshing = this._refresh();\n    return this._refreshing;\n  }\n  reload(patterns, excludes) {\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    return this.refresh();\n  }\n  addFile(path) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const excluded = _this2._findExcluded(path);\n      if (excluded) {\n        log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`);\n        return _this2.files;\n      }\n      const pattern = _this2._findIncluded(path);\n      if (!pattern) {\n        log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`);\n        return _this2.files;\n      }\n      if (_this2._exists(path)) {\n        log.debug(`Add file \"${path}\" ignored. Already in the list.`);\n        return _this2.files;\n      }\n      const file = new File(path);\n      _this2._getFilesByPattern(pattern.pattern).push(file);\n      const [stat] = yield Promise.all([statAsync(path), _this2._refreshing]);\n      file.mtime = stat.mtime;\n      yield _this2._preprocess(file);\n      log.info(`Added file \"${path}\".`);\n      _this2._emitModified();\n      return _this2.files;\n    })();\n  }\n  changeFile(path, force) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const pattern = _this3._findIncluded(path);\n      const file = _this3._findFile(path, pattern);\n      if (!file) {\n        log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`);\n        return _this3.files;\n      }\n      const [stat] = yield Promise.all([statAsync(path), _this3._refreshing]);\n      if (force || stat.mtime > file.mtime) {\n        file.mtime = stat.mtime;\n        yield _this3._preprocess(file);\n        log.info(`Changed file \"${path}\".`);\n        _this3._emitModified(force);\n      }\n      return _this3.files;\n    })();\n  }\n  removeFile(path) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const pattern = _this4._findIncluded(path);\n      const file = _this4._findFile(path, pattern);\n      if (file) {\n        helper.arrayRemove(_this4._getFilesByPattern(pattern.pattern), file);\n        log.info(`Removed file \"${path}\".`);\n        _this4._emitModified();\n      } else {\n        log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`);\n      }\n      return _this4.files;\n    })();\n  }\n}\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay);\n};\nFileList.factory.$inject = ['config', 'emitter', 'preprocess'];\nmodule.exports = FileList;","map":{"version":3,"names":["promisify","require","mm","Glob","fs","statAsync","stat","bind","pathLib","_","File","Url","helper","log","create","createPatternObject","FileList","constructor","patterns","excludes","emitter","preprocess","autoWatchBatchDelay","_patterns","_excludes","_emitter","_preprocess","buckets","Map","_refreshing","emit","files","debouncedEmit","debounce","_emitModified","immediate","_findExcluded","path","find","pattern","_findIncluded","_findFile","_getFilesByPattern","file","originalPath","_exists","get","_refresh","matchedFiles","Set","lastCompletedRefresh","Promise","all","map","type","nocache","isBinary","integrity","isUrlAbsolute","set","mg","normalize","cwd","follow","nodir","sync","found","filter","debug","has","add","statCache","mtime","isEmpty","warn","then","served","included","lookup","forEach","p","name","sort","a","b","push","compare","uniq","values","refresh","reload","addFile","excluded","info","changeFile","force","removeFile","arrayRemove","factory","config","exclude","$inject","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/karma/lib/file-list.js"],"sourcesContent":["'use strict'\n\nconst { promisify } = require('util')\nconst mm = require('minimatch')\nconst Glob = require('glob').Glob\nconst fs = require('graceful-fs')\nconst statAsync = promisify(fs.stat.bind(fs))\nconst pathLib = require('path')\nconst _ = require('lodash')\n\nconst File = require('./file')\nconst Url = require('./url')\nconst helper = require('./helper')\nconst log = require('./logger').create('filelist')\nconst createPatternObject = require('./config').createPatternObject\n\nclass FileList {\n  constructor (patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n    this._emitter = emitter\n    this._preprocess = preprocess\n\n    this.buckets = new Map()\n\n    // A promise that is pending if and only if we are active in this.refresh_()\n    this._refreshing = null\n\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files)\n    }\n\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay)\n    this._emitModified = (immediate) => {\n      immediate ? emit() : debouncedEmit()\n    }\n  }\n\n  _findExcluded (path) {\n    return this._excludes.find((pattern) => mm(path, pattern))\n  }\n\n  _findIncluded (path) {\n    return this._patterns.find((pattern) => mm(path, pattern.pattern))\n  }\n\n  _findFile (path, pattern) {\n    if (!path || !pattern) return\n    return this._getFilesByPattern(pattern.pattern).find((file) => file.originalPath === path)\n  }\n\n  _exists (path) {\n    return !!this._patterns.find((pattern) => mm(path, pattern.pattern) && this._findFile(path, pattern))\n  }\n\n  _getFilesByPattern (pattern) {\n    return this.buckets.get(pattern) || []\n  }\n\n  _refresh () {\n    const matchedFiles = new Set()\n\n    let lastCompletedRefresh = this._refreshing\n    lastCompletedRefresh = Promise.all(\n      this._patterns.map(async ({ pattern, type, nocache, isBinary, integrity }) => {\n        if (helper.isUrlAbsolute(pattern)) {\n          this.buckets.set(pattern, [new Url(pattern, type, integrity)])\n          return\n        }\n\n        const mg = new Glob(pathLib.normalize(pattern), { cwd: '/', follow: true, nodir: true, sync: true })\n\n        const files = mg.found\n          .filter((path) => {\n            if (this._findExcluded(path)) {\n              log.debug(`Excluded file \"${path}\"`)\n              return false\n            } else if (matchedFiles.has(path)) {\n              return false\n            } else {\n              matchedFiles.add(path)\n              return true\n            }\n          })\n          .map((path) => new File(path, mg.statCache[path].mtime, nocache, type, isBinary))\n\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`)\n        } else {\n          await Promise.all(files.map((file) => this._preprocess(file)))\n        }\n\n        this.buckets.set(pattern, files)\n\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`)\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`)\n        }\n      })\n    )\n      .then(() => {\n        // When we return from this function the file processing chain will be\n        // complete. In the case of two fast refresh() calls, the second call\n        // will overwrite this._refreshing, and we want the status to reflect\n        // the second call and skip the modification event from the first call.\n        if (this._refreshing !== lastCompletedRefresh) {\n          return this._refreshing\n        }\n        this._emitModified(true)\n        return this.files\n      })\n\n    return lastCompletedRefresh\n  }\n\n  get files () {\n    const served = []\n    const included = {}\n    const lookup = {}\n    this._patterns.forEach((p) => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p)\n      }\n\n      const files = this._getFilesByPattern(p.pattern)\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1\n        if (a.path < b.path) return -1\n\n        return 0\n      })\n\n      if (p.served) {\n        served.push(...files)\n      }\n\n      files.forEach((file) => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return\n\n        lookup[file.path] = p\n        if (p.included) {\n          included[file.path] = file\n        } else {\n          delete included[file.path]\n        }\n      })\n    })\n\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    }\n  }\n\n  refresh () {\n    this._refreshing = this._refresh()\n    return this._refreshing\n  }\n\n  reload (patterns, excludes) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n\n    return this.refresh()\n  }\n\n  async addFile (path) {\n    const excluded = this._findExcluded(path)\n    if (excluded) {\n      log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`)\n      return this.files\n    }\n\n    const pattern = this._findIncluded(path)\n    if (!pattern) {\n      log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`)\n      return this.files\n    }\n\n    if (this._exists(path)) {\n      log.debug(`Add file \"${path}\" ignored. Already in the list.`)\n      return this.files\n    }\n\n    const file = new File(path)\n    this._getFilesByPattern(pattern.pattern).push(file)\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    file.mtime = stat.mtime\n    await this._preprocess(file)\n\n    log.info(`Added file \"${path}\".`)\n    this._emitModified()\n    return this.files\n  }\n\n  async changeFile (path, force) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (!file) {\n      log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`)\n      return this.files\n    }\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    if (force || stat.mtime > file.mtime) {\n      file.mtime = stat.mtime\n      await this._preprocess(file)\n      log.info(`Changed file \"${path}\".`)\n      this._emitModified(force)\n    }\n    return this.files\n  }\n\n  async removeFile (path) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (file) {\n      helper.arrayRemove(this._getFilesByPattern(pattern.pattern), file)\n      log.info(`Removed file \"${path}\".`)\n\n      this._emitModified()\n    } else {\n      log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`)\n    }\n    return this.files\n  }\n}\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay)\n}\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess']\n\nmodule.exports = FileList\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}