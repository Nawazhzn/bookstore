{"ast":null,"code":"const {\n  classes\n} = require('istanbul-lib-coverage');\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\nclass SourceCoverage extends classes.FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n  }\n  newStatement(loc) {\n    const s = this.meta.last.s;\n    this.data.statementMap[s] = cloneLocation(loc);\n    this.data.s[s] = 0;\n    this.meta.last.s += 1;\n    return s;\n  }\n  newFunction(name, decl, loc) {\n    const f = this.meta.last.f;\n    name = name || '(anonymous_' + f + ')';\n    this.data.fnMap[f] = {\n      name,\n      decl: cloneLocation(decl),\n      loc: cloneLocation(loc),\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.data.f[f] = 0;\n    this.meta.last.f += 1;\n    return f;\n  }\n  newBranch(type, loc, isReportLogic = false) {\n    const b = this.meta.last.b;\n    this.data.b[b] = [];\n    this.data.branchMap[b] = {\n      loc: cloneLocation(loc),\n      type,\n      locations: [],\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.meta.last.b += 1;\n    this.maybeNewBranchTrue(type, b, isReportLogic);\n    return b;\n  }\n  maybeNewBranchTrue(type, name, isReportLogic) {\n    if (!isReportLogic) {\n      return;\n    }\n    if (type !== 'binary-expr') {\n      return;\n    }\n    this.data.bT = this.data.bT || {};\n    this.data.bT[name] = [];\n  }\n  addBranchPath(name, location) {\n    const bMeta = this.data.branchMap[name];\n    const counts = this.data.b[name];\n\n    /* istanbul ignore if: paranoid check */\n    if (!bMeta) {\n      throw new Error('Invalid branch ' + name);\n    }\n    bMeta.locations.push(cloneLocation(location));\n    counts.push(0);\n    this.maybeAddBranchTrue(name);\n    return counts.length - 1;\n  }\n  maybeAddBranchTrue(name) {\n    if (!this.data.bT) {\n      return;\n    }\n    const countsTrue = this.data.bT[name];\n    if (!countsTrue) {\n      return;\n    }\n    countsTrue.push(0);\n  }\n\n  /**\n   * Assigns an input source map to the coverage that can be used\n   * to remap the coverage output to the original source\n   * @param sourceMap {object} the source map\n   */\n  inputSourceMap(sourceMap) {\n    this.data.inputSourceMap = sourceMap;\n  }\n  freeze() {\n    // prune empty branches\n    const map = this.data.branchMap;\n    const branches = this.data.b;\n    const branchesT = this.data.bT || {};\n    Object.keys(map).forEach(b => {\n      if (map[b].locations.length === 0) {\n        delete map[b];\n        delete branches[b];\n        delete branchesT[b];\n      }\n    });\n  }\n}\nmodule.exports = {\n  SourceCoverage\n};","map":{"version":3,"names":["classes","require","cloneLocation","loc","start","line","column","end","SourceCoverage","FileCoverage","constructor","pathOrObj","meta","last","s","f","b","newStatement","data","statementMap","newFunction","name","decl","fnMap","newBranch","type","isReportLogic","branchMap","locations","maybeNewBranchTrue","bT","addBranchPath","location","bMeta","counts","Error","push","maybeAddBranchTrue","length","countsTrue","inputSourceMap","sourceMap","freeze","map","branches","branchesT","Object","keys","forEach","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/istanbul-lib-instrument/src/source-coverage.js"],"sourcesContent":["const { classes } = require('istanbul-lib-coverage');\n\nfunction cloneLocation(loc) {\n    return {\n        start: {\n            line: loc && loc.start.line,\n            column: loc && loc.start.column\n        },\n        end: {\n            line: loc && loc.end.line,\n            column: loc && loc.end.column\n        }\n    };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\nclass SourceCoverage extends classes.FileCoverage {\n    constructor(pathOrObj) {\n        super(pathOrObj);\n        this.meta = {\n            last: {\n                s: 0,\n                f: 0,\n                b: 0\n            }\n        };\n    }\n\n    newStatement(loc) {\n        const s = this.meta.last.s;\n        this.data.statementMap[s] = cloneLocation(loc);\n        this.data.s[s] = 0;\n        this.meta.last.s += 1;\n        return s;\n    }\n\n    newFunction(name, decl, loc) {\n        const f = this.meta.last.f;\n        name = name || '(anonymous_' + f + ')';\n        this.data.fnMap[f] = {\n            name,\n            decl: cloneLocation(decl),\n            loc: cloneLocation(loc),\n            // DEPRECATED: some legacy reports require this info.\n            line: loc && loc.start.line\n        };\n        this.data.f[f] = 0;\n        this.meta.last.f += 1;\n        return f;\n    }\n\n    newBranch(type, loc, isReportLogic = false) {\n        const b = this.meta.last.b;\n        this.data.b[b] = [];\n        this.data.branchMap[b] = {\n            loc: cloneLocation(loc),\n            type,\n            locations: [],\n            // DEPRECATED: some legacy reports require this info.\n            line: loc && loc.start.line\n        };\n        this.meta.last.b += 1;\n        this.maybeNewBranchTrue(type, b, isReportLogic);\n        return b;\n    }\n\n    maybeNewBranchTrue(type, name, isReportLogic) {\n        if (!isReportLogic) {\n            return;\n        }\n        if (type !== 'binary-expr') {\n            return;\n        }\n        this.data.bT = this.data.bT || {};\n        this.data.bT[name] = [];\n    }\n\n    addBranchPath(name, location) {\n        const bMeta = this.data.branchMap[name];\n        const counts = this.data.b[name];\n\n        /* istanbul ignore if: paranoid check */\n        if (!bMeta) {\n            throw new Error('Invalid branch ' + name);\n        }\n        bMeta.locations.push(cloneLocation(location));\n        counts.push(0);\n        this.maybeAddBranchTrue(name);\n        return counts.length - 1;\n    }\n\n    maybeAddBranchTrue(name) {\n        if (!this.data.bT) {\n            return;\n        }\n        const countsTrue = this.data.bT[name];\n        if (!countsTrue) {\n            return;\n        }\n        countsTrue.push(0);\n    }\n\n    /**\n     * Assigns an input source map to the coverage that can be used\n     * to remap the coverage output to the original source\n     * @param sourceMap {object} the source map\n     */\n    inputSourceMap(sourceMap) {\n        this.data.inputSourceMap = sourceMap;\n    }\n\n    freeze() {\n        // prune empty branches\n        const map = this.data.branchMap;\n        const branches = this.data.b;\n        const branchesT = this.data.bT || {};\n        Object.keys(map).forEach(b => {\n            if (map[b].locations.length === 0) {\n                delete map[b];\n                delete branches[b];\n                delete branchesT[b];\n            }\n        });\n    }\n}\n\nmodule.exports = { SourceCoverage };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}