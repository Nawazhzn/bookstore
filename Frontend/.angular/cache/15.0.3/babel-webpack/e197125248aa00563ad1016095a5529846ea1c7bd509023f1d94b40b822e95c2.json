{"ast":null,"code":"'use strict';\n\nconst Jobs = require('qjobs');\nconst log = require('./logger').create('launcher');\nconst baseDecorator = require('./launchers/base').decoratorFactory;\nconst captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory;\nconst retryDecorator = require('./launchers/retry').decoratorFactory;\nconst processDecorator = require('./launchers/process').decoratorFactory;\n\n// TODO(vojta): remove once nobody uses it\nconst baseBrowserDecoratorFactory = function (baseLauncherDecorator, captureTimeoutLauncherDecorator, retryLauncherDecorator, processLauncherDecorator, processKillTimeout) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher);\n    captureTimeoutLauncherDecorator(launcher);\n    retryLauncherDecorator(launcher);\n    processLauncherDecorator(launcher, processKillTimeout);\n  };\n};\nclass Launcher {\n  constructor(server, emitter, injector) {\n    this._server = server;\n    this._emitter = emitter;\n    this._injector = injector;\n    this._browsers = [];\n    this._lastStartTime = null;\n\n    // Attach list of dependency injection parameters to methods.\n    this.launch.$inject = ['config.browsers', 'config.concurrency'];\n    this.launchSingle.$inject = ['config.protocol', 'config.hostname', 'config.port', 'config.urlRoot', 'config.upstreamProxy', 'config.processKillTimeout'];\n    this._emitter.on('exit', callback => this.killAll(callback));\n  }\n  getBrowserById(id) {\n    return this._browsers.find(browser => browser.id === id);\n  }\n  launchSingle(protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    if (upstreamProxy) {\n      protocol = upstreamProxy.protocol;\n      hostname = upstreamProxy.hostname;\n      port = upstreamProxy.port;\n      urlRoot = upstreamProxy.path + urlRoot.slice(1);\n    }\n    return name => {\n      let browser;\n      const locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      };\n\n      // TODO(vojta): determine script from name\n      if (name.includes('/')) {\n        name = 'Script';\n      }\n      try {\n        browser = this._injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name);\n      } catch (e) {\n        if (e.message.includes(`No provider for \"launcher:${name}\"`)) {\n          log.error(`Cannot load browser \"${name}\": it is not registered! Perhaps you are missing some plugin?`);\n        } else {\n          log.error(`Cannot load browser \"${name}\"!\\n  ` + e.stack);\n        }\n        this._emitter.emit('load_error', 'launcher', name);\n        return;\n      }\n      this.jobs.add((args, done) => {\n        log.info(`Starting browser ${browser.displayName || browser.name}`);\n        browser.on('browser_process_failure', () => done(browser.error));\n        browser.on('done', () => {\n          if (!browser.error && browser.state !== browser.STATE_RESTARTING) {\n            done(null, browser);\n          }\n        });\n        browser.start(`${protocol}//${hostname}:${port}${urlRoot}`);\n      }, []);\n      this.jobs.run();\n      this._browsers.push(browser);\n    };\n  }\n  launch(names, concurrency) {\n    log.info(`Launching browsers ${names.join(', ')} with concurrency ${concurrency === Infinity ? 'unlimited' : concurrency}`);\n    this.jobs = new Jobs({\n      maxConcurrency: concurrency\n    });\n    this._lastStartTime = Date.now();\n    if (this._server.loadErrors.length) {\n      this.jobs.add((args, done) => done(), []);\n    } else {\n      names.forEach(name => this._injector.invoke(this.launchSingle, this)(name));\n    }\n    this.jobs.on('end', err => {\n      log.debug('Finished all browsers');\n      if (err) {\n        log.error(err);\n      }\n    });\n    this.jobs.run();\n    return this._browsers;\n  }\n  kill(id, callback) {\n    callback = callback || function () {};\n    const browser = this.getBrowserById(id);\n    if (browser) {\n      browser.forceKill().then(callback);\n      return true;\n    }\n    process.nextTick(callback);\n    return false;\n  }\n  restart(id) {\n    const browser = this.getBrowserById(id);\n    if (browser) {\n      browser.restart();\n      return true;\n    }\n    return false;\n  }\n  killAll(callback) {\n    callback = callback || function () {};\n    log.debug('Disconnecting all browsers');\n    if (!this._browsers.length) {\n      return process.nextTick(callback);\n    }\n    Promise.all(this._browsers.map(browser => browser.forceKill())).then(callback);\n  }\n  areAllCaptured() {\n    return this._browsers.every(browser => browser.isCaptured());\n  }\n  markCaptured(id) {\n    const browser = this.getBrowserById(id);\n    if (browser) {\n      browser.markCaptured();\n      log.debug(`${browser.name} (id ${browser.id}) captured in ${(Date.now() - this._lastStartTime) / 1000} secs`);\n    }\n  }\n  static generateId() {\n    return Math.floor(Math.random() * 100000000).toString();\n  }\n}\nLauncher.factory = function (server, emitter, injector) {\n  return new Launcher(server, emitter, injector);\n};\nLauncher.factory.$inject = ['server', 'emitter', 'injector'];\nexports.Launcher = Launcher;","map":{"version":3,"names":["Jobs","require","log","create","baseDecorator","decoratorFactory","captureTimeoutDecorator","retryDecorator","processDecorator","baseBrowserDecoratorFactory","baseLauncherDecorator","captureTimeoutLauncherDecorator","retryLauncherDecorator","processLauncherDecorator","processKillTimeout","launcher","Launcher","constructor","server","emitter","injector","_server","_emitter","_injector","_browsers","_lastStartTime","launch","$inject","launchSingle","on","callback","killAll","getBrowserById","id","find","browser","protocol","hostname","port","urlRoot","upstreamProxy","path","slice","name","locals","generateId","baseBrowserDecorator","includes","createChild","get","e","message","error","stack","emit","jobs","add","args","done","info","displayName","state","STATE_RESTARTING","start","run","push","names","concurrency","join","Infinity","maxConcurrency","Date","now","loadErrors","length","forEach","invoke","err","debug","kill","forceKill","then","process","nextTick","restart","Promise","all","map","areAllCaptured","every","isCaptured","markCaptured","Math","floor","random","toString","factory","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/karma/lib/launcher.js"],"sourcesContent":["'use strict'\n\nconst Jobs = require('qjobs')\n\nconst log = require('./logger').create('launcher')\n\nconst baseDecorator = require('./launchers/base').decoratorFactory\nconst captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory\nconst retryDecorator = require('./launchers/retry').decoratorFactory\nconst processDecorator = require('./launchers/process').decoratorFactory\n\n// TODO(vojta): remove once nobody uses it\nconst baseBrowserDecoratorFactory = function (\n  baseLauncherDecorator,\n  captureTimeoutLauncherDecorator,\n  retryLauncherDecorator,\n  processLauncherDecorator,\n  processKillTimeout\n) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher)\n    captureTimeoutLauncherDecorator(launcher)\n    retryLauncherDecorator(launcher)\n    processLauncherDecorator(launcher, processKillTimeout)\n  }\n}\n\nclass Launcher {\n  constructor (server, emitter, injector) {\n    this._server = server\n    this._emitter = emitter\n    this._injector = injector\n    this._browsers = []\n    this._lastStartTime = null\n\n    // Attach list of dependency injection parameters to methods.\n    this.launch.$inject = [\n      'config.browsers',\n      'config.concurrency'\n    ]\n\n    this.launchSingle.$inject = [\n      'config.protocol',\n      'config.hostname',\n      'config.port',\n      'config.urlRoot',\n      'config.upstreamProxy',\n      'config.processKillTimeout'\n    ]\n\n    this._emitter.on('exit', (callback) => this.killAll(callback))\n  }\n\n  getBrowserById (id) {\n    return this._browsers.find((browser) => browser.id === id)\n  }\n\n  launchSingle (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    if (upstreamProxy) {\n      protocol = upstreamProxy.protocol\n      hostname = upstreamProxy.hostname\n      port = upstreamProxy.port\n      urlRoot = upstreamProxy.path + urlRoot.slice(1)\n    }\n\n    return (name) => {\n      let browser\n      const locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      }\n\n      // TODO(vojta): determine script from name\n      if (name.includes('/')) {\n        name = 'Script'\n      }\n\n      try {\n        browser = this._injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)\n      } catch (e) {\n        if (e.message.includes(`No provider for \"launcher:${name}\"`)) {\n          log.error(`Cannot load browser \"${name}\": it is not registered! Perhaps you are missing some plugin?`)\n        } else {\n          log.error(`Cannot load browser \"${name}\"!\\n  ` + e.stack)\n        }\n\n        this._emitter.emit('load_error', 'launcher', name)\n        return\n      }\n\n      this.jobs.add((args, done) => {\n        log.info(`Starting browser ${browser.displayName || browser.name}`)\n\n        browser.on('browser_process_failure', () => done(browser.error))\n\n        browser.on('done', () => {\n          if (!browser.error && browser.state !== browser.STATE_RESTARTING) {\n            done(null, browser)\n          }\n        })\n\n        browser.start(`${protocol}//${hostname}:${port}${urlRoot}`)\n      }, [])\n\n      this.jobs.run()\n      this._browsers.push(browser)\n    }\n  }\n\n  launch (names, concurrency) {\n    log.info(`Launching browsers ${names.join(', ')} with concurrency ${concurrency === Infinity ? 'unlimited' : concurrency}`)\n    this.jobs = new Jobs({ maxConcurrency: concurrency })\n\n    this._lastStartTime = Date.now()\n\n    if (this._server.loadErrors.length) {\n      this.jobs.add((args, done) => done(), [])\n    } else {\n      names.forEach((name) => this._injector.invoke(this.launchSingle, this)(name))\n    }\n\n    this.jobs.on('end', (err) => {\n      log.debug('Finished all browsers')\n\n      if (err) {\n        log.error(err)\n      }\n    })\n\n    this.jobs.run()\n\n    return this._browsers\n  }\n\n  kill (id, callback) {\n    callback = callback || function () {}\n    const browser = this.getBrowserById(id)\n\n    if (browser) {\n      browser.forceKill().then(callback)\n      return true\n    }\n    process.nextTick(callback)\n    return false\n  }\n\n  restart (id) {\n    const browser = this.getBrowserById(id)\n    if (browser) {\n      browser.restart()\n      return true\n    }\n    return false\n  }\n\n  killAll (callback) {\n    callback = callback || function () {}\n    log.debug('Disconnecting all browsers')\n\n    if (!this._browsers.length) {\n      return process.nextTick(callback)\n    }\n\n    Promise.all(\n      this._browsers\n        .map((browser) => browser.forceKill())\n    ).then(callback)\n  }\n\n  areAllCaptured () {\n    return this._browsers.every((browser) => browser.isCaptured())\n  }\n\n  markCaptured (id) {\n    const browser = this.getBrowserById(id)\n    if (browser) {\n      browser.markCaptured()\n      log.debug(`${browser.name} (id ${browser.id}) captured in ${(Date.now() - this._lastStartTime) / 1000} secs`)\n    }\n  }\n\n  static generateId () {\n    return Math.floor(Math.random() * 100000000).toString()\n  }\n}\n\nLauncher.factory = function (server, emitter, injector) {\n  return new Launcher(server, emitter, injector)\n}\n\nLauncher.factory.$inject = ['server', 'emitter', 'injector']\n\nexports.Launcher = Launcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}