{"ast":null,"code":"\"use strict\";\n\nconst Range = require(\"./Range\");\n/** @typedef {import(\"../validate\").Schema} Schema */\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\nmodule.exports.stringHints = function stringHints(schema, logic) {\n  const hints = [];\n  let type = \"string\";\n  const currentSchema = {\n    ...schema\n  };\n  if (!logic) {\n    const tmpLength = currentSchema.minLength;\n    const tmpFormat = currentSchema.formatMinimum;\n    currentSchema.minLength = currentSchema.maxLength;\n    currentSchema.maxLength = tmpLength;\n    currentSchema.formatMinimum = currentSchema.formatMaximum;\n    currentSchema.formatMaximum = tmpFormat;\n  }\n  if (typeof currentSchema.minLength === \"number\") {\n    if (currentSchema.minLength === 1) {\n      type = \"non-empty string\";\n    } else {\n      const length = Math.max(currentSchema.minLength - 1, 0);\n      hints.push(`should be longer than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n  if (typeof currentSchema.maxLength === \"number\") {\n    if (currentSchema.maxLength === 0) {\n      type = \"empty string\";\n    } else {\n      const length = currentSchema.maxLength + 1;\n      hints.push(`should be shorter than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n  if (currentSchema.pattern) {\n    hints.push(`should${logic ? \"\" : \" not\"} match pattern ${JSON.stringify(currentSchema.pattern)}`);\n  }\n  if (currentSchema.format) {\n    hints.push(`should${logic ? \"\" : \" not\"} match format ${JSON.stringify(currentSchema.format)}`);\n  }\n  if (currentSchema.formatMinimum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMinimum ? \">\" : \">=\"} ${JSON.stringify(currentSchema.formatMinimum)}`);\n  }\n  if (currentSchema.formatMaximum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMaximum ? \"<\" : \"<=\"} ${JSON.stringify(currentSchema.formatMaximum)}`);\n  }\n  return [type].concat(hints);\n};\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\nmodule.exports.numberHints = function numberHints(schema, logic) {\n  const hints = [schema.type === \"integer\" ? \"integer\" : \"number\"];\n  const range = new Range();\n  if (typeof schema.minimum === \"number\") {\n    range.left(schema.minimum);\n  }\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    range.left(schema.exclusiveMinimum, true);\n  }\n  if (typeof schema.maximum === \"number\") {\n    range.right(schema.maximum);\n  }\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    range.right(schema.exclusiveMaximum, true);\n  }\n  const rangeFormat = range.format(logic);\n  if (rangeFormat) {\n    hints.push(rangeFormat);\n  }\n  if (typeof schema.multipleOf === \"number\") {\n    hints.push(`should${logic ? \"\" : \" not\"} be multiple of ${schema.multipleOf}`);\n  }\n  return hints;\n};","map":{"version":3,"names":["Range","require","module","exports","stringHints","schema","logic","hints","type","currentSchema","tmpLength","minLength","tmpFormat","formatMinimum","maxLength","formatMaximum","length","Math","max","push","pattern","JSON","stringify","format","formatExclusiveMinimum","formatExclusiveMaximum","concat","numberHints","range","minimum","left","exclusiveMinimum","maximum","right","exclusiveMaximum","rangeFormat","multipleOf"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/schema-utils/dist/util/hints.js"],"sourcesContent":["\"use strict\";\n\nconst Range = require(\"./Range\");\n/** @typedef {import(\"../validate\").Schema} Schema */\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\n\nmodule.exports.stringHints = function stringHints(schema, logic) {\n  const hints = [];\n  let type = \"string\";\n  const currentSchema = { ...schema\n  };\n\n  if (!logic) {\n    const tmpLength = currentSchema.minLength;\n    const tmpFormat = currentSchema.formatMinimum;\n    currentSchema.minLength = currentSchema.maxLength;\n    currentSchema.maxLength = tmpLength;\n    currentSchema.formatMinimum = currentSchema.formatMaximum;\n    currentSchema.formatMaximum = tmpFormat;\n  }\n\n  if (typeof currentSchema.minLength === \"number\") {\n    if (currentSchema.minLength === 1) {\n      type = \"non-empty string\";\n    } else {\n      const length = Math.max(currentSchema.minLength - 1, 0);\n      hints.push(`should be longer than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n\n  if (typeof currentSchema.maxLength === \"number\") {\n    if (currentSchema.maxLength === 0) {\n      type = \"empty string\";\n    } else {\n      const length = currentSchema.maxLength + 1;\n      hints.push(`should be shorter than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n\n  if (currentSchema.pattern) {\n    hints.push(`should${logic ? \"\" : \" not\"} match pattern ${JSON.stringify(currentSchema.pattern)}`);\n  }\n\n  if (currentSchema.format) {\n    hints.push(`should${logic ? \"\" : \" not\"} match format ${JSON.stringify(currentSchema.format)}`);\n  }\n\n  if (currentSchema.formatMinimum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMinimum ? \">\" : \">=\"} ${JSON.stringify(currentSchema.formatMinimum)}`);\n  }\n\n  if (currentSchema.formatMaximum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMaximum ? \"<\" : \"<=\"} ${JSON.stringify(currentSchema.formatMaximum)}`);\n  }\n\n  return [type].concat(hints);\n};\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\n\nmodule.exports.numberHints = function numberHints(schema, logic) {\n  const hints = [schema.type === \"integer\" ? \"integer\" : \"number\"];\n  const range = new Range();\n\n  if (typeof schema.minimum === \"number\") {\n    range.left(schema.minimum);\n  }\n\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    range.left(schema.exclusiveMinimum, true);\n  }\n\n  if (typeof schema.maximum === \"number\") {\n    range.right(schema.maximum);\n  }\n\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    range.right(schema.exclusiveMaximum, true);\n  }\n\n  const rangeFormat = range.format(logic);\n\n  if (rangeFormat) {\n    hints.push(rangeFormat);\n  }\n\n  if (typeof schema.multipleOf === \"number\") {\n    hints.push(`should${logic ? \"\" : \" not\"} be multiple of ${schema.multipleOf}`);\n  }\n\n  return hints;\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}