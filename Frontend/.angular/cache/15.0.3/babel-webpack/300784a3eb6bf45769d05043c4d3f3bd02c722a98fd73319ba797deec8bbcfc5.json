{"ast":null,"code":"'use strict';\n\nconst log = require('./logger').create();\nclass Executor {\n  constructor(capturedBrowsers, config, emitter) {\n    this.capturedBrowsers = capturedBrowsers;\n    this.config = config;\n    this.emitter = emitter;\n    this.executionScheduled = false;\n    this.errorsScheduled = [];\n    this.pendingCount = 0;\n    this.runningBrowsers = null;\n    this.emitter.on('run_complete', () => this.onRunComplete());\n    this.emitter.on('browser_complete', () => this.onBrowserComplete());\n  }\n  schedule() {\n    if (this.capturedBrowsers.length === 0) {\n      log.warn(`No captured browser, open ${this.config.protocol}//${this.config.hostname}:${this.config.port}${this.config.urlRoot}`);\n      return false;\n    } else if (this.capturedBrowsers.areAllReady()) {\n      log.debug('All browsers are ready, executing');\n      log.debug(`Captured ${this.capturedBrowsers.length} browsers`);\n      this.executionScheduled = false;\n      this.capturedBrowsers.clearResults();\n      this.pendingCount = this.capturedBrowsers.length;\n      this.runningBrowsers = this.capturedBrowsers.clone();\n      this.emitter.emit('run_start', this.runningBrowsers);\n      this.socketIoSockets.emit('execute', this.config.client);\n      return true;\n    } else {\n      log.info('Delaying execution, these browsers are not ready: ' + this.capturedBrowsers.getNonReady().join(', '));\n      this.executionScheduled = true;\n      return false;\n    }\n  }\n\n  /**\n   * Schedule an error to be reported\n   * @param {string} errorMessage\n   * @returns {boolean} a boolean indicating whether or not the error was handled synchronously\n   */\n  scheduleError(errorMessage) {\n    // We don't want to interfere with any running test.\n    // Verify that no test is running before reporting the error.\n    if (this.capturedBrowsers.areAllReady()) {\n      log.warn(errorMessage);\n      const errorResult = {\n        success: 0,\n        failed: 0,\n        skipped: 0,\n        error: errorMessage,\n        exitCode: 1\n      };\n      const noBrowsersStartedTests = [];\n      this.emitter.emit('run_start', noBrowsersStartedTests); // A run cannot complete without being started\n      this.emitter.emit('run_complete', noBrowsersStartedTests, errorResult);\n      return true;\n    } else {\n      this.errorsScheduled.push(errorMessage);\n      return false;\n    }\n  }\n  onRunComplete() {\n    if (this.executionScheduled) {\n      this.schedule();\n    }\n    if (this.errorsScheduled.length) {\n      const errorsToReport = this.errorsScheduled;\n      this.errorsScheduled = [];\n      errorsToReport.forEach(error => this.scheduleError(error));\n    }\n  }\n  onBrowserComplete() {\n    this.pendingCount--;\n    if (!this.pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(() => {\n        this.emitter.emit('run_complete', this.runningBrowsers, this.runningBrowsers.getResults());\n      });\n    }\n  }\n}\nExecutor.factory = function (capturedBrowsers, config, emitter) {\n  return new Executor(capturedBrowsers, config, emitter);\n};\nmodule.exports = Executor;","map":{"version":3,"names":["log","require","create","Executor","constructor","capturedBrowsers","config","emitter","executionScheduled","errorsScheduled","pendingCount","runningBrowsers","on","onRunComplete","onBrowserComplete","schedule","length","warn","protocol","hostname","port","urlRoot","areAllReady","debug","clearResults","clone","emit","socketIoSockets","client","info","getNonReady","join","scheduleError","errorMessage","errorResult","success","failed","skipped","error","exitCode","noBrowsersStartedTests","push","errorsToReport","forEach","setTimeout","getResults","factory","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/karma/lib/executor.js"],"sourcesContent":["'use strict'\n\nconst log = require('./logger').create()\n\nclass Executor {\n  constructor (capturedBrowsers, config, emitter) {\n    this.capturedBrowsers = capturedBrowsers\n    this.config = config\n    this.emitter = emitter\n\n    this.executionScheduled = false\n    this.errorsScheduled = []\n    this.pendingCount = 0\n    this.runningBrowsers = null\n\n    this.emitter.on('run_complete', () => this.onRunComplete())\n    this.emitter.on('browser_complete', () => this.onBrowserComplete())\n  }\n\n  schedule () {\n    if (this.capturedBrowsers.length === 0) {\n      log.warn(`No captured browser, open ${this.config.protocol}//${this.config.hostname}:${this.config.port}${this.config.urlRoot}`)\n      return false\n    } else if (this.capturedBrowsers.areAllReady()) {\n      log.debug('All browsers are ready, executing')\n      log.debug(`Captured ${this.capturedBrowsers.length} browsers`)\n      this.executionScheduled = false\n      this.capturedBrowsers.clearResults()\n      this.pendingCount = this.capturedBrowsers.length\n      this.runningBrowsers = this.capturedBrowsers.clone()\n      this.emitter.emit('run_start', this.runningBrowsers)\n      this.socketIoSockets.emit('execute', this.config.client)\n      return true\n    } else {\n      log.info('Delaying execution, these browsers are not ready: ' + this.capturedBrowsers.getNonReady().join(', '))\n      this.executionScheduled = true\n      return false\n    }\n  }\n\n  /**\n   * Schedule an error to be reported\n   * @param {string} errorMessage\n   * @returns {boolean} a boolean indicating whether or not the error was handled synchronously\n   */\n  scheduleError (errorMessage) {\n    // We don't want to interfere with any running test.\n    // Verify that no test is running before reporting the error.\n    if (this.capturedBrowsers.areAllReady()) {\n      log.warn(errorMessage)\n      const errorResult = {\n        success: 0,\n        failed: 0,\n        skipped: 0,\n        error: errorMessage,\n        exitCode: 1\n      }\n      const noBrowsersStartedTests = []\n      this.emitter.emit('run_start', noBrowsersStartedTests) // A run cannot complete without being started\n      this.emitter.emit('run_complete', noBrowsersStartedTests, errorResult)\n      return true\n    } else {\n      this.errorsScheduled.push(errorMessage)\n      return false\n    }\n  }\n\n  onRunComplete () {\n    if (this.executionScheduled) {\n      this.schedule()\n    }\n    if (this.errorsScheduled.length) {\n      const errorsToReport = this.errorsScheduled\n      this.errorsScheduled = []\n      errorsToReport.forEach((error) => this.scheduleError(error))\n    }\n  }\n\n  onBrowserComplete () {\n    this.pendingCount--\n\n    if (!this.pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(() => {\n        this.emitter.emit('run_complete', this.runningBrowsers, this.runningBrowsers.getResults())\n      })\n    }\n  }\n}\n\nExecutor.factory = function (capturedBrowsers, config, emitter) {\n  return new Executor(capturedBrowsers, config, emitter)\n}\n\nmodule.exports = Executor\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}