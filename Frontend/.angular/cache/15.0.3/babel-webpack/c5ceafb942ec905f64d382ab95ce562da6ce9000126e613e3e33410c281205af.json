{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, function () {\n  'use strict';\n\n  // Matches the scheme of a URL, eg \"http://\"\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   * 6. Query, including \"?\", optional.\n   * 7. Hash, including \"#\", optional.\n   */\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may include \"/\", guaranteed.\n   * 3. Query, including \"?\", optional.\n   * 4. Hash, including \"#\", optional.\n   */\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  var UrlType;\n  (function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n  })(UrlType || (UrlType = {}));\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n  }\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n  }\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      query,\n      hash,\n      type: UrlType.Absolute\n    };\n  }\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      url.type = UrlType.SchemeRelative;\n      return url;\n    }\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      url.type = UrlType.AbsolutePath;\n      return url;\n    }\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n    return url;\n  }\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  function mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n  function normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i];\n      // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      }\n      // If we encounter a real directory, then we don't need to append anymore.\n      addTrailingSlash = false;\n      // A current directory, which we can always drop.\n      if (piece === '.') continue;\n      // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n        continue;\n      }\n      // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n      pieces[pointer++] = piece;\n      positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n  function resolve(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n      switch (inputType) {\n        case UrlType.Empty:\n          url.hash = baseUrl.hash;\n        // fall through\n        case UrlType.Hash:\n          url.query = baseUrl.query;\n        // fall through\n        case UrlType.Query:\n        case UrlType.RelativePath:\n          mergePaths(url, baseUrl);\n        // fall through\n        case UrlType.AbsolutePath:\n          // The host, user, and port are joined, you can't copy one without the others.\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        // fall through\n        case UrlType.SchemeRelative:\n          // The input doesn't have a schema at least, so we need to copy at least that over.\n          url.scheme = baseUrl.scheme;\n      }\n      if (baseType > inputType) inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n      // This is impossible, because of the empty checks at the start of the function.\n      // case UrlType.Empty:\n      case UrlType.Hash:\n      case UrlType.Query:\n        return queryHash;\n      case UrlType.RelativePath:\n        {\n          // The first char is always a \"/\", and we need it to be relative.\n          const path = url.path.slice(1);\n          if (!path) return queryHash || '.';\n          if (isRelative(base || input) && !isRelative(path)) {\n            // If base started with a leading \".\", or there is no base and input started with a \".\",\n            // then we need to ensure that the relative path starts with a \".\". We don't know if\n            // relative starts with a \"..\", though, so check before prepending.\n            return './' + path + queryHash;\n          }\n          return path + queryHash;\n        }\n      case UrlType.AbsolutePath:\n        return url.path + queryHash;\n      default:\n        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n  return resolve;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","resolveURI","schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","Query","Hash","RelativePath","Empty","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","inputType","baseUrl","baseType","queryHash"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    var UrlType;\n    (function (UrlType) {\n        UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n        UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n        UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n        UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n        UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n        UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n        UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n    })(UrlType || (UrlType = {}));\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: UrlType.Absolute,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = UrlType.SchemeRelative;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = UrlType.AbsolutePath;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? UrlType.Query\n                : input.startsWith('#')\n                    ? UrlType.Hash\n                    : UrlType.RelativePath\n            : UrlType.Empty;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= UrlType.RelativePath;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== UrlType.Absolute) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case UrlType.Empty:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case UrlType.Hash:\n                    url.query = baseUrl.query;\n                // fall through\n                case UrlType.Query:\n                case UrlType.RelativePath:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case UrlType.AbsolutePath:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case UrlType.SchemeRelative:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case UrlType.Hash:\n            case UrlType.Query:\n                return queryHash;\n            case UrlType.RelativePath: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case UrlType.AbsolutePath:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}