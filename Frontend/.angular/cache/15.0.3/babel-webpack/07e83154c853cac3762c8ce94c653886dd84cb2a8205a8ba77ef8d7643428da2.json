{"ast":null,"code":"\"use strict\";\n\n/*\n * Based on the packages get-port https://www.npmjs.com/package/get-port\n * and portfinder https://www.npmjs.com/package/portfinder\n * The code structure is similar to get-port, but it searches\n * ports deterministically like portfinder\n */\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst net = require(\"net\");\nconst os = require(\"os\");\nconst minPort = 1024;\nconst maxPort = 65_535;\n\n/**\n * @return {Set<string|undefined>}\n */\nconst getLocalHosts = () => {\n  const interfaces = os.networkInterfaces();\n\n  // Add undefined value for createServer function to use default host,\n  // and default IPv4 host in case createServer defaults to IPv6.\n  // eslint-disable-next-line no-undefined\n  const results = new Set([undefined, \"0.0.0.0\"]);\n  for (const _interface of Object.values(interfaces)) {\n    if (_interface) {\n      for (const config of _interface) {\n        results.add(config.address);\n      }\n    }\n  }\n  return results;\n};\n\n/**\n * @param {number} basePort\n * @param {string | undefined} host\n * @return {Promise<number>}\n */\nconst checkAvailablePort = (basePort, host) => new Promise((resolve, reject) => {\n  const server = net.createServer();\n  server.unref();\n  server.on(\"error\", reject);\n  server.listen(basePort, host, () => {\n    // Next line should return AdressInfo because we're calling it after listen() and before close()\n    const {\n      port\n    } = /** @type {import(\"net\").AddressInfo} */\n    server.address();\n    server.close(() => {\n      resolve(port);\n    });\n  });\n});\n\n/**\n * @param {number} port\n * @param {Set<string|undefined>} hosts\n * @return {Promise<number>}\n */\nconst getAvailablePort = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (port, hosts) {\n    /**\n     * Errors that mean that host is not available.\n     * @type {Set<string | undefined>}\n     */\n    const nonExistentInterfaceErrors = new Set([\"EADDRNOTAVAIL\", \"EINVAL\"]);\n    /* Check if the post is available on every local host name */\n    for (const host of hosts) {\n      try {\n        yield checkAvailablePort(port, host); // eslint-disable-line no-await-in-loop\n      } catch (error) {\n        /* We throw an error only if the interface exists */\n        if (!nonExistentInterfaceErrors.has( /** @type {NodeJS.ErrnoException} */error.code)) {\n          throw error;\n        }\n      }\n    }\n    return port;\n  });\n  return function getAvailablePort(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {number} basePort\n * @param {string=} host\n * @return {Promise<number>}\n */\nfunction getPorts(_x3, _x4) {\n  return _getPorts.apply(this, arguments);\n}\nfunction _getPorts() {\n  _getPorts = _asyncToGenerator(function* (basePort, host) {\n    if (basePort < minPort || basePort > maxPort) {\n      throw new Error(`Port number must lie between ${minPort} and ${maxPort}`);\n    }\n    let port = basePort;\n    const localhosts = getLocalHosts();\n    let hosts;\n    if (host && !localhosts.has(host)) {\n      hosts = new Set([host]);\n    } else {\n      /* If the host is equivalent to localhost\n         we need to check every equivalent host\n         else the port might falsely appear as available\n         on some operating systems  */\n      hosts = localhosts;\n    }\n    /** @type {Set<string | undefined>} */\n    const portUnavailableErrors = new Set([\"EADDRINUSE\", \"EACCES\"]);\n    while (port <= maxPort) {\n      try {\n        const availablePort = yield getAvailablePort(port, hosts); // eslint-disable-line no-await-in-loop\n        return availablePort;\n      } catch (error) {\n        /* Try next port if port is busy; throw for any other error */\n        if (!portUnavailableErrors.has( /** @type {NodeJS.ErrnoException} */error.code)) {\n          throw error;\n        }\n        port += 1;\n      }\n    }\n    throw new Error(\"No available ports found\");\n  });\n  return _getPorts.apply(this, arguments);\n}\nmodule.exports = getPorts;","map":{"version":3,"names":["net","require","os","minPort","maxPort","getLocalHosts","interfaces","networkInterfaces","results","Set","undefined","_interface","Object","values","config","add","address","checkAvailablePort","basePort","host","Promise","resolve","reject","server","createServer","unref","on","listen","port","close","getAvailablePort","hosts","nonExistentInterfaceErrors","error","has","code","getPorts","Error","localhosts","portUnavailableErrors","availablePort","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/webpack-dev-server/lib/getPort.js"],"sourcesContent":["\"use strict\";\n\n/*\n * Based on the packages get-port https://www.npmjs.com/package/get-port\n * and portfinder https://www.npmjs.com/package/portfinder\n * The code structure is similar to get-port, but it searches\n * ports deterministically like portfinder\n */\nconst net = require(\"net\");\nconst os = require(\"os\");\n\nconst minPort = 1024;\nconst maxPort = 65_535;\n\n/**\n * @return {Set<string|undefined>}\n */\nconst getLocalHosts = () => {\n  const interfaces = os.networkInterfaces();\n\n  // Add undefined value for createServer function to use default host,\n  // and default IPv4 host in case createServer defaults to IPv6.\n  // eslint-disable-next-line no-undefined\n  const results = new Set([undefined, \"0.0.0.0\"]);\n\n  for (const _interface of Object.values(interfaces)) {\n    if (_interface) {\n      for (const config of _interface) {\n        results.add(config.address);\n      }\n    }\n  }\n\n  return results;\n};\n\n/**\n * @param {number} basePort\n * @param {string | undefined} host\n * @return {Promise<number>}\n */\nconst checkAvailablePort = (basePort, host) =>\n  new Promise((resolve, reject) => {\n    const server = net.createServer();\n    server.unref();\n    server.on(\"error\", reject);\n\n    server.listen(basePort, host, () => {\n      // Next line should return AdressInfo because we're calling it after listen() and before close()\n      const { port } = /** @type {import(\"net\").AddressInfo} */ (\n        server.address()\n      );\n      server.close(() => {\n        resolve(port);\n      });\n    });\n  });\n\n/**\n * @param {number} port\n * @param {Set<string|undefined>} hosts\n * @return {Promise<number>}\n */\nconst getAvailablePort = async (port, hosts) => {\n  /**\n   * Errors that mean that host is not available.\n   * @type {Set<string | undefined>}\n   */\n  const nonExistentInterfaceErrors = new Set([\"EADDRNOTAVAIL\", \"EINVAL\"]);\n  /* Check if the post is available on every local host name */\n  for (const host of hosts) {\n    try {\n      await checkAvailablePort(port, host); // eslint-disable-line no-await-in-loop\n    } catch (error) {\n      /* We throw an error only if the interface exists */\n      if (\n        !nonExistentInterfaceErrors.has(\n          /** @type {NodeJS.ErrnoException} */ (error).code\n        )\n      ) {\n        throw error;\n      }\n    }\n  }\n\n  return port;\n};\n\n/**\n * @param {number} basePort\n * @param {string=} host\n * @return {Promise<number>}\n */\nasync function getPorts(basePort, host) {\n  if (basePort < minPort || basePort > maxPort) {\n    throw new Error(`Port number must lie between ${minPort} and ${maxPort}`);\n  }\n\n  let port = basePort;\n  const localhosts = getLocalHosts();\n  let hosts;\n  if (host && !localhosts.has(host)) {\n    hosts = new Set([host]);\n  } else {\n    /* If the host is equivalent to localhost\n       we need to check every equivalent host\n       else the port might falsely appear as available\n       on some operating systems  */\n    hosts = localhosts;\n  }\n  /** @type {Set<string | undefined>} */\n  const portUnavailableErrors = new Set([\"EADDRINUSE\", \"EACCES\"]);\n  while (port <= maxPort) {\n    try {\n      const availablePort = await getAvailablePort(port, hosts); // eslint-disable-line no-await-in-loop\n      return availablePort;\n    } catch (error) {\n      /* Try next port if port is busy; throw for any other error */\n      if (\n        !portUnavailableErrors.has(\n          /** @type {NodeJS.ErrnoException} */ (error).code\n        )\n      ) {\n        throw error;\n      }\n      port += 1;\n    }\n  }\n\n  throw new Error(\"No available ports found\");\n}\n\nmodule.exports = getPorts;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}