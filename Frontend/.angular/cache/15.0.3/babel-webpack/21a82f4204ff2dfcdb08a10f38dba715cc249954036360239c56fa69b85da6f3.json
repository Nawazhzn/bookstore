{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\nconst getHashDigest = require(\"./getHashDigest\");\nfunction interpolateName(loaderContext, name, options = {}) {\n  let filename;\n  const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n  if (typeof name === \"function\") {\n    filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : undefined);\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n    if (typeof context !== \"undefined\") {\n      directory = path.relative(context, resourcePath + \"_\").replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n    const hashIdx = query.indexOf(\"#\");\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n  let url = filename;\n  if (content) {\n    // Match hash template\n    url = url\n    // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^[:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10)));\n  }\n  url = url.replace(/\\[ext\\]/gi, () => ext).replace(/\\[name\\]/gi, () => basename).replace(/\\[path\\]/gi, () => directory).replace(/\\[folder\\]/gi, () => folder).replace(/\\[query\\]/gi, () => query);\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach((matched, i) => {\n      url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n    });\n  }\n  if (typeof loaderContext.options === \"object\" && typeof loaderContext.options.customInterpolateName === \"function\") {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n  return url;\n}\nmodule.exports = interpolateName;","map":{"version":3,"names":["path","require","getHashDigest","interpolateName","loaderContext","name","options","filename","hasQuery","resourceQuery","length","resourcePath","undefined","context","content","regExp","ext","basename","directory","folder","query","parsed","parse","substr","dir","sep","relative","replace","hashIdx","indexOf","url","all","hashType","digestType","maxLength","parseInt","match","RegExp","forEach","matched","i","customInterpolateName","call","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/loader-utils/lib/interpolateName.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\nconst getHashDigest = require(\"./getHashDigest\");\n\nfunction interpolateName(loaderContext, name, options = {}) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === \"function\") {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== \"undefined\") {\n      directory = path\n        .relative(context, resourcePath + \"_\")\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf(\"#\");\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^[:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === \"object\" &&\n    typeof loaderContext.options.customInterpolateName === \"function\"\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}