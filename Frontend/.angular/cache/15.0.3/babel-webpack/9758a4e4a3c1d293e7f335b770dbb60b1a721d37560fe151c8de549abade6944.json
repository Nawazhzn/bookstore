{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst helper = require('./helper');\nfunction bufferEvents(emitter, eventsToBuffer) {\n  const listeners = [];\n  const eventsToReply = [];\n  function genericListener() {\n    eventsToReply.push(Array.from(arguments));\n  }\n  eventsToBuffer.forEach(eventName => {\n    const listener = genericListener.bind(null, eventName);\n    listeners.push(listener);\n    emitter.on(eventName, listener);\n  });\n  return function () {\n    listeners.forEach((listener, i) => {\n      emitter.removeListener(eventsToBuffer[i], listener);\n    });\n    eventsToReply.forEach(args => {\n      EventEmitter.prototype.emit.apply(emitter, args);\n    });\n    listeners.length = 0;\n    eventsToReply.length = 0;\n  };\n}\nclass KarmaEventEmitter extends EventEmitter {\n  bind(object) {\n    for (const method in object) {\n      if (method.startsWith('on') && helper.isFunction(object[method])) {\n        this.on(helper.camelToSnake(method.slice(2)), function () {\n          // We do not use an arrow function here, to supply the caller as this.\n          object[method].apply(object, Array.from(arguments).concat(this));\n        });\n      }\n    }\n  }\n  emitAsync(name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    let pending = this.listeners(name).length;\n    const deferred = helper.defer();\n    this.emit(name, () => {\n      if (! --pending) {\n        deferred.resolve();\n      }\n    });\n    if (!pending) {\n      deferred.resolve();\n    }\n    return deferred.promise;\n  }\n}\nexports.EventEmitter = KarmaEventEmitter;\nexports.bufferEvents = bufferEvents;","map":{"version":3,"names":["EventEmitter","require","helper","bufferEvents","emitter","eventsToBuffer","listeners","eventsToReply","genericListener","push","Array","from","arguments","forEach","eventName","listener","bind","on","i","removeListener","args","prototype","emit","apply","length","KarmaEventEmitter","object","method","startsWith","isFunction","camelToSnake","slice","concat","emitAsync","name","pending","deferred","defer","resolve","promise","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/karma/lib/events.js"],"sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst helper = require('./helper')\n\nfunction bufferEvents (emitter, eventsToBuffer) {\n  const listeners = []\n  const eventsToReply = []\n\n  function genericListener () {\n    eventsToReply.push(Array.from(arguments))\n  }\n\n  eventsToBuffer.forEach((eventName) => {\n    const listener = genericListener.bind(null, eventName)\n    listeners.push(listener)\n    emitter.on(eventName, listener)\n  })\n\n  return function () {\n    listeners.forEach((listener, i) => {\n      emitter.removeListener(eventsToBuffer[i], listener)\n    })\n\n    eventsToReply.forEach((args) => {\n      EventEmitter.prototype.emit.apply(emitter, args)\n    })\n\n    listeners.length = 0\n    eventsToReply.length = 0\n  }\n}\n\nclass KarmaEventEmitter extends EventEmitter {\n  bind (object) {\n    for (const method in object) {\n      if (method.startsWith('on') && helper.isFunction(object[method])) {\n        this.on(helper.camelToSnake(method.slice(2)), function () {\n          // We do not use an arrow function here, to supply the caller as this.\n          object[method].apply(object, Array.from(arguments).concat(this))\n        })\n      }\n    }\n  }\n\n  emitAsync (name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    let pending = this.listeners(name).length\n    const deferred = helper.defer()\n\n    this.emit(name, () => {\n      if (!--pending) {\n        deferred.resolve()\n      }\n    })\n\n    if (!pending) {\n      deferred.resolve()\n    }\n\n    return deferred.promise\n  }\n}\n\nexports.EventEmitter = KarmaEventEmitter\nexports.bufferEvents = bufferEvents\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACD,YAAY;AACnD,MAAME,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAElC,SAASE,YAAY,CAAEC,OAAO,EAAEC,cAAc,EAAE;EAC9C,MAAMC,SAAS,GAAG,EAAE;EACpB,MAAMC,aAAa,GAAG,EAAE;EAExB,SAASC,eAAe,GAAI;IAC1BD,aAAa,CAACE,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC,CAAC;EAC3C;EAEAP,cAAc,CAACQ,OAAO,CAAEC,SAAS,IAAK;IACpC,MAAMC,QAAQ,GAAGP,eAAe,CAACQ,IAAI,CAAC,IAAI,EAAEF,SAAS,CAAC;IACtDR,SAAS,CAACG,IAAI,CAACM,QAAQ,CAAC;IACxBX,OAAO,CAACa,EAAE,CAACH,SAAS,EAAEC,QAAQ,CAAC;EACjC,CAAC,CAAC;EAEF,OAAO,YAAY;IACjBT,SAAS,CAACO,OAAO,CAAC,CAACE,QAAQ,EAAEG,CAAC,KAAK;MACjCd,OAAO,CAACe,cAAc,CAACd,cAAc,CAACa,CAAC,CAAC,EAAEH,QAAQ,CAAC;IACrD,CAAC,CAAC;IAEFR,aAAa,CAACM,OAAO,CAAEO,IAAI,IAAK;MAC9BpB,YAAY,CAACqB,SAAS,CAACC,IAAI,CAACC,KAAK,CAACnB,OAAO,EAAEgB,IAAI,CAAC;IAClD,CAAC,CAAC;IAEFd,SAAS,CAACkB,MAAM,GAAG,CAAC;IACpBjB,aAAa,CAACiB,MAAM,GAAG,CAAC;EAC1B,CAAC;AACH;AAEA,MAAMC,iBAAiB,SAASzB,YAAY,CAAC;EAC3CgB,IAAI,CAAEU,MAAM,EAAE;IACZ,KAAK,MAAMC,MAAM,IAAID,MAAM,EAAE;MAC3B,IAAIC,MAAM,CAACC,UAAU,CAAC,IAAI,CAAC,IAAI1B,MAAM,CAAC2B,UAAU,CAACH,MAAM,CAACC,MAAM,CAAC,CAAC,EAAE;QAChE,IAAI,CAACV,EAAE,CAACf,MAAM,CAAC4B,YAAY,CAACH,MAAM,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,YAAY;UACxD;UACAL,MAAM,CAACC,MAAM,CAAC,CAACJ,KAAK,CAACG,MAAM,EAAEhB,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC,CAACoB,MAAM,CAAC,IAAI,CAAC,CAAC;QAClE,CAAC,CAAC;MACJ;IACF;EACF;EAEAC,SAAS,CAAEC,IAAI,EAAE;IACf;IACA;IACA,IAAIC,OAAO,GAAG,IAAI,CAAC7B,SAAS,CAAC4B,IAAI,CAAC,CAACV,MAAM;IACzC,MAAMY,QAAQ,GAAGlC,MAAM,CAACmC,KAAK,EAAE;IAE/B,IAAI,CAACf,IAAI,CAACY,IAAI,EAAE,MAAM;MACpB,IAAI,CAAC,GAAEC,OAAO,EAAE;QACdC,QAAQ,CAACE,OAAO,EAAE;MACpB;IACF,CAAC,CAAC;IAEF,IAAI,CAACH,OAAO,EAAE;MACZC,QAAQ,CAACE,OAAO,EAAE;IACpB;IAEA,OAAOF,QAAQ,CAACG,OAAO;EACzB;AACF;AAEAC,OAAO,CAACxC,YAAY,GAAGyB,iBAAiB;AACxCe,OAAO,CAACrC,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}