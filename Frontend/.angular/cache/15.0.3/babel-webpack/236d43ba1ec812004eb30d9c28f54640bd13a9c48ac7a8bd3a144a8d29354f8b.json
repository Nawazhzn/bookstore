{"ast":null,"code":"const topologicalSort = require(\"./topologicalSort\");\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n    const siblings = visited[siblingsId];\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n    visited[visitedId] = VISITED_MARKER;\n    siblings.push(importId);\n  }\n}\nmodule.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName = typeof options.createImportedName !== \"function\" ? (importName /*, path*/) => `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}` : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules(rule => {\n            const matches = icssImport.exec(rule.selector);\n            if (matches) {\n              const [, /*match*/doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n              addImportToGraph(importPath, \"root\", graph, visited);\n              existingImports[importPath] = rule;\n            }\n          });\n          root.walkDecls(/^composes$/, declaration => {\n            const matches = declaration.value.match(matchImports);\n            if (!matches) {\n              return;\n            }\n            let tmpSymbols;\n            let [, /*match*/symbols, doubleQuotePath, singleQuotePath, global] = matches;\n            if (global) {\n              // Composing globals simply means changing these classes to wrap them in global(name)\n              tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`);\n            } else {\n              const importPath = doubleQuotePath || singleQuotePath;\n              let parent = declaration.parent;\n              let parentIndexes = \"\";\n              while (parent.type !== \"root\") {\n                parentIndexes = parent.parent.index(parent) + \"_\" + parentIndexes;\n                parent = parent.parent;\n              }\n              const {\n                selector\n              } = declaration.parent;\n              const parentRule = `_${parentIndexes}${selector}`;\n              addImportToGraph(importPath, parentRule, graph, visited);\n              importDecls[importPath] = declaration;\n              imports[importPath] = imports[importPath] || {};\n              tmpSymbols = symbols.split(/\\s+/).map(s => {\n                if (!imports[importPath][s]) {\n                  imports[importPath][s] = createImportedName(s, importPath);\n                }\n                return imports[importPath][s];\n              });\n            }\n            declaration.value = tmpSymbols.join(\" \");\n          });\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find(importPath =>\n            // eslint-disable-next-line no-prototype-builtins\n            importDecls.hasOwnProperty(importPath));\n            const decl = importDecls[importPath];\n            throw decl.error(\"Failed to resolve order of composed modules \" + importsOrder.nodes.map(importPath => \"`\" + importPath + \"`\").join(\", \") + \".\", {\n              plugin: \"postcss-modules-extract-imports\",\n              word: \"composes\"\n            });\n          }\n          let lastImportRule;\n          importsOrder.forEach(path => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: {\n                  after: \"\\n\"\n                }\n              });\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n            lastImportRule = rule;\n            if (!importedSymbols) {\n              return;\n            }\n            Object.keys(importedSymbols).forEach(importedSymbol => {\n              rule.append(postcss.decl({\n                value: importedSymbol,\n                prop: importedSymbols[importedSymbol],\n                raws: {\n                  before: \"\\n  \"\n                }\n              }));\n            });\n          });\n        }\n      };\n    }\n  };\n};\nmodule.exports.postcss = true;","map":{"version":3,"names":["topologicalSort","require","matchImports","icssImport","VISITED_MARKER","addImportToGraph","importId","parentId","graph","visited","siblingsId","visitedId","Array","isArray","siblings","concat","slice","push","module","exports","options","importIndex","createImportedName","importName","replace","failOnWrongOrder","postcssPlugin","prepare","existingImports","importDecls","imports","Once","root","postcss","walkRules","rule","matches","exec","selector","doubleQuotePath","singleQuotePath","importPath","walkDecls","declaration","value","match","tmpSymbols","symbols","global","split","map","s","parent","parentIndexes","type","index","parentRule","join","importsOrder","Error","nodes","find","hasOwnProperty","decl","error","plugin","word","lastImportRule","forEach","path","importedSymbols","raws","after","insertAfter","prepend","Object","keys","importedSymbol","append","prop","before"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/postcss-modules-extract-imports/src/index.js"],"sourcesContent":["const topologicalSort = require(\"./topologicalSort\");\n\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n\n    const siblings = visited[siblingsId];\n\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n\n    visited[visitedId] = VISITED_MARKER;\n\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName =\n    typeof options.createImportedName !== \"function\"\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`\n      : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules((rule) => {\n            const matches = icssImport.exec(rule.selector);\n\n            if (matches) {\n              const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              addImportToGraph(importPath, \"root\", graph, visited);\n\n              existingImports[importPath] = rule;\n            }\n          });\n\n          root.walkDecls(/^composes$/, (declaration) => {\n            const matches = declaration.value.match(matchImports);\n\n            if (!matches) {\n              return;\n            }\n\n            let tmpSymbols;\n            let [\n              ,\n              /*match*/ symbols,\n              doubleQuotePath,\n              singleQuotePath,\n              global,\n            ] = matches;\n\n            if (global) {\n              // Composing globals simply means changing these classes to wrap them in global(name)\n              tmpSymbols = symbols.split(/\\s+/).map((s) => `global(${s})`);\n            } else {\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              let parent = declaration.parent;\n              let parentIndexes = \"\";\n\n              while (parent.type !== \"root\") {\n                parentIndexes =\n                  parent.parent.index(parent) + \"_\" + parentIndexes;\n                parent = parent.parent;\n              }\n\n              const { selector } = declaration.parent;\n              const parentRule = `_${parentIndexes}${selector}`;\n\n              addImportToGraph(importPath, parentRule, graph, visited);\n\n              importDecls[importPath] = declaration;\n              imports[importPath] = imports[importPath] || {};\n\n              tmpSymbols = symbols.split(/\\s+/).map((s) => {\n                if (!imports[importPath][s]) {\n                  imports[importPath][s] = createImportedName(s, importPath);\n                }\n\n                return imports[importPath][s];\n              });\n            }\n\n            declaration.value = tmpSymbols.join(\" \");\n          });\n\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find((importPath) =>\n              // eslint-disable-next-line no-prototype-builtins\n              importDecls.hasOwnProperty(importPath)\n            );\n            const decl = importDecls[importPath];\n\n            throw decl.error(\n              \"Failed to resolve order of composed modules \" +\n                importsOrder.nodes\n                  .map((importPath) => \"`\" + importPath + \"`\")\n                  .join(\", \") +\n                \".\",\n              {\n                plugin: \"postcss-modules-extract-imports\",\n                word: \"composes\",\n              }\n            );\n          }\n\n          let lastImportRule;\n\n          importsOrder.forEach((path) => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: { after: \"\\n\" },\n              });\n\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n\n            lastImportRule = rule;\n\n            if (!importedSymbols) {\n              return;\n            }\n\n            Object.keys(importedSymbols).forEach((importedSymbol) => {\n              rule.append(\n                postcss.decl({\n                  value: importedSymbol,\n                  prop: importedSymbols[importedSymbol],\n                  raws: { before: \"\\n  \" },\n                })\n              );\n            });\n          });\n        },\n      };\n    },\n  };\n};\n\nmodule.exports.postcss = true;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}