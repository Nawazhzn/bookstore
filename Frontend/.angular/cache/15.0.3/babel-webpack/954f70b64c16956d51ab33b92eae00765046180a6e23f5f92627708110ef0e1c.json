{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AngularWebpackPlugin = void 0;\nconst assert_1 = require(\"assert\");\nconst ts = __importStar(require(\"typescript\"));\nconst ngcc_processor_1 = require(\"../ngcc_processor\");\nconst paths_plugin_1 = require(\"../paths-plugin\");\nconst resource_loader_1 = require(\"../resource_loader\");\nconst cache_1 = require(\"./cache\");\nconst diagnostics_1 = require(\"./diagnostics\");\nconst host_1 = require(\"./host\");\nconst paths_1 = require(\"./paths\");\nconst symbol_1 = require(\"./symbol\");\nconst system_1 = require(\"./system\");\nconst transformation_1 = require(\"./transformation\");\n/**\n * The threshold used to determine whether Angular file diagnostics should optimize for full programs\n * or single files. If the number of affected files for a build is more than the threshold, full\n * program optimization will be used.\n */\nconst DIAGNOSTICS_AFFECTED_THRESHOLD = 1;\nfunction initializeNgccProcessor(compiler, tsconfig, compilerNgccModule) {\n  var _a, _b, _c;\n  const {\n    inputFileSystem,\n    options: webpackOptions\n  } = compiler;\n  const mainFields = (_c = (_b = (_a = webpackOptions.resolve) === null || _a === void 0 ? void 0 : _a.mainFields) === null || _b === void 0 ? void 0 : _b.flat()) !== null && _c !== void 0 ? _c : [];\n  const errors = [];\n  const warnings = [];\n  const resolver = compiler.resolverFactory.get('normal', {\n    // Caching must be disabled because it causes the resolver to become async after a rebuild\n    cache: false,\n    extensions: ['.json'],\n    useSyncFileSystemCalls: true\n  });\n  // The compilerNgccModule field is guaranteed to be defined during a compilation\n  // due to the `beforeCompile` hook. Usage of this property accessor prior to the\n  // hook execution is an implementation error.\n  assert_1.strict.ok(compilerNgccModule, `'@angular/compiler-cli/ngcc' used prior to Webpack compilation.`);\n  const processor = new ngcc_processor_1.NgccProcessor(compilerNgccModule, mainFields, warnings, errors, compiler.context, tsconfig, inputFileSystem, resolver);\n  return {\n    processor,\n    errors,\n    warnings\n  };\n}\nconst PLUGIN_NAME = 'angular-compiler';\nconst compilationFileEmitters = new WeakMap();\nclass AngularWebpackPlugin {\n  constructor(options = {}) {\n    this.fileDependencies = new Map();\n    this.requiredFilesToEmit = new Set();\n    this.requiredFilesToEmitCache = new Map();\n    this.fileEmitHistory = new Map();\n    this.pluginOptions = {\n      emitClassMetadata: false,\n      emitNgModuleScope: false,\n      jitMode: false,\n      fileReplacements: {},\n      substitutions: {},\n      directTemplateLoading: true,\n      tsconfig: 'tsconfig.json',\n      ...options\n    };\n  }\n  get compilerCli() {\n    // The compilerCliModule field is guaranteed to be defined during a compilation\n    // due to the `beforeCompile` hook. Usage of this property accessor prior to the\n    // hook execution is an implementation error.\n    assert_1.strict.ok(this.compilerCliModule, `'@angular/compiler-cli' used prior to Webpack compilation.`);\n    return this.compilerCliModule;\n  }\n  get options() {\n    return this.pluginOptions;\n  }\n  apply(compiler) {\n    const {\n      NormalModuleReplacementPlugin,\n      WebpackError,\n      util\n    } = compiler.webpack;\n    this.webpackCreateHash = util.createHash;\n    // Setup file replacements with webpack\n    for (const [key, value] of Object.entries(this.pluginOptions.fileReplacements)) {\n      new NormalModuleReplacementPlugin(new RegExp('^' + key.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&') + '$'), value).apply(compiler);\n    }\n    // Set resolver options\n    const pathsPlugin = new paths_plugin_1.TypeScriptPathsPlugin();\n    compiler.hooks.afterResolvers.tap(PLUGIN_NAME, compiler => {\n      // When Ivy is enabled we need to add the fields added by NGCC\n      // to take precedence over the provided mainFields.\n      // NGCC adds fields in package.json suffixed with '_ivy_ngcc'\n      // Example: module -> module__ivy_ngcc\n      compiler.resolverFactory.hooks.resolveOptions.for('normal').tap(PLUGIN_NAME, resolveOptions => {\n        var _a, _b;\n        const originalMainFields = resolveOptions.mainFields;\n        const ivyMainFields = (_a = originalMainFields === null || originalMainFields === void 0 ? void 0 : originalMainFields.flat().map(f => `${f}_ivy_ngcc`)) !== null && _a !== void 0 ? _a : [];\n        (_b = resolveOptions.plugins) !== null && _b !== void 0 ? _b : resolveOptions.plugins = [];\n        resolveOptions.plugins.push(pathsPlugin);\n        // https://github.com/webpack/webpack/issues/11635#issuecomment-707016779\n        return util.cleverMerge(resolveOptions, {\n          mainFields: [...ivyMainFields, '...']\n        });\n      });\n    });\n    // Load the compiler-cli if not already available\n    compiler.hooks.beforeCompile.tapPromise(PLUGIN_NAME, () => this.initializeCompilerCli());\n    const compilationState = {\n      pathsPlugin\n    };\n    compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => {\n      try {\n        this.setupCompilation(compilation, compilationState);\n      } catch (error) {\n        (0, diagnostics_1.addError)(compilation, `Failed to initialize Angular compilation - ${error instanceof Error ? error.message : error}`);\n      }\n    });\n  }\n  setupCompilation(compilation, state) {\n    var _this = this;\n    const compiler = compilation.compiler;\n    // Register plugin to ensure deterministic emit order in multi-plugin usage\n    const emitRegistration = this.registerWithCompilation(compilation);\n    this.watchMode = compiler.watchMode;\n    // Initialize webpack cache\n    if (!this.webpackCache && compilation.options.cache) {\n      this.webpackCache = compilation.getCache(PLUGIN_NAME);\n    }\n    // Initialize the resource loader if not already setup\n    if (!state.resourceLoader) {\n      state.resourceLoader = new resource_loader_1.WebpackResourceLoader(this.watchMode);\n    }\n    // Initialize and process eager ngcc if not already setup\n    if (!state.ngccProcessor) {\n      const {\n        processor,\n        errors,\n        warnings\n      } = initializeNgccProcessor(compiler, this.pluginOptions.tsconfig, this.compilerNgccModule);\n      processor.process();\n      warnings.forEach(warning => (0, diagnostics_1.addWarning)(compilation, warning));\n      errors.forEach(error => (0, diagnostics_1.addError)(compilation, error));\n      state.ngccProcessor = processor;\n    }\n    // Setup and read TypeScript and Angular compiler configuration\n    const {\n      compilerOptions,\n      rootNames,\n      errors\n    } = this.loadConfiguration();\n    // Create diagnostics reporter and report configuration file errors\n    const diagnosticsReporter = (0, diagnostics_1.createDiagnosticsReporter)(compilation, diagnostic => this.compilerCli.formatDiagnostics([diagnostic]));\n    diagnosticsReporter(errors);\n    // Update TypeScript path mapping plugin with new configuration\n    state.pathsPlugin.update(compilerOptions);\n    // Create a Webpack-based TypeScript compiler host\n    const system = (0, system_1.createWebpackSystem)(\n    // Webpack lacks an InputFileSytem type definition with sync functions\n    compiler.inputFileSystem, (0, paths_1.normalizePath)(compiler.context));\n    const host = ts.createIncrementalCompilerHost(compilerOptions, system);\n    // Setup source file caching and reuse cache from previous compilation if present\n    let cache = this.sourceFileCache;\n    let changedFiles;\n    if (cache) {\n      changedFiles = new Set();\n      for (const changedFile of [...compiler.modifiedFiles, ...compiler.removedFiles]) {\n        const normalizedChangedFile = (0, paths_1.normalizePath)(changedFile);\n        // Invalidate file dependencies\n        this.fileDependencies.delete(normalizedChangedFile);\n        // Invalidate existing cache\n        cache.invalidate(normalizedChangedFile);\n        changedFiles.add(normalizedChangedFile);\n      }\n    } else {\n      // Initialize a new cache\n      cache = new cache_1.SourceFileCache();\n      // Only store cache if in watch mode\n      if (this.watchMode) {\n        this.sourceFileCache = cache;\n      }\n    }\n    (0, host_1.augmentHostWithCaching)(host, cache);\n    const moduleResolutionCache = ts.createModuleResolutionCache(host.getCurrentDirectory(), host.getCanonicalFileName.bind(host), compilerOptions);\n    // Setup source file dependency collection\n    (0, host_1.augmentHostWithDependencyCollection)(host, this.fileDependencies, moduleResolutionCache);\n    // Setup on demand ngcc\n    (0, host_1.augmentHostWithNgcc)(host, state.ngccProcessor, moduleResolutionCache);\n    // Setup resource loading\n    state.resourceLoader.update(compilation, changedFiles);\n    (0, host_1.augmentHostWithResources)(host, state.resourceLoader, {\n      directTemplateLoading: this.pluginOptions.directTemplateLoading,\n      inlineStyleFileExtension: this.pluginOptions.inlineStyleFileExtension\n    });\n    // Setup source file adjustment options\n    (0, host_1.augmentHostWithReplacements)(host, this.pluginOptions.fileReplacements, moduleResolutionCache);\n    (0, host_1.augmentHostWithSubstitutions)(host, this.pluginOptions.substitutions);\n    // Create the file emitter used by the webpack loader\n    const {\n      fileEmitter,\n      builder,\n      internalFiles\n    } = this.pluginOptions.jitMode ? this.updateJitProgram(compilerOptions, rootNames, host, diagnosticsReporter) : this.updateAotProgram(compilerOptions, rootNames, host, diagnosticsReporter, state.resourceLoader);\n    // Set of files used during the unused TypeScript file analysis\n    const currentUnused = new Set();\n    for (const sourceFile of builder.getSourceFiles()) {\n      if (internalFiles === null || internalFiles === void 0 ? void 0 : internalFiles.has(sourceFile)) {\n        continue;\n      }\n      // Ensure all program files are considered part of the compilation and will be watched.\n      // Webpack does not normalize paths. Therefore, we need to normalize the path with FS seperators.\n      compilation.fileDependencies.add((0, paths_1.externalizePath)(sourceFile.fileName));\n      // Add all non-declaration files to the initial set of unused files. The set will be\n      // analyzed and pruned after all Webpack modules are finished building.\n      if (!sourceFile.isDeclarationFile) {\n        currentUnused.add((0, paths_1.normalizePath)(sourceFile.fileName));\n      }\n    }\n    compilation.hooks.finishModules.tapPromise(PLUGIN_NAME, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (modules) {\n        var _a, _b;\n        // Rebuild any remaining AOT required modules\n        yield _this.rebuildRequiredFiles(modules, compilation, fileEmitter);\n        // Clear out the Webpack compilation to avoid an extra retaining reference\n        (_a = state.resourceLoader) === null || _a === void 0 ? void 0 : _a.clearParentCompilation();\n        // Analyze program for unused files\n        if (compilation.errors.length > 0) {\n          return;\n        }\n        for (const webpackModule of modules) {\n          const resource = webpackModule.resource;\n          if (resource) {\n            _this.markResourceUsed((0, paths_1.normalizePath)(resource), currentUnused);\n          }\n        }\n        for (const unused of currentUnused) {\n          if ((_b = state.previousUnused) === null || _b === void 0 ? void 0 : _b.has(unused)) {\n            continue;\n          }\n          (0, diagnostics_1.addWarning)(compilation, `${unused} is part of the TypeScript compilation but it's unused.\\n` + `Add only entry points to the 'files' or 'include' properties in your tsconfig.`);\n        }\n        state.previousUnused = currentUnused;\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    // Store file emitter for loader usage\n    emitRegistration.update(fileEmitter);\n  }\n  registerWithCompilation(compilation) {\n    let fileEmitters = compilationFileEmitters.get(compilation);\n    if (!fileEmitters) {\n      fileEmitters = new symbol_1.FileEmitterCollection();\n      compilationFileEmitters.set(compilation, fileEmitters);\n      compilation.compiler.webpack.NormalModule.getCompilationHooks(compilation).loader.tap(PLUGIN_NAME, loaderContext => {\n        loaderContext[symbol_1.AngularPluginSymbol] = fileEmitters;\n      });\n    }\n    const emitRegistration = fileEmitters.register();\n    return emitRegistration;\n  }\n  markResourceUsed(normalizedResourcePath, currentUnused) {\n    if (!currentUnused.has(normalizedResourcePath)) {\n      return;\n    }\n    currentUnused.delete(normalizedResourcePath);\n    const dependencies = this.fileDependencies.get(normalizedResourcePath);\n    if (!dependencies) {\n      return;\n    }\n    for (const dependency of dependencies) {\n      this.markResourceUsed((0, paths_1.normalizePath)(dependency), currentUnused);\n    }\n  }\n  rebuildRequiredFiles(modules, compilation, fileEmitter) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.requiredFilesToEmit.size === 0) {\n        return;\n      }\n      const filesToRebuild = new Set();\n      for (const requiredFile of _this2.requiredFilesToEmit) {\n        const history = yield _this2.getFileEmitHistory(requiredFile);\n        if (history) {\n          const emitResult = yield fileEmitter(requiredFile);\n          if ((emitResult === null || emitResult === void 0 ? void 0 : emitResult.content) === undefined || history.length !== emitResult.content.length || emitResult.hash === undefined || Buffer.compare(history.hash, emitResult.hash) !== 0) {\n            // New emit result is different so rebuild using new emit result\n            _this2.requiredFilesToEmitCache.set(requiredFile, emitResult);\n            filesToRebuild.add(requiredFile);\n          }\n        } else {\n          // No emit history so rebuild\n          filesToRebuild.add(requiredFile);\n        }\n      }\n      if (filesToRebuild.size > 0) {\n        const rebuild = webpackModule => new Promise(resolve => compilation.rebuildModule(webpackModule, () => resolve()));\n        const modulesToRebuild = [];\n        for (const webpackModule of modules) {\n          const resource = webpackModule.resource;\n          if (resource && filesToRebuild.has((0, paths_1.normalizePath)(resource))) {\n            modulesToRebuild.push(webpackModule);\n          }\n        }\n        yield Promise.all(modulesToRebuild.map(webpackModule => rebuild(webpackModule)));\n      }\n      _this2.requiredFilesToEmit.clear();\n      _this2.requiredFilesToEmitCache.clear();\n    })();\n  }\n  loadConfiguration() {\n    const {\n      options: compilerOptions,\n      rootNames,\n      errors\n    } = this.compilerCli.readConfiguration(this.pluginOptions.tsconfig, this.pluginOptions.compilerOptions);\n    compilerOptions.noEmitOnError = false;\n    compilerOptions.suppressOutputPathCheck = true;\n    compilerOptions.outDir = undefined;\n    compilerOptions.inlineSources = compilerOptions.sourceMap;\n    compilerOptions.inlineSourceMap = false;\n    compilerOptions.mapRoot = undefined;\n    compilerOptions.sourceRoot = undefined;\n    compilerOptions.allowEmptyCodegenFiles = false;\n    compilerOptions.annotationsAs = 'decorators';\n    compilerOptions.enableResourceInlining = false;\n    return {\n      compilerOptions,\n      rootNames,\n      errors\n    };\n  }\n  updateAotProgram(compilerOptions, rootNames, host, diagnosticsReporter, resourceLoader) {\n    // Create the Angular specific program that contains the Angular compiler\n    const angularProgram = new this.compilerCli.NgtscProgram(rootNames, compilerOptions, host, this.ngtscNextProgram);\n    const angularCompiler = angularProgram.compiler;\n    // The `ignoreForEmit` return value can be safely ignored when emitting. Only files\n    // that will be bundled (requested by Webpack) will be emitted. Combined with TypeScript's\n    // eliding of type only imports, this will cause type only files to be automatically ignored.\n    // Internal Angular type check files are also not resolvable by the bundler. Even if they\n    // were somehow errantly imported, the bundler would error before an emit was attempted.\n    // Diagnostics are still collected for all files which requires using `ignoreForDiagnostics`.\n    const {\n      ignoreForDiagnostics,\n      ignoreForEmit\n    } = angularCompiler;\n    // SourceFile versions are required for builder programs.\n    // The wrapped host inside NgtscProgram adds additional files that will not have versions.\n    const typeScriptProgram = angularProgram.getTsProgram();\n    (0, host_1.augmentProgramWithVersioning)(typeScriptProgram);\n    let builder;\n    if (this.watchMode) {\n      builder = this.builder = ts.createEmitAndSemanticDiagnosticsBuilderProgram(typeScriptProgram, host, this.builder);\n      this.ngtscNextProgram = angularProgram;\n    } else {\n      // When not in watch mode, the startup cost of the incremental analysis can be avoided by\n      // using an abstract builder that only wraps a TypeScript program.\n      builder = ts.createAbstractBuilder(typeScriptProgram, host);\n    }\n    // Update semantic diagnostics cache\n    const affectedFiles = new Set();\n    // Analyze affected files when in watch mode for incremental type checking\n    if ('getSemanticDiagnosticsOfNextAffectedFile' in builder) {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const result = builder.getSemanticDiagnosticsOfNextAffectedFile(undefined, sourceFile => {\n          // If the affected file is a TTC shim, add the shim's original source file.\n          // This ensures that changes that affect TTC are typechecked even when the changes\n          // are otherwise unrelated from a TS perspective and do not result in Ivy codegen changes.\n          // For example, changing @Input property types of a directive used in another component's\n          // template.\n          if (ignoreForDiagnostics.has(sourceFile) && sourceFile.fileName.endsWith('.ngtypecheck.ts')) {\n            // This file name conversion relies on internal compiler logic and should be converted\n            // to an official method when available. 15 is length of `.ngtypecheck.ts`\n            const originalFilename = sourceFile.fileName.slice(0, -15) + '.ts';\n            const originalSourceFile = builder.getSourceFile(originalFilename);\n            if (originalSourceFile) {\n              affectedFiles.add(originalSourceFile);\n            }\n            return true;\n          }\n          return false;\n        });\n        if (!result) {\n          break;\n        }\n        affectedFiles.add(result.affected);\n      }\n    }\n    // Collect program level diagnostics\n    const diagnostics = [...angularCompiler.getOptionDiagnostics(), ...builder.getOptionsDiagnostics(), ...builder.getGlobalDiagnostics()];\n    diagnosticsReporter(diagnostics);\n    // Collect source file specific diagnostics\n    for (const sourceFile of builder.getSourceFiles()) {\n      if (!ignoreForDiagnostics.has(sourceFile)) {\n        diagnosticsReporter(builder.getSyntacticDiagnostics(sourceFile));\n        diagnosticsReporter(builder.getSemanticDiagnostics(sourceFile));\n      }\n    }\n    const transformers = (0, transformation_1.createAotTransformers)(builder, this.pluginOptions);\n    const getDependencies = sourceFile => {\n      const dependencies = [];\n      for (const resourcePath of angularCompiler.getResourceDependencies(sourceFile)) {\n        dependencies.push(resourcePath,\n        // Retrieve all dependencies of the resource (stylesheet imports, etc.)\n        ...resourceLoader.getResourceDependencies(resourcePath));\n      }\n      return dependencies;\n    };\n    // Required to support asynchronous resource loading\n    // Must be done before creating transformers or getting template diagnostics\n    const pendingAnalysis = angularCompiler.analyzeAsync().then(() => {\n      var _a;\n      this.requiredFilesToEmit.clear();\n      for (const sourceFile of builder.getSourceFiles()) {\n        if (sourceFile.isDeclarationFile) {\n          continue;\n        }\n        // Collect sources that are required to be emitted\n        if (!ignoreForEmit.has(sourceFile) && !angularCompiler.incrementalCompilation.safeToSkipEmit(sourceFile)) {\n          this.requiredFilesToEmit.add((0, paths_1.normalizePath)(sourceFile.fileName));\n          // If required to emit, diagnostics may have also changed\n          if (!ignoreForDiagnostics.has(sourceFile)) {\n            affectedFiles.add(sourceFile);\n          }\n        } else if (this.sourceFileCache && !affectedFiles.has(sourceFile) && !ignoreForDiagnostics.has(sourceFile)) {\n          // Use cached Angular diagnostics for unchanged and unaffected files\n          const angularDiagnostics = this.sourceFileCache.getAngularDiagnostics(sourceFile);\n          if (angularDiagnostics) {\n            diagnosticsReporter(angularDiagnostics);\n          }\n        }\n      }\n      // Collect new Angular diagnostics for files affected by changes\n      const OptimizeFor = this.compilerCli.OptimizeFor;\n      const optimizeDiagnosticsFor = affectedFiles.size <= DIAGNOSTICS_AFFECTED_THRESHOLD ? OptimizeFor.SingleFile : OptimizeFor.WholeProgram;\n      for (const affectedFile of affectedFiles) {\n        const angularDiagnostics = angularCompiler.getDiagnosticsForFile(affectedFile, optimizeDiagnosticsFor);\n        diagnosticsReporter(angularDiagnostics);\n        (_a = this.sourceFileCache) === null || _a === void 0 ? void 0 : _a.updateAngularDiagnostics(affectedFile, angularDiagnostics);\n      }\n      return {\n        emitter: this.createFileEmitter(builder, (0, transformation_1.mergeTransformers)(angularCompiler.prepareEmit().transformers, transformers), getDependencies, sourceFile => {\n          this.requiredFilesToEmit.delete((0, paths_1.normalizePath)(sourceFile.fileName));\n          angularCompiler.incrementalCompilation.recordSuccessfulEmit(sourceFile);\n        })\n      };\n    }).catch(err => ({\n      errorMessage: err instanceof Error ? err.message : `${err}`\n    }));\n    const analyzingFileEmitter = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (file) {\n        const analysis = yield pendingAnalysis;\n        if ('errorMessage' in analysis) {\n          throw new Error(analysis.errorMessage);\n        }\n        return analysis.emitter(file);\n      });\n      return function analyzingFileEmitter(_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    return {\n      fileEmitter: analyzingFileEmitter,\n      builder,\n      internalFiles: ignoreForEmit\n    };\n  }\n  updateJitProgram(compilerOptions, rootNames, host, diagnosticsReporter) {\n    let builder;\n    if (this.watchMode) {\n      builder = this.builder = ts.createEmitAndSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, this.builder);\n    } else {\n      // When not in watch mode, the startup cost of the incremental analysis can be avoided by\n      // using an abstract builder that only wraps a TypeScript program.\n      builder = ts.createAbstractBuilder(rootNames, compilerOptions, host);\n    }\n    const diagnostics = [...builder.getOptionsDiagnostics(), ...builder.getGlobalDiagnostics(), ...builder.getSyntacticDiagnostics(),\n    // Gather incremental semantic diagnostics\n    ...builder.getSemanticDiagnostics()];\n    diagnosticsReporter(diagnostics);\n    const transformers = (0, transformation_1.createJitTransformers)(builder, this.compilerCli, this.pluginOptions);\n    return {\n      fileEmitter: this.createFileEmitter(builder, transformers, () => []),\n      builder,\n      internalFiles: undefined\n    };\n  }\n  createFileEmitter(program, transformers = {}, getExtraDependencies, onAfterEmit) {\n    var _this3 = this;\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (file) {\n        const filePath = (0, paths_1.normalizePath)(file);\n        if (_this3.requiredFilesToEmitCache.has(filePath)) {\n          return _this3.requiredFilesToEmitCache.get(filePath);\n        }\n        const sourceFile = program.getSourceFile(filePath);\n        if (!sourceFile) {\n          return undefined;\n        }\n        let content;\n        let map;\n        program.emit(sourceFile, (filename, data) => {\n          if (filename.endsWith('.map')) {\n            map = data;\n          } else if (filename.endsWith('.js')) {\n            content = data;\n          }\n        }, undefined, undefined, transformers);\n        onAfterEmit === null || onAfterEmit === void 0 ? void 0 : onAfterEmit(sourceFile);\n        // Capture emit history info for Angular rebuild analysis\n        const hash = content ? (yield _this3.addFileEmitHistory(filePath, content)).hash : undefined;\n        const dependencies = [...(_this3.fileDependencies.get(filePath) || []), ...getExtraDependencies(sourceFile)].map(paths_1.externalizePath);\n        return {\n          content,\n          map,\n          dependencies,\n          hash\n        };\n      });\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }\n  initializeCompilerCli() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (_this4.compilerCliModule) {\n        return;\n      }\n      // This uses a dynamic import to load `@angular/compiler-cli` which may be ESM.\n      // CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript\n      // will currently, unconditionally downlevel dynamic import into a require call.\n      // require calls cannot load ESM code and will result in a runtime error. To workaround\n      // this, a Function constructor is used to prevent TypeScript from changing the dynamic import.\n      // Once TypeScript provides support for keeping the dynamic import this workaround can\n      // be dropped.\n      _this4.compilerCliModule = yield new Function(`return import('@angular/compiler-cli');`)();\n      _this4.compilerNgccModule = yield new Function(`return import('@angular/compiler-cli/ngcc');`)();\n    })();\n  }\n  addFileEmitHistory(filePath, content) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      assert_1.strict.ok(_this5.webpackCreateHash, 'File emitter is used prior to Webpack compilation');\n      const historyData = {\n        length: content.length,\n        hash: _this5.webpackCreateHash('xxhash64').update(content).digest()\n      };\n      if (_this5.webpackCache) {\n        const history = yield _this5.getFileEmitHistory(filePath);\n        if (!history || Buffer.compare(history.hash, historyData.hash) !== 0) {\n          // Hash doesn't match or item doesn't exist.\n          yield _this5.webpackCache.storePromise(filePath, null, historyData);\n        }\n      } else if (_this5.watchMode) {\n        // The in memory file emit history is only required during watch mode.\n        _this5.fileEmitHistory.set(filePath, historyData);\n      }\n      return historyData;\n    })();\n  }\n  getFileEmitHistory(filePath) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return _this6.webpackCache ? _this6.webpackCache.getPromise(filePath, null) : _this6.fileEmitHistory.get(filePath);\n    })();\n  }\n}\nexports.AngularWebpackPlugin = AngularWebpackPlugin;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","AngularWebpackPlugin","assert_1","require","ts","ngcc_processor_1","paths_plugin_1","resource_loader_1","cache_1","diagnostics_1","host_1","paths_1","symbol_1","system_1","transformation_1","DIAGNOSTICS_AFFECTED_THRESHOLD","initializeNgccProcessor","compiler","tsconfig","compilerNgccModule","_a","_b","_c","inputFileSystem","options","webpackOptions","mainFields","resolve","flat","errors","warnings","resolver","resolverFactory","cache","extensions","useSyncFileSystemCalls","strict","ok","processor","NgccProcessor","context","PLUGIN_NAME","compilationFileEmitters","WeakMap","constructor","fileDependencies","Map","requiredFilesToEmit","Set","requiredFilesToEmitCache","fileEmitHistory","pluginOptions","emitClassMetadata","emitNgModuleScope","jitMode","fileReplacements","substitutions","directTemplateLoading","compilerCli","compilerCliModule","apply","NormalModuleReplacementPlugin","WebpackError","util","webpack","webpackCreateHash","createHash","key","entries","RegExp","replace","pathsPlugin","TypeScriptPathsPlugin","hooks","afterResolvers","tap","resolveOptions","for","originalMainFields","ivyMainFields","map","f","plugins","push","cleverMerge","beforeCompile","tapPromise","initializeCompilerCli","compilationState","thisCompilation","compilation","setupCompilation","error","addError","Error","message","state","emitRegistration","registerWithCompilation","watchMode","webpackCache","getCache","resourceLoader","WebpackResourceLoader","ngccProcessor","process","forEach","warning","addWarning","compilerOptions","rootNames","loadConfiguration","diagnosticsReporter","createDiagnosticsReporter","diagnostic","formatDiagnostics","update","system","createWebpackSystem","normalizePath","host","createIncrementalCompilerHost","sourceFileCache","changedFiles","changedFile","modifiedFiles","removedFiles","normalizedChangedFile","delete","invalidate","add","SourceFileCache","augmentHostWithCaching","moduleResolutionCache","createModuleResolutionCache","getCurrentDirectory","getCanonicalFileName","bind","augmentHostWithDependencyCollection","augmentHostWithNgcc","augmentHostWithResources","inlineStyleFileExtension","augmentHostWithReplacements","augmentHostWithSubstitutions","fileEmitter","builder","internalFiles","updateJitProgram","updateAotProgram","currentUnused","sourceFile","getSourceFiles","has","externalizePath","fileName","isDeclarationFile","finishModules","modules","rebuildRequiredFiles","clearParentCompilation","length","webpackModule","resource","markResourceUsed","unused","previousUnused","fileEmitters","FileEmitterCollection","set","NormalModule","getCompilationHooks","loader","loaderContext","AngularPluginSymbol","register","normalizedResourcePath","dependencies","dependency","size","filesToRebuild","requiredFile","history","getFileEmitHistory","emitResult","content","hash","Buffer","compare","rebuild","Promise","rebuildModule","modulesToRebuild","all","clear","readConfiguration","noEmitOnError","suppressOutputPathCheck","outDir","inlineSources","sourceMap","inlineSourceMap","mapRoot","sourceRoot","allowEmptyCodegenFiles","annotationsAs","enableResourceInlining","angularProgram","NgtscProgram","ngtscNextProgram","angularCompiler","ignoreForDiagnostics","ignoreForEmit","typeScriptProgram","getTsProgram","augmentProgramWithVersioning","createEmitAndSemanticDiagnosticsBuilderProgram","createAbstractBuilder","affectedFiles","getSemanticDiagnosticsOfNextAffectedFile","endsWith","originalFilename","slice","originalSourceFile","getSourceFile","affected","diagnostics","getOptionDiagnostics","getOptionsDiagnostics","getGlobalDiagnostics","getSyntacticDiagnostics","getSemanticDiagnostics","transformers","createAotTransformers","getDependencies","resourcePath","getResourceDependencies","pendingAnalysis","analyzeAsync","then","incrementalCompilation","safeToSkipEmit","angularDiagnostics","getAngularDiagnostics","OptimizeFor","optimizeDiagnosticsFor","SingleFile","WholeProgram","affectedFile","getDiagnosticsForFile","updateAngularDiagnostics","emitter","createFileEmitter","mergeTransformers","prepareEmit","recordSuccessfulEmit","catch","err","errorMessage","analyzingFileEmitter","file","analysis","createJitTransformers","program","getExtraDependencies","onAfterEmit","filePath","emit","filename","data","addFileEmitHistory","Function","historyData","digest","storePromise","getPromise"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@ngtools/webpack/src/ivy/plugin.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AngularWebpackPlugin = void 0;\nconst assert_1 = require(\"assert\");\nconst ts = __importStar(require(\"typescript\"));\nconst ngcc_processor_1 = require(\"../ngcc_processor\");\nconst paths_plugin_1 = require(\"../paths-plugin\");\nconst resource_loader_1 = require(\"../resource_loader\");\nconst cache_1 = require(\"./cache\");\nconst diagnostics_1 = require(\"./diagnostics\");\nconst host_1 = require(\"./host\");\nconst paths_1 = require(\"./paths\");\nconst symbol_1 = require(\"./symbol\");\nconst system_1 = require(\"./system\");\nconst transformation_1 = require(\"./transformation\");\n/**\n * The threshold used to determine whether Angular file diagnostics should optimize for full programs\n * or single files. If the number of affected files for a build is more than the threshold, full\n * program optimization will be used.\n */\nconst DIAGNOSTICS_AFFECTED_THRESHOLD = 1;\nfunction initializeNgccProcessor(compiler, tsconfig, compilerNgccModule) {\n    var _a, _b, _c;\n    const { inputFileSystem, options: webpackOptions } = compiler;\n    const mainFields = (_c = (_b = (_a = webpackOptions.resolve) === null || _a === void 0 ? void 0 : _a.mainFields) === null || _b === void 0 ? void 0 : _b.flat()) !== null && _c !== void 0 ? _c : [];\n    const errors = [];\n    const warnings = [];\n    const resolver = compiler.resolverFactory.get('normal', {\n        // Caching must be disabled because it causes the resolver to become async after a rebuild\n        cache: false,\n        extensions: ['.json'],\n        useSyncFileSystemCalls: true,\n    });\n    // The compilerNgccModule field is guaranteed to be defined during a compilation\n    // due to the `beforeCompile` hook. Usage of this property accessor prior to the\n    // hook execution is an implementation error.\n    assert_1.strict.ok(compilerNgccModule, `'@angular/compiler-cli/ngcc' used prior to Webpack compilation.`);\n    const processor = new ngcc_processor_1.NgccProcessor(compilerNgccModule, mainFields, warnings, errors, compiler.context, tsconfig, inputFileSystem, resolver);\n    return { processor, errors, warnings };\n}\nconst PLUGIN_NAME = 'angular-compiler';\nconst compilationFileEmitters = new WeakMap();\nclass AngularWebpackPlugin {\n    constructor(options = {}) {\n        this.fileDependencies = new Map();\n        this.requiredFilesToEmit = new Set();\n        this.requiredFilesToEmitCache = new Map();\n        this.fileEmitHistory = new Map();\n        this.pluginOptions = {\n            emitClassMetadata: false,\n            emitNgModuleScope: false,\n            jitMode: false,\n            fileReplacements: {},\n            substitutions: {},\n            directTemplateLoading: true,\n            tsconfig: 'tsconfig.json',\n            ...options,\n        };\n    }\n    get compilerCli() {\n        // The compilerCliModule field is guaranteed to be defined during a compilation\n        // due to the `beforeCompile` hook. Usage of this property accessor prior to the\n        // hook execution is an implementation error.\n        assert_1.strict.ok(this.compilerCliModule, `'@angular/compiler-cli' used prior to Webpack compilation.`);\n        return this.compilerCliModule;\n    }\n    get options() {\n        return this.pluginOptions;\n    }\n    apply(compiler) {\n        const { NormalModuleReplacementPlugin, WebpackError, util } = compiler.webpack;\n        this.webpackCreateHash = util.createHash;\n        // Setup file replacements with webpack\n        for (const [key, value] of Object.entries(this.pluginOptions.fileReplacements)) {\n            new NormalModuleReplacementPlugin(new RegExp('^' + key.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&') + '$'), value).apply(compiler);\n        }\n        // Set resolver options\n        const pathsPlugin = new paths_plugin_1.TypeScriptPathsPlugin();\n        compiler.hooks.afterResolvers.tap(PLUGIN_NAME, (compiler) => {\n            // When Ivy is enabled we need to add the fields added by NGCC\n            // to take precedence over the provided mainFields.\n            // NGCC adds fields in package.json suffixed with '_ivy_ngcc'\n            // Example: module -> module__ivy_ngcc\n            compiler.resolverFactory.hooks.resolveOptions\n                .for('normal')\n                .tap(PLUGIN_NAME, (resolveOptions) => {\n                var _a, _b;\n                const originalMainFields = resolveOptions.mainFields;\n                const ivyMainFields = (_a = originalMainFields === null || originalMainFields === void 0 ? void 0 : originalMainFields.flat().map((f) => `${f}_ivy_ngcc`)) !== null && _a !== void 0 ? _a : [];\n                (_b = resolveOptions.plugins) !== null && _b !== void 0 ? _b : (resolveOptions.plugins = []);\n                resolveOptions.plugins.push(pathsPlugin);\n                // https://github.com/webpack/webpack/issues/11635#issuecomment-707016779\n                return util.cleverMerge(resolveOptions, { mainFields: [...ivyMainFields, '...'] });\n            });\n        });\n        // Load the compiler-cli if not already available\n        compiler.hooks.beforeCompile.tapPromise(PLUGIN_NAME, () => this.initializeCompilerCli());\n        const compilationState = { pathsPlugin };\n        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {\n            try {\n                this.setupCompilation(compilation, compilationState);\n            }\n            catch (error) {\n                (0, diagnostics_1.addError)(compilation, `Failed to initialize Angular compilation - ${error instanceof Error ? error.message : error}`);\n            }\n        });\n    }\n    setupCompilation(compilation, state) {\n        const compiler = compilation.compiler;\n        // Register plugin to ensure deterministic emit order in multi-plugin usage\n        const emitRegistration = this.registerWithCompilation(compilation);\n        this.watchMode = compiler.watchMode;\n        // Initialize webpack cache\n        if (!this.webpackCache && compilation.options.cache) {\n            this.webpackCache = compilation.getCache(PLUGIN_NAME);\n        }\n        // Initialize the resource loader if not already setup\n        if (!state.resourceLoader) {\n            state.resourceLoader = new resource_loader_1.WebpackResourceLoader(this.watchMode);\n        }\n        // Initialize and process eager ngcc if not already setup\n        if (!state.ngccProcessor) {\n            const { processor, errors, warnings } = initializeNgccProcessor(compiler, this.pluginOptions.tsconfig, this.compilerNgccModule);\n            processor.process();\n            warnings.forEach((warning) => (0, diagnostics_1.addWarning)(compilation, warning));\n            errors.forEach((error) => (0, diagnostics_1.addError)(compilation, error));\n            state.ngccProcessor = processor;\n        }\n        // Setup and read TypeScript and Angular compiler configuration\n        const { compilerOptions, rootNames, errors } = this.loadConfiguration();\n        // Create diagnostics reporter and report configuration file errors\n        const diagnosticsReporter = (0, diagnostics_1.createDiagnosticsReporter)(compilation, (diagnostic) => this.compilerCli.formatDiagnostics([diagnostic]));\n        diagnosticsReporter(errors);\n        // Update TypeScript path mapping plugin with new configuration\n        state.pathsPlugin.update(compilerOptions);\n        // Create a Webpack-based TypeScript compiler host\n        const system = (0, system_1.createWebpackSystem)(\n        // Webpack lacks an InputFileSytem type definition with sync functions\n        compiler.inputFileSystem, (0, paths_1.normalizePath)(compiler.context));\n        const host = ts.createIncrementalCompilerHost(compilerOptions, system);\n        // Setup source file caching and reuse cache from previous compilation if present\n        let cache = this.sourceFileCache;\n        let changedFiles;\n        if (cache) {\n            changedFiles = new Set();\n            for (const changedFile of [...compiler.modifiedFiles, ...compiler.removedFiles]) {\n                const normalizedChangedFile = (0, paths_1.normalizePath)(changedFile);\n                // Invalidate file dependencies\n                this.fileDependencies.delete(normalizedChangedFile);\n                // Invalidate existing cache\n                cache.invalidate(normalizedChangedFile);\n                changedFiles.add(normalizedChangedFile);\n            }\n        }\n        else {\n            // Initialize a new cache\n            cache = new cache_1.SourceFileCache();\n            // Only store cache if in watch mode\n            if (this.watchMode) {\n                this.sourceFileCache = cache;\n            }\n        }\n        (0, host_1.augmentHostWithCaching)(host, cache);\n        const moduleResolutionCache = ts.createModuleResolutionCache(host.getCurrentDirectory(), host.getCanonicalFileName.bind(host), compilerOptions);\n        // Setup source file dependency collection\n        (0, host_1.augmentHostWithDependencyCollection)(host, this.fileDependencies, moduleResolutionCache);\n        // Setup on demand ngcc\n        (0, host_1.augmentHostWithNgcc)(host, state.ngccProcessor, moduleResolutionCache);\n        // Setup resource loading\n        state.resourceLoader.update(compilation, changedFiles);\n        (0, host_1.augmentHostWithResources)(host, state.resourceLoader, {\n            directTemplateLoading: this.pluginOptions.directTemplateLoading,\n            inlineStyleFileExtension: this.pluginOptions.inlineStyleFileExtension,\n        });\n        // Setup source file adjustment options\n        (0, host_1.augmentHostWithReplacements)(host, this.pluginOptions.fileReplacements, moduleResolutionCache);\n        (0, host_1.augmentHostWithSubstitutions)(host, this.pluginOptions.substitutions);\n        // Create the file emitter used by the webpack loader\n        const { fileEmitter, builder, internalFiles } = this.pluginOptions.jitMode\n            ? this.updateJitProgram(compilerOptions, rootNames, host, diagnosticsReporter)\n            : this.updateAotProgram(compilerOptions, rootNames, host, diagnosticsReporter, state.resourceLoader);\n        // Set of files used during the unused TypeScript file analysis\n        const currentUnused = new Set();\n        for (const sourceFile of builder.getSourceFiles()) {\n            if (internalFiles === null || internalFiles === void 0 ? void 0 : internalFiles.has(sourceFile)) {\n                continue;\n            }\n            // Ensure all program files are considered part of the compilation and will be watched.\n            // Webpack does not normalize paths. Therefore, we need to normalize the path with FS seperators.\n            compilation.fileDependencies.add((0, paths_1.externalizePath)(sourceFile.fileName));\n            // Add all non-declaration files to the initial set of unused files. The set will be\n            // analyzed and pruned after all Webpack modules are finished building.\n            if (!sourceFile.isDeclarationFile) {\n                currentUnused.add((0, paths_1.normalizePath)(sourceFile.fileName));\n            }\n        }\n        compilation.hooks.finishModules.tapPromise(PLUGIN_NAME, async (modules) => {\n            var _a, _b;\n            // Rebuild any remaining AOT required modules\n            await this.rebuildRequiredFiles(modules, compilation, fileEmitter);\n            // Clear out the Webpack compilation to avoid an extra retaining reference\n            (_a = state.resourceLoader) === null || _a === void 0 ? void 0 : _a.clearParentCompilation();\n            // Analyze program for unused files\n            if (compilation.errors.length > 0) {\n                return;\n            }\n            for (const webpackModule of modules) {\n                const resource = webpackModule.resource;\n                if (resource) {\n                    this.markResourceUsed((0, paths_1.normalizePath)(resource), currentUnused);\n                }\n            }\n            for (const unused of currentUnused) {\n                if ((_b = state.previousUnused) === null || _b === void 0 ? void 0 : _b.has(unused)) {\n                    continue;\n                }\n                (0, diagnostics_1.addWarning)(compilation, `${unused} is part of the TypeScript compilation but it's unused.\\n` +\n                    `Add only entry points to the 'files' or 'include' properties in your tsconfig.`);\n            }\n            state.previousUnused = currentUnused;\n        });\n        // Store file emitter for loader usage\n        emitRegistration.update(fileEmitter);\n    }\n    registerWithCompilation(compilation) {\n        let fileEmitters = compilationFileEmitters.get(compilation);\n        if (!fileEmitters) {\n            fileEmitters = new symbol_1.FileEmitterCollection();\n            compilationFileEmitters.set(compilation, fileEmitters);\n            compilation.compiler.webpack.NormalModule.getCompilationHooks(compilation).loader.tap(PLUGIN_NAME, (loaderContext) => {\n                loaderContext[symbol_1.AngularPluginSymbol] = fileEmitters;\n            });\n        }\n        const emitRegistration = fileEmitters.register();\n        return emitRegistration;\n    }\n    markResourceUsed(normalizedResourcePath, currentUnused) {\n        if (!currentUnused.has(normalizedResourcePath)) {\n            return;\n        }\n        currentUnused.delete(normalizedResourcePath);\n        const dependencies = this.fileDependencies.get(normalizedResourcePath);\n        if (!dependencies) {\n            return;\n        }\n        for (const dependency of dependencies) {\n            this.markResourceUsed((0, paths_1.normalizePath)(dependency), currentUnused);\n        }\n    }\n    async rebuildRequiredFiles(modules, compilation, fileEmitter) {\n        if (this.requiredFilesToEmit.size === 0) {\n            return;\n        }\n        const filesToRebuild = new Set();\n        for (const requiredFile of this.requiredFilesToEmit) {\n            const history = await this.getFileEmitHistory(requiredFile);\n            if (history) {\n                const emitResult = await fileEmitter(requiredFile);\n                if ((emitResult === null || emitResult === void 0 ? void 0 : emitResult.content) === undefined ||\n                    history.length !== emitResult.content.length ||\n                    emitResult.hash === undefined ||\n                    Buffer.compare(history.hash, emitResult.hash) !== 0) {\n                    // New emit result is different so rebuild using new emit result\n                    this.requiredFilesToEmitCache.set(requiredFile, emitResult);\n                    filesToRebuild.add(requiredFile);\n                }\n            }\n            else {\n                // No emit history so rebuild\n                filesToRebuild.add(requiredFile);\n            }\n        }\n        if (filesToRebuild.size > 0) {\n            const rebuild = (webpackModule) => new Promise((resolve) => compilation.rebuildModule(webpackModule, () => resolve()));\n            const modulesToRebuild = [];\n            for (const webpackModule of modules) {\n                const resource = webpackModule.resource;\n                if (resource && filesToRebuild.has((0, paths_1.normalizePath)(resource))) {\n                    modulesToRebuild.push(webpackModule);\n                }\n            }\n            await Promise.all(modulesToRebuild.map((webpackModule) => rebuild(webpackModule)));\n        }\n        this.requiredFilesToEmit.clear();\n        this.requiredFilesToEmitCache.clear();\n    }\n    loadConfiguration() {\n        const { options: compilerOptions, rootNames, errors, } = this.compilerCli.readConfiguration(this.pluginOptions.tsconfig, this.pluginOptions.compilerOptions);\n        compilerOptions.noEmitOnError = false;\n        compilerOptions.suppressOutputPathCheck = true;\n        compilerOptions.outDir = undefined;\n        compilerOptions.inlineSources = compilerOptions.sourceMap;\n        compilerOptions.inlineSourceMap = false;\n        compilerOptions.mapRoot = undefined;\n        compilerOptions.sourceRoot = undefined;\n        compilerOptions.allowEmptyCodegenFiles = false;\n        compilerOptions.annotationsAs = 'decorators';\n        compilerOptions.enableResourceInlining = false;\n        return { compilerOptions, rootNames, errors };\n    }\n    updateAotProgram(compilerOptions, rootNames, host, diagnosticsReporter, resourceLoader) {\n        // Create the Angular specific program that contains the Angular compiler\n        const angularProgram = new this.compilerCli.NgtscProgram(rootNames, compilerOptions, host, this.ngtscNextProgram);\n        const angularCompiler = angularProgram.compiler;\n        // The `ignoreForEmit` return value can be safely ignored when emitting. Only files\n        // that will be bundled (requested by Webpack) will be emitted. Combined with TypeScript's\n        // eliding of type only imports, this will cause type only files to be automatically ignored.\n        // Internal Angular type check files are also not resolvable by the bundler. Even if they\n        // were somehow errantly imported, the bundler would error before an emit was attempted.\n        // Diagnostics are still collected for all files which requires using `ignoreForDiagnostics`.\n        const { ignoreForDiagnostics, ignoreForEmit } = angularCompiler;\n        // SourceFile versions are required for builder programs.\n        // The wrapped host inside NgtscProgram adds additional files that will not have versions.\n        const typeScriptProgram = angularProgram.getTsProgram();\n        (0, host_1.augmentProgramWithVersioning)(typeScriptProgram);\n        let builder;\n        if (this.watchMode) {\n            builder = this.builder = ts.createEmitAndSemanticDiagnosticsBuilderProgram(typeScriptProgram, host, this.builder);\n            this.ngtscNextProgram = angularProgram;\n        }\n        else {\n            // When not in watch mode, the startup cost of the incremental analysis can be avoided by\n            // using an abstract builder that only wraps a TypeScript program.\n            builder = ts.createAbstractBuilder(typeScriptProgram, host);\n        }\n        // Update semantic diagnostics cache\n        const affectedFiles = new Set();\n        // Analyze affected files when in watch mode for incremental type checking\n        if ('getSemanticDiagnosticsOfNextAffectedFile' in builder) {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const result = builder.getSemanticDiagnosticsOfNextAffectedFile(undefined, (sourceFile) => {\n                    // If the affected file is a TTC shim, add the shim's original source file.\n                    // This ensures that changes that affect TTC are typechecked even when the changes\n                    // are otherwise unrelated from a TS perspective and do not result in Ivy codegen changes.\n                    // For example, changing @Input property types of a directive used in another component's\n                    // template.\n                    if (ignoreForDiagnostics.has(sourceFile) &&\n                        sourceFile.fileName.endsWith('.ngtypecheck.ts')) {\n                        // This file name conversion relies on internal compiler logic and should be converted\n                        // to an official method when available. 15 is length of `.ngtypecheck.ts`\n                        const originalFilename = sourceFile.fileName.slice(0, -15) + '.ts';\n                        const originalSourceFile = builder.getSourceFile(originalFilename);\n                        if (originalSourceFile) {\n                            affectedFiles.add(originalSourceFile);\n                        }\n                        return true;\n                    }\n                    return false;\n                });\n                if (!result) {\n                    break;\n                }\n                affectedFiles.add(result.affected);\n            }\n        }\n        // Collect program level diagnostics\n        const diagnostics = [\n            ...angularCompiler.getOptionDiagnostics(),\n            ...builder.getOptionsDiagnostics(),\n            ...builder.getGlobalDiagnostics(),\n        ];\n        diagnosticsReporter(diagnostics);\n        // Collect source file specific diagnostics\n        for (const sourceFile of builder.getSourceFiles()) {\n            if (!ignoreForDiagnostics.has(sourceFile)) {\n                diagnosticsReporter(builder.getSyntacticDiagnostics(sourceFile));\n                diagnosticsReporter(builder.getSemanticDiagnostics(sourceFile));\n            }\n        }\n        const transformers = (0, transformation_1.createAotTransformers)(builder, this.pluginOptions);\n        const getDependencies = (sourceFile) => {\n            const dependencies = [];\n            for (const resourcePath of angularCompiler.getResourceDependencies(sourceFile)) {\n                dependencies.push(resourcePath, \n                // Retrieve all dependencies of the resource (stylesheet imports, etc.)\n                ...resourceLoader.getResourceDependencies(resourcePath));\n            }\n            return dependencies;\n        };\n        // Required to support asynchronous resource loading\n        // Must be done before creating transformers or getting template diagnostics\n        const pendingAnalysis = angularCompiler\n            .analyzeAsync()\n            .then(() => {\n            var _a;\n            this.requiredFilesToEmit.clear();\n            for (const sourceFile of builder.getSourceFiles()) {\n                if (sourceFile.isDeclarationFile) {\n                    continue;\n                }\n                // Collect sources that are required to be emitted\n                if (!ignoreForEmit.has(sourceFile) &&\n                    !angularCompiler.incrementalCompilation.safeToSkipEmit(sourceFile)) {\n                    this.requiredFilesToEmit.add((0, paths_1.normalizePath)(sourceFile.fileName));\n                    // If required to emit, diagnostics may have also changed\n                    if (!ignoreForDiagnostics.has(sourceFile)) {\n                        affectedFiles.add(sourceFile);\n                    }\n                }\n                else if (this.sourceFileCache &&\n                    !affectedFiles.has(sourceFile) &&\n                    !ignoreForDiagnostics.has(sourceFile)) {\n                    // Use cached Angular diagnostics for unchanged and unaffected files\n                    const angularDiagnostics = this.sourceFileCache.getAngularDiagnostics(sourceFile);\n                    if (angularDiagnostics) {\n                        diagnosticsReporter(angularDiagnostics);\n                    }\n                }\n            }\n            // Collect new Angular diagnostics for files affected by changes\n            const OptimizeFor = this.compilerCli.OptimizeFor;\n            const optimizeDiagnosticsFor = affectedFiles.size <= DIAGNOSTICS_AFFECTED_THRESHOLD\n                ? OptimizeFor.SingleFile\n                : OptimizeFor.WholeProgram;\n            for (const affectedFile of affectedFiles) {\n                const angularDiagnostics = angularCompiler.getDiagnosticsForFile(affectedFile, optimizeDiagnosticsFor);\n                diagnosticsReporter(angularDiagnostics);\n                (_a = this.sourceFileCache) === null || _a === void 0 ? void 0 : _a.updateAngularDiagnostics(affectedFile, angularDiagnostics);\n            }\n            return {\n                emitter: this.createFileEmitter(builder, (0, transformation_1.mergeTransformers)(angularCompiler.prepareEmit().transformers, transformers), getDependencies, (sourceFile) => {\n                    this.requiredFilesToEmit.delete((0, paths_1.normalizePath)(sourceFile.fileName));\n                    angularCompiler.incrementalCompilation.recordSuccessfulEmit(sourceFile);\n                }),\n            };\n        })\n            .catch((err) => ({ errorMessage: err instanceof Error ? err.message : `${err}` }));\n        const analyzingFileEmitter = async (file) => {\n            const analysis = await pendingAnalysis;\n            if ('errorMessage' in analysis) {\n                throw new Error(analysis.errorMessage);\n            }\n            return analysis.emitter(file);\n        };\n        return {\n            fileEmitter: analyzingFileEmitter,\n            builder,\n            internalFiles: ignoreForEmit,\n        };\n    }\n    updateJitProgram(compilerOptions, rootNames, host, diagnosticsReporter) {\n        let builder;\n        if (this.watchMode) {\n            builder = this.builder = ts.createEmitAndSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, this.builder);\n        }\n        else {\n            // When not in watch mode, the startup cost of the incremental analysis can be avoided by\n            // using an abstract builder that only wraps a TypeScript program.\n            builder = ts.createAbstractBuilder(rootNames, compilerOptions, host);\n        }\n        const diagnostics = [\n            ...builder.getOptionsDiagnostics(),\n            ...builder.getGlobalDiagnostics(),\n            ...builder.getSyntacticDiagnostics(),\n            // Gather incremental semantic diagnostics\n            ...builder.getSemanticDiagnostics(),\n        ];\n        diagnosticsReporter(diagnostics);\n        const transformers = (0, transformation_1.createJitTransformers)(builder, this.compilerCli, this.pluginOptions);\n        return {\n            fileEmitter: this.createFileEmitter(builder, transformers, () => []),\n            builder,\n            internalFiles: undefined,\n        };\n    }\n    createFileEmitter(program, transformers = {}, getExtraDependencies, onAfterEmit) {\n        return async (file) => {\n            const filePath = (0, paths_1.normalizePath)(file);\n            if (this.requiredFilesToEmitCache.has(filePath)) {\n                return this.requiredFilesToEmitCache.get(filePath);\n            }\n            const sourceFile = program.getSourceFile(filePath);\n            if (!sourceFile) {\n                return undefined;\n            }\n            let content;\n            let map;\n            program.emit(sourceFile, (filename, data) => {\n                if (filename.endsWith('.map')) {\n                    map = data;\n                }\n                else if (filename.endsWith('.js')) {\n                    content = data;\n                }\n            }, undefined, undefined, transformers);\n            onAfterEmit === null || onAfterEmit === void 0 ? void 0 : onAfterEmit(sourceFile);\n            // Capture emit history info for Angular rebuild analysis\n            const hash = content ? (await this.addFileEmitHistory(filePath, content)).hash : undefined;\n            const dependencies = [\n                ...(this.fileDependencies.get(filePath) || []),\n                ...getExtraDependencies(sourceFile),\n            ].map(paths_1.externalizePath);\n            return { content, map, dependencies, hash };\n        };\n    }\n    async initializeCompilerCli() {\n        if (this.compilerCliModule) {\n            return;\n        }\n        // This uses a dynamic import to load `@angular/compiler-cli` which may be ESM.\n        // CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript\n        // will currently, unconditionally downlevel dynamic import into a require call.\n        // require calls cannot load ESM code and will result in a runtime error. To workaround\n        // this, a Function constructor is used to prevent TypeScript from changing the dynamic import.\n        // Once TypeScript provides support for keeping the dynamic import this workaround can\n        // be dropped.\n        this.compilerCliModule = await new Function(`return import('@angular/compiler-cli');`)();\n        this.compilerNgccModule = await new Function(`return import('@angular/compiler-cli/ngcc');`)();\n    }\n    async addFileEmitHistory(filePath, content) {\n        assert_1.strict.ok(this.webpackCreateHash, 'File emitter is used prior to Webpack compilation');\n        const historyData = {\n            length: content.length,\n            hash: this.webpackCreateHash('xxhash64').update(content).digest(),\n        };\n        if (this.webpackCache) {\n            const history = await this.getFileEmitHistory(filePath);\n            if (!history || Buffer.compare(history.hash, historyData.hash) !== 0) {\n                // Hash doesn't match or item doesn't exist.\n                await this.webpackCache.storePromise(filePath, null, historyData);\n            }\n        }\n        else if (this.watchMode) {\n            // The in memory file emit history is only required during watch mode.\n            this.fileEmitHistory.set(filePath, historyData);\n        }\n        return historyData;\n    }\n    async getFileEmitHistory(filePath) {\n        return this.webpackCache\n            ? this.webpackCache.getPromise(filePath, null)\n            : this.fileEmitHistory.get(filePath);\n    }\n}\nexports.AngularWebpackPlugin = AngularWebpackPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}