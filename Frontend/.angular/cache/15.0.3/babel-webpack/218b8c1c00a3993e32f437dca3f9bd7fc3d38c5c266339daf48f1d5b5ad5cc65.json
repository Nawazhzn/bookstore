{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst transform = {\n  trimStart: s => s.trimStart(),\n  trimEnd: s => s.trimEnd(),\n  trimLeft: s => s.trimStart(),\n  trimRight: s => s.trimEnd(),\n  trim: s => s.trim(),\n  toLowerCase: s => s.toLowerCase(),\n  toUpperCase: s => s.toUpperCase(),\n  toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s\n};\nconst getDef = Object.assign(_getDef, {\n  transform\n});\nfunction _getDef() {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n    code(cxt) {\n      const {\n        gen,\n        data,\n        schema,\n        parentSchema,\n        it\n      } = cxt;\n      const {\n        parentData,\n        parentDataProperty\n      } = it;\n      const tNames = schema;\n      if (!tNames.length) return;\n      let cfg;\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema);\n        cfg = gen.scopeValue(\"obj\", {\n          ref: config,\n          code: (0, codegen_1.stringify)(config)\n        });\n      }\n      gen.if((0, codegen_1._)`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()));\n        gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, data);\n      });\n      function transformExpr(ts) {\n        if (!ts.length) return data;\n        const t = ts.pop();\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`);\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t],\n          code: (0, codegen_1._)`require(\"ajv-keywords/dist/definitions/transform\").transform${(0, codegen_1.getProperty)(t)}`\n        });\n        const arg = transformExpr(ts);\n        return cfg && t === \"toEnumCase\" ? (0, codegen_1._)`${func}(${arg}, ${cfg})` : (0, codegen_1._)`${func}(${arg})`;\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        enum: Object.keys(transform)\n      }\n    }\n  };\n}\nfunction getEnumCaseCfg(parentSchema) {\n  // build hash table to enum values\n  const cfg = {\n    hash: {}\n  };\n  // requires `enum` in the same schema as transform\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"');\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue;\n    const k = configKey(v);\n    // requires all `enum` values have unique keys\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique');\n    }\n    cfg.hash[k] = v;\n  }\n  return cfg;\n}\nfunction configKey(s) {\n  return s.toLowerCase();\n}\nexports.default = getDef;\nmodule.exports = getDef;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","transform","trimStart","s","trimEnd","trimLeft","trimRight","trim","toLowerCase","toUpperCase","toEnumCase","cfg","hash","configKey","getDef","assign","_getDef","keyword","schemaType","before","code","cxt","gen","data","schema","parentSchema","it","parentData","parentDataProperty","tNames","length","includes","config","getEnumCaseCfg","scopeValue","ref","stringify","if","_","transformExpr","slice","ts","t","pop","Error","func","getProperty","arg","metaSchema","type","items","enum","keys","v","k","default","module"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/ajv-keywords/dist/definitions/transform.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst transform = {\n    trimStart: (s) => s.trimStart(),\n    trimEnd: (s) => s.trimEnd(),\n    trimLeft: (s) => s.trimStart(),\n    trimRight: (s) => s.trimEnd(),\n    trim: (s) => s.trim(),\n    toLowerCase: (s) => s.toLowerCase(),\n    toUpperCase: (s) => s.toUpperCase(),\n    toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s,\n};\nconst getDef = Object.assign(_getDef, { transform });\nfunction _getDef() {\n    return {\n        keyword: \"transform\",\n        schemaType: \"array\",\n        before: \"enum\",\n        code(cxt) {\n            const { gen, data, schema, parentSchema, it } = cxt;\n            const { parentData, parentDataProperty } = it;\n            const tNames = schema;\n            if (!tNames.length)\n                return;\n            let cfg;\n            if (tNames.includes(\"toEnumCase\")) {\n                const config = getEnumCaseCfg(parentSchema);\n                cfg = gen.scopeValue(\"obj\", { ref: config, code: (0, codegen_1.stringify)(config) });\n            }\n            gen.if((0, codegen_1._) `typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n                gen.assign(data, transformExpr(tNames.slice()));\n                gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, data);\n            });\n            function transformExpr(ts) {\n                if (!ts.length)\n                    return data;\n                const t = ts.pop();\n                if (!(t in transform))\n                    throw new Error(`transform: unknown transformation ${t}`);\n                const func = gen.scopeValue(\"func\", {\n                    ref: transform[t],\n                    code: (0, codegen_1._) `require(\"ajv-keywords/dist/definitions/transform\").transform${(0, codegen_1.getProperty)(t)}`,\n                });\n                const arg = transformExpr(ts);\n                return cfg && t === \"toEnumCase\" ? (0, codegen_1._) `${func}(${arg}, ${cfg})` : (0, codegen_1._) `${func}(${arg})`;\n            }\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\", enum: Object.keys(transform) },\n        },\n    };\n}\nfunction getEnumCaseCfg(parentSchema) {\n    // build hash table to enum values\n    const cfg = { hash: {} };\n    // requires `enum` in the same schema as transform\n    if (!parentSchema.enum)\n        throw new Error('transform: \"toEnumCase\" requires \"enum\"');\n    for (const v of parentSchema.enum) {\n        if (typeof v !== \"string\")\n            continue;\n        const k = configKey(v);\n        // requires all `enum` values have unique keys\n        if (cfg.hash[k]) {\n            throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique');\n        }\n        cfg.hash[k] = v;\n    }\n    return cfg;\n}\nfunction configKey(s) {\n    return s.toLowerCase();\n}\nexports.default = getDef;\nmodule.exports = getDef;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,SAAS,GAAGC,OAAO,CAAC,0BAA0B,CAAC;AACrD,MAAMC,SAAS,GAAG;EACdC,SAAS,EAAGC,CAAC,IAAKA,CAAC,CAACD,SAAS,EAAE;EAC/BE,OAAO,EAAGD,CAAC,IAAKA,CAAC,CAACC,OAAO,EAAE;EAC3BC,QAAQ,EAAGF,CAAC,IAAKA,CAAC,CAACD,SAAS,EAAE;EAC9BI,SAAS,EAAGH,CAAC,IAAKA,CAAC,CAACC,OAAO,EAAE;EAC7BG,IAAI,EAAGJ,CAAC,IAAKA,CAAC,CAACI,IAAI,EAAE;EACrBC,WAAW,EAAGL,CAAC,IAAKA,CAAC,CAACK,WAAW,EAAE;EACnCC,WAAW,EAAGN,CAAC,IAAKA,CAAC,CAACM,WAAW,EAAE;EACnCC,UAAU,EAAE,CAACP,CAAC,EAAEQ,GAAG,KAAK,CAACA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACC,IAAI,CAACC,SAAS,CAACV,CAAC,CAAC,CAAC,KAAKA;AAClG,CAAC;AACD,MAAMW,MAAM,GAAGnB,MAAM,CAACoB,MAAM,CAACC,OAAO,EAAE;EAAEf;AAAU,CAAC,CAAC;AACpD,SAASe,OAAO,GAAG;EACf,OAAO;IACHC,OAAO,EAAE,WAAW;IACpBC,UAAU,EAAE,OAAO;IACnBC,MAAM,EAAE,MAAM;IACdC,IAAI,CAACC,GAAG,EAAE;MACN,MAAM;QAAEC,GAAG;QAAEC,IAAI;QAAEC,MAAM;QAAEC,YAAY;QAAEC;MAAG,CAAC,GAAGL,GAAG;MACnD,MAAM;QAAEM,UAAU;QAAEC;MAAmB,CAAC,GAAGF,EAAE;MAC7C,MAAMG,MAAM,GAAGL,MAAM;MACrB,IAAI,CAACK,MAAM,CAACC,MAAM,EACd;MACJ,IAAInB,GAAG;MACP,IAAIkB,MAAM,CAACE,QAAQ,CAAC,YAAY,CAAC,EAAE;QAC/B,MAAMC,MAAM,GAAGC,cAAc,CAACR,YAAY,CAAC;QAC3Cd,GAAG,GAAGW,GAAG,CAACY,UAAU,CAAC,KAAK,EAAE;UAAEC,GAAG,EAAEH,MAAM;UAAEZ,IAAI,EAAE,CAAC,CAAC,EAAErB,SAAS,CAACqC,SAAS,EAAEJ,MAAM;QAAE,CAAC,CAAC;MACxF;MACAV,GAAG,CAACe,EAAE,CAAC,CAAC,CAAC,EAAEtC,SAAS,CAACuC,CAAC,CAAG,UAASf,IAAK,mBAAkBI,UAAW,gBAAe,EAAE,MAAM;QACvFL,GAAG,CAACP,MAAM,CAACQ,IAAI,EAAEgB,aAAa,CAACV,MAAM,CAACW,KAAK,EAAE,CAAC,CAAC;QAC/ClB,GAAG,CAACP,MAAM,CAAC,CAAC,CAAC,EAAEhB,SAAS,CAACuC,CAAC,CAAG,GAAEX,UAAW,IAAGC,kBAAmB,GAAE,EAAEL,IAAI,CAAC;MAC7E,CAAC,CAAC;MACF,SAASgB,aAAa,CAACE,EAAE,EAAE;QACvB,IAAI,CAACA,EAAE,CAACX,MAAM,EACV,OAAOP,IAAI;QACf,MAAMmB,CAAC,GAAGD,EAAE,CAACE,GAAG,EAAE;QAClB,IAAI,EAAED,CAAC,IAAIzC,SAAS,CAAC,EACjB,MAAM,IAAI2C,KAAK,CAAE,qCAAoCF,CAAE,EAAC,CAAC;QAC7D,MAAMG,IAAI,GAAGvB,GAAG,CAACY,UAAU,CAAC,MAAM,EAAE;UAChCC,GAAG,EAAElC,SAAS,CAACyC,CAAC,CAAC;UACjBtB,IAAI,EAAE,CAAC,CAAC,EAAErB,SAAS,CAACuC,CAAC,CAAG,+DAA8D,CAAC,CAAC,EAAEvC,SAAS,CAAC+C,WAAW,EAAEJ,CAAC,CAAE;QACxH,CAAC,CAAC;QACF,MAAMK,GAAG,GAAGR,aAAa,CAACE,EAAE,CAAC;QAC7B,OAAO9B,GAAG,IAAI+B,CAAC,KAAK,YAAY,GAAG,CAAC,CAAC,EAAE3C,SAAS,CAACuC,CAAC,CAAG,GAAEO,IAAK,IAAGE,GAAI,KAAIpC,GAAI,GAAE,GAAG,CAAC,CAAC,EAAEZ,SAAS,CAACuC,CAAC,CAAG,GAAEO,IAAK,IAAGE,GAAI,GAAE;MACtH;IACJ,CAAC;IACDC,UAAU,EAAE;MACRC,IAAI,EAAE,OAAO;MACbC,KAAK,EAAE;QAAED,IAAI,EAAE,QAAQ;QAAEE,IAAI,EAAExD,MAAM,CAACyD,IAAI,CAACnD,SAAS;MAAE;IAC1D;EACJ,CAAC;AACL;AACA,SAASgC,cAAc,CAACR,YAAY,EAAE;EAClC;EACA,MAAMd,GAAG,GAAG;IAAEC,IAAI,EAAE,CAAC;EAAE,CAAC;EACxB;EACA,IAAI,CAACa,YAAY,CAAC0B,IAAI,EAClB,MAAM,IAAIP,KAAK,CAAC,yCAAyC,CAAC;EAC9D,KAAK,MAAMS,CAAC,IAAI5B,YAAY,CAAC0B,IAAI,EAAE;IAC/B,IAAI,OAAOE,CAAC,KAAK,QAAQ,EACrB;IACJ,MAAMC,CAAC,GAAGzC,SAAS,CAACwC,CAAC,CAAC;IACtB;IACA,IAAI1C,GAAG,CAACC,IAAI,CAAC0C,CAAC,CAAC,EAAE;MACb,MAAM,IAAIV,KAAK,CAAC,4EAA4E,CAAC;IACjG;IACAjC,GAAG,CAACC,IAAI,CAAC0C,CAAC,CAAC,GAAGD,CAAC;EACnB;EACA,OAAO1C,GAAG;AACd;AACA,SAASE,SAAS,CAACV,CAAC,EAAE;EAClB,OAAOA,CAAC,CAACK,WAAW,EAAE;AAC1B;AACAX,OAAO,CAAC0D,OAAO,GAAGzC,MAAM;AACxB0C,MAAM,CAAC3D,OAAO,GAAGiB,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}