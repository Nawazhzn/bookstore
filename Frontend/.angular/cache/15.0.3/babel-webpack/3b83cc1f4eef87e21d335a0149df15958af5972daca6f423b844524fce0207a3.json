{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InlineFontsProcessor = void 0;\nconst cacache = __importStar(require(\"cacache\"));\nconst fs = __importStar(require(\"fs\"));\nconst https = __importStar(require(\"https\"));\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst package_version_1 = require(\"../package-version\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\nconst SUPPORTED_PROVIDERS = {\n  'fonts.googleapis.com': {\n    preconnectUrl: 'https://fonts.gstatic.com'\n  },\n  'use.typekit.net': {\n    preconnectUrl: 'https://use.typekit.net'\n  }\n};\nclass InlineFontsProcessor {\n  constructor(options) {\n    this.options = options;\n    const {\n      path: cacheDirectory,\n      enabled\n    } = this.options.cache || {};\n    if (cacheDirectory && enabled) {\n      this.cachePath = (0, path_1.join)(cacheDirectory, 'angular-build-fonts');\n    }\n  }\n  process(content) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const hrefList = [];\n      const existingPreconnect = new Set();\n      // Collector link tags with href\n      const {\n        rewriter: collectorStream,\n        transformedContent: initCollectorStream\n      } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n      collectorStream.on('startTag', tag => {\n        const {\n          tagName,\n          attrs\n        } = tag;\n        if (tagName !== 'link') {\n          return;\n        }\n        let hrefValue;\n        let relValue;\n        for (const {\n          name,\n          value\n        } of attrs) {\n          switch (name) {\n            case 'rel':\n              relValue = value;\n              break;\n            case 'href':\n              hrefValue = value;\n              break;\n          }\n          if (hrefValue && relValue) {\n            switch (relValue) {\n              case 'stylesheet':\n                // <link rel=\"stylesheet\" href=\"https://example.com/main.css\">\n                hrefList.push(hrefValue);\n                break;\n              case 'preconnect':\n                // <link rel=\"preconnect\" href=\"https://example.com\">\n                existingPreconnect.add(hrefValue.replace(/\\/$/, ''));\n                break;\n            }\n            return;\n          }\n        }\n      });\n      initCollectorStream().catch(() => {\n        // We don't really care about any errors here because it just initializes\n        // the rewriting stream, as we are waiting for `finish` below.\n      });\n      yield new Promise(resolve => collectorStream.on('finish', resolve));\n      // Download stylesheets\n      const hrefsContent = new Map();\n      const newPreconnectUrls = new Set();\n      for (const hrefItem of hrefList) {\n        const url = _this.createNormalizedUrl(hrefItem);\n        if (!url) {\n          continue;\n        }\n        const content = yield _this.processHref(url);\n        if (content === undefined) {\n          continue;\n        }\n        hrefsContent.set(hrefItem, content);\n        // Add preconnect\n        const preconnectUrl = (_a = _this.getFontProviderDetails(url)) === null || _a === void 0 ? void 0 : _a.preconnectUrl;\n        if (preconnectUrl && !existingPreconnect.has(preconnectUrl)) {\n          newPreconnectUrls.add(preconnectUrl);\n        }\n      }\n      if (hrefsContent.size === 0) {\n        return content;\n      }\n      // Replace link with style tag.\n      const {\n        rewriter,\n        transformedContent\n      } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n      rewriter.on('startTag', tag => {\n        const {\n          tagName,\n          attrs\n        } = tag;\n        switch (tagName) {\n          case 'head':\n            rewriter.emitStartTag(tag);\n            for (const url of newPreconnectUrls) {\n              rewriter.emitRaw(`<link rel=\"preconnect\" href=\"${url}\" crossorigin>`);\n            }\n            break;\n          case 'link':\n            const hrefAttr = attrs.some(({\n              name,\n              value\n            }) => name === 'rel' && value === 'stylesheet') && attrs.find(({\n              name,\n              value\n            }) => name === 'href' && hrefsContent.has(value));\n            if (hrefAttr) {\n              const href = hrefAttr.value;\n              const cssContent = hrefsContent.get(href);\n              rewriter.emitRaw(`<style type=\"text/css\">${cssContent}</style>`);\n            } else {\n              rewriter.emitStartTag(tag);\n            }\n            break;\n          default:\n            rewriter.emitStartTag(tag);\n            break;\n        }\n      });\n      return transformedContent();\n    })();\n  }\n  getResponse(url) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const key = `${package_version_1.VERSION}|${url}`;\n      if (_this2.cachePath) {\n        const entry = yield cacache.get.info(_this2.cachePath, key);\n        if (entry) {\n          return fs.promises.readFile(entry.path, 'utf8');\n        }\n      }\n      let agent;\n      const httpsProxy = (_a = process.env.HTTPS_PROXY) !== null && _a !== void 0 ? _a : process.env.https_proxy;\n      if (httpsProxy) {\n        agent = (0, https_proxy_agent_1.default)(httpsProxy);\n      }\n      const data = yield new Promise((resolve, reject) => {\n        let rawResponse = '';\n        https.get(url, {\n          agent,\n          rejectUnauthorized: false,\n          headers: {\n            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36'\n          }\n        }, res => {\n          if (res.statusCode !== 200) {\n            reject(new Error(`Inlining of fonts failed. ${url} returned status code: ${res.statusCode}.`));\n            return;\n          }\n          res.on('data', chunk => rawResponse += chunk).on('end', () => resolve(rawResponse));\n        }).on('error', e => reject(new Error(`Inlining of fonts failed. An error has occurred while retrieving ${url} over the internet.\\n` + e.message)));\n      });\n      if (_this2.cachePath) {\n        yield cacache.put(_this2.cachePath, key, data);\n      }\n      return data;\n    })();\n  }\n  processHref(url) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const provider = _this3.getFontProviderDetails(url);\n      if (!provider) {\n        return undefined;\n      }\n      let cssContent = yield _this3.getResponse(url);\n      if (_this3.options.minify) {\n        cssContent = cssContent\n        // Comments.\n        .replace(/\\/\\*([\\s\\S]*?)\\*\\//g, '')\n        // New lines.\n        .replace(/\\n/g, '')\n        // Safe spaces.\n        .replace(/\\s?[{:;]\\s+/g, s => s.trim());\n      }\n      return cssContent;\n    })();\n  }\n  getFontProviderDetails(url) {\n    return SUPPORTED_PROVIDERS[url.hostname];\n  }\n  createNormalizedUrl(value) {\n    // Need to convert '//' to 'https://' because the URL parser will fail with '//'.\n    const normalizedHref = value.startsWith('//') ? `https:${value}` : value;\n    if (!normalizedHref.startsWith('http')) {\n      // Non valid URL.\n      // Example: relative path styles.css.\n      return undefined;\n    }\n    const url = new url_1.URL(normalizedHref);\n    // Force HTTPS protocol\n    url.protocol = 'https:';\n    return url;\n  }\n}\nexports.InlineFontsProcessor = InlineFontsProcessor;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","InlineFontsProcessor","cacache","require","fs","https","https_proxy_agent_1","path_1","url_1","package_version_1","html_rewriting_stream_1","SUPPORTED_PROVIDERS","preconnectUrl","constructor","options","path","cacheDirectory","enabled","cache","cachePath","join","process","content","_a","hrefList","existingPreconnect","Set","rewriter","collectorStream","transformedContent","initCollectorStream","htmlRewritingStream","on","tag","tagName","attrs","hrefValue","relValue","name","push","add","replace","catch","Promise","resolve","hrefsContent","Map","newPreconnectUrls","hrefItem","url","createNormalizedUrl","processHref","set","getFontProviderDetails","has","size","emitStartTag","emitRaw","hrefAttr","some","find","href","cssContent","getResponse","key","VERSION","entry","info","promises","readFile","agent","httpsProxy","env","HTTPS_PROXY","https_proxy","default","data","reject","rawResponse","rejectUnauthorized","headers","res","statusCode","Error","chunk","e","message","put","provider","minify","s","trim","hostname","normalizedHref","startsWith","URL","protocol"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@angular-devkit/build-angular/src/utils/index-file/inline-fonts.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineFontsProcessor = void 0;\nconst cacache = __importStar(require(\"cacache\"));\nconst fs = __importStar(require(\"fs\"));\nconst https = __importStar(require(\"https\"));\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst package_version_1 = require(\"../package-version\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\nconst SUPPORTED_PROVIDERS = {\n    'fonts.googleapis.com': {\n        preconnectUrl: 'https://fonts.gstatic.com',\n    },\n    'use.typekit.net': {\n        preconnectUrl: 'https://use.typekit.net',\n    },\n};\nclass InlineFontsProcessor {\n    constructor(options) {\n        this.options = options;\n        const { path: cacheDirectory, enabled } = this.options.cache || {};\n        if (cacheDirectory && enabled) {\n            this.cachePath = (0, path_1.join)(cacheDirectory, 'angular-build-fonts');\n        }\n    }\n    async process(content) {\n        var _a;\n        const hrefList = [];\n        const existingPreconnect = new Set();\n        // Collector link tags with href\n        const { rewriter: collectorStream, transformedContent: initCollectorStream } = await (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n        collectorStream.on('startTag', (tag) => {\n            const { tagName, attrs } = tag;\n            if (tagName !== 'link') {\n                return;\n            }\n            let hrefValue;\n            let relValue;\n            for (const { name, value } of attrs) {\n                switch (name) {\n                    case 'rel':\n                        relValue = value;\n                        break;\n                    case 'href':\n                        hrefValue = value;\n                        break;\n                }\n                if (hrefValue && relValue) {\n                    switch (relValue) {\n                        case 'stylesheet':\n                            // <link rel=\"stylesheet\" href=\"https://example.com/main.css\">\n                            hrefList.push(hrefValue);\n                            break;\n                        case 'preconnect':\n                            // <link rel=\"preconnect\" href=\"https://example.com\">\n                            existingPreconnect.add(hrefValue.replace(/\\/$/, ''));\n                            break;\n                    }\n                    return;\n                }\n            }\n        });\n        initCollectorStream().catch(() => {\n            // We don't really care about any errors here because it just initializes\n            // the rewriting stream, as we are waiting for `finish` below.\n        });\n        await new Promise((resolve) => collectorStream.on('finish', resolve));\n        // Download stylesheets\n        const hrefsContent = new Map();\n        const newPreconnectUrls = new Set();\n        for (const hrefItem of hrefList) {\n            const url = this.createNormalizedUrl(hrefItem);\n            if (!url) {\n                continue;\n            }\n            const content = await this.processHref(url);\n            if (content === undefined) {\n                continue;\n            }\n            hrefsContent.set(hrefItem, content);\n            // Add preconnect\n            const preconnectUrl = (_a = this.getFontProviderDetails(url)) === null || _a === void 0 ? void 0 : _a.preconnectUrl;\n            if (preconnectUrl && !existingPreconnect.has(preconnectUrl)) {\n                newPreconnectUrls.add(preconnectUrl);\n            }\n        }\n        if (hrefsContent.size === 0) {\n            return content;\n        }\n        // Replace link with style tag.\n        const { rewriter, transformedContent } = await (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n        rewriter.on('startTag', (tag) => {\n            const { tagName, attrs } = tag;\n            switch (tagName) {\n                case 'head':\n                    rewriter.emitStartTag(tag);\n                    for (const url of newPreconnectUrls) {\n                        rewriter.emitRaw(`<link rel=\"preconnect\" href=\"${url}\" crossorigin>`);\n                    }\n                    break;\n                case 'link':\n                    const hrefAttr = attrs.some(({ name, value }) => name === 'rel' && value === 'stylesheet') &&\n                        attrs.find(({ name, value }) => name === 'href' && hrefsContent.has(value));\n                    if (hrefAttr) {\n                        const href = hrefAttr.value;\n                        const cssContent = hrefsContent.get(href);\n                        rewriter.emitRaw(`<style type=\"text/css\">${cssContent}</style>`);\n                    }\n                    else {\n                        rewriter.emitStartTag(tag);\n                    }\n                    break;\n                default:\n                    rewriter.emitStartTag(tag);\n                    break;\n            }\n        });\n        return transformedContent();\n    }\n    async getResponse(url) {\n        var _a;\n        const key = `${package_version_1.VERSION}|${url}`;\n        if (this.cachePath) {\n            const entry = await cacache.get.info(this.cachePath, key);\n            if (entry) {\n                return fs.promises.readFile(entry.path, 'utf8');\n            }\n        }\n        let agent;\n        const httpsProxy = (_a = process.env.HTTPS_PROXY) !== null && _a !== void 0 ? _a : process.env.https_proxy;\n        if (httpsProxy) {\n            agent = (0, https_proxy_agent_1.default)(httpsProxy);\n        }\n        const data = await new Promise((resolve, reject) => {\n            let rawResponse = '';\n            https\n                .get(url, {\n                agent,\n                rejectUnauthorized: false,\n                headers: {\n                    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36',\n                },\n            }, (res) => {\n                if (res.statusCode !== 200) {\n                    reject(new Error(`Inlining of fonts failed. ${url} returned status code: ${res.statusCode}.`));\n                    return;\n                }\n                res.on('data', (chunk) => (rawResponse += chunk)).on('end', () => resolve(rawResponse));\n            })\n                .on('error', (e) => reject(new Error(`Inlining of fonts failed. An error has occurred while retrieving ${url} over the internet.\\n` +\n                e.message)));\n        });\n        if (this.cachePath) {\n            await cacache.put(this.cachePath, key, data);\n        }\n        return data;\n    }\n    async processHref(url) {\n        const provider = this.getFontProviderDetails(url);\n        if (!provider) {\n            return undefined;\n        }\n        let cssContent = await this.getResponse(url);\n        if (this.options.minify) {\n            cssContent = cssContent\n                // Comments.\n                .replace(/\\/\\*([\\s\\S]*?)\\*\\//g, '')\n                // New lines.\n                .replace(/\\n/g, '')\n                // Safe spaces.\n                .replace(/\\s?[{:;]\\s+/g, (s) => s.trim());\n        }\n        return cssContent;\n    }\n    getFontProviderDetails(url) {\n        return SUPPORTED_PROVIDERS[url.hostname];\n    }\n    createNormalizedUrl(value) {\n        // Need to convert '//' to 'https://' because the URL parser will fail with '//'.\n        const normalizedHref = value.startsWith('//') ? `https:${value}` : value;\n        if (!normalizedHref.startsWith('http')) {\n            // Non valid URL.\n            // Example: relative path styles.css.\n            return undefined;\n        }\n        const url = new url_1.URL(normalizedHref);\n        // Force HTTPS protocol\n        url.protocol = 'https:';\n        return url;\n    }\n}\nexports.InlineFontsProcessor = InlineFontsProcessor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}