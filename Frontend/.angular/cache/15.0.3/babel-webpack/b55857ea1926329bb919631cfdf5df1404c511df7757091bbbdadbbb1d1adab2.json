{"ast":null,"code":"const BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\nclass BulkUpdateDecorator {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    this.hashKey = hashKey;\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n    this.buffer = \"\";\n  }\n\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n  update(data, inputEncoding) {\n    if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n      if (this.hash === undefined) {\n        this.hash = this.hashFactory();\n      }\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) {\n          this.hash = this.hashFactory();\n        }\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n  digest(encoding) {\n    let digestCache;\n    const buffer = this.buffer;\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n      digestCache = digestCaches[cacheKey];\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n      const cacheEntry = digestCache.get(buffer);\n      if (cacheEntry !== undefined) {\n        return cacheEntry;\n      }\n      this.hash = this.hashFactory();\n    }\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n    const digestResult = this.hash.digest(encoding);\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, digestResult);\n    }\n    return digestResult;\n  }\n}\nmodule.exports = BulkUpdateDecorator;","map":{"version":3,"names":["BULK_SIZE","digestCaches","BulkUpdateDecorator","constructor","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","update","data","inputEncoding","length","digest","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","set","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/loader-utils/lib/hash/BulkUpdateDecorator.js"],"sourcesContent":["const BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\n\nclass BulkUpdateDecorator {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n\n    this.buffer = \"\";\n  }\n\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n  update(data, inputEncoding) {\n    if (\n      inputEncoding !== undefined ||\n      typeof data !== \"string\" ||\n      data.length > BULK_SIZE\n    ) {\n      if (this.hash === undefined) {\n        this.hash = this.hashFactory();\n      }\n\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) {\n          this.hash = this.hashFactory();\n        }\n\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n  digest(encoding) {\n    let digestCache;\n\n    const buffer = this.buffer;\n\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n\n      digestCache = digestCaches[cacheKey];\n\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n\n      const cacheEntry = digestCache.get(buffer);\n\n      if (cacheEntry !== undefined) {\n        return cacheEntry;\n      }\n\n      this.hash = this.hashFactory();\n    }\n\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n\n    const digestResult = this.hash.digest(encoding);\n\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, digestResult);\n    }\n\n    return digestResult;\n  }\n}\n\nmodule.exports = BulkUpdateDecorator;\n"],"mappings":"AAAA,MAAMA,SAAS,GAAG,IAAI;;AAEtB;AACA;AACA,MAAMC,YAAY,GAAG,CAAC,CAAC;AAEvB,MAAMC,mBAAmB,CAAC;EACxB;AACF;AACA;AACA;EACEC,WAAW,CAACC,aAAa,EAAEC,OAAO,EAAE;IAClC,IAAI,CAACA,OAAO,GAAGA,OAAO;IAEtB,IAAI,OAAOD,aAAa,KAAK,UAAU,EAAE;MACvC,IAAI,CAACE,WAAW,GAAGF,aAAa;MAChC,IAAI,CAACG,IAAI,GAAGC,SAAS;IACvB,CAAC,MAAM;MACL,IAAI,CAACF,WAAW,GAAGE,SAAS;MAC5B,IAAI,CAACD,IAAI,GAAGH,aAAa;IAC3B;IAEA,IAAI,CAACK,MAAM,GAAG,EAAE;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,MAAM,CAACC,IAAI,EAAEC,aAAa,EAAE;IAC1B,IACEA,aAAa,KAAKJ,SAAS,IAC3B,OAAOG,IAAI,KAAK,QAAQ,IACxBA,IAAI,CAACE,MAAM,GAAGb,SAAS,EACvB;MACA,IAAI,IAAI,CAACO,IAAI,KAAKC,SAAS,EAAE;QAC3B,IAAI,CAACD,IAAI,GAAG,IAAI,CAACD,WAAW,EAAE;MAChC;MAEA,IAAI,IAAI,CAACG,MAAM,CAACI,MAAM,GAAG,CAAC,EAAE;QAC1B,IAAI,CAACN,IAAI,CAACG,MAAM,CAAC,IAAI,CAACD,MAAM,CAAC;QAC7B,IAAI,CAACA,MAAM,GAAG,EAAE;MAClB;MAEA,IAAI,CAACF,IAAI,CAACG,MAAM,CAACC,IAAI,EAAEC,aAAa,CAAC;IACvC,CAAC,MAAM;MACL,IAAI,CAACH,MAAM,IAAIE,IAAI;MAEnB,IAAI,IAAI,CAACF,MAAM,CAACI,MAAM,GAAGb,SAAS,EAAE;QAClC,IAAI,IAAI,CAACO,IAAI,KAAKC,SAAS,EAAE;UAC3B,IAAI,CAACD,IAAI,GAAG,IAAI,CAACD,WAAW,EAAE;QAChC;QAEA,IAAI,CAACC,IAAI,CAACG,MAAM,CAAC,IAAI,CAACD,MAAM,CAAC;QAC7B,IAAI,CAACA,MAAM,GAAG,EAAE;MAClB;IACF;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEK,MAAM,CAACC,QAAQ,EAAE;IACf,IAAIC,WAAW;IAEf,MAAMP,MAAM,GAAG,IAAI,CAACA,MAAM;IAE1B,IAAI,IAAI,CAACF,IAAI,KAAKC,SAAS,EAAE;MAC3B;MACA,MAAMS,QAAQ,GAAI,GAAE,IAAI,CAACZ,OAAQ,IAAGU,QAAS,EAAC;MAE9CC,WAAW,GAAGf,YAAY,CAACgB,QAAQ,CAAC;MAEpC,IAAID,WAAW,KAAKR,SAAS,EAAE;QAC7BQ,WAAW,GAAGf,YAAY,CAACgB,QAAQ,CAAC,GAAG,IAAIC,GAAG,EAAE;MAClD;MAEA,MAAMC,UAAU,GAAGH,WAAW,CAACI,GAAG,CAACX,MAAM,CAAC;MAE1C,IAAIU,UAAU,KAAKX,SAAS,EAAE;QAC5B,OAAOW,UAAU;MACnB;MAEA,IAAI,CAACZ,IAAI,GAAG,IAAI,CAACD,WAAW,EAAE;IAChC;IAEA,IAAIG,MAAM,CAACI,MAAM,GAAG,CAAC,EAAE;MACrB,IAAI,CAACN,IAAI,CAACG,MAAM,CAACD,MAAM,CAAC;IAC1B;IAEA,MAAMY,YAAY,GAAG,IAAI,CAACd,IAAI,CAACO,MAAM,CAACC,QAAQ,CAAC;IAE/C,IAAIC,WAAW,KAAKR,SAAS,EAAE;MAC7BQ,WAAW,CAACM,GAAG,CAACb,MAAM,EAAEY,YAAY,CAAC;IACvC;IAEA,OAAOA,YAAY;EACrB;AACF;AAEAE,MAAM,CAACC,OAAO,GAAGtB,mBAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}