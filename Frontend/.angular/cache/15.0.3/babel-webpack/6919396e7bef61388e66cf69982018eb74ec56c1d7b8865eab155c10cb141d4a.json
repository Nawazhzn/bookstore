{"ast":null,"code":"import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\nconst SOURCELESS_MAPPING = {\n  source: null,\n  column: null,\n  line: null,\n  name: null,\n  content: null\n};\nconst EMPTY_SOURCES = [];\nfunction Source(map, sources, source, content) {\n  return {\n    map,\n    sources,\n    source,\n    content\n  };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nfunction MapSource(map, sources) {\n  return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nfunction OriginalSource(source, content) {\n  return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nfunction traceMappings(tree) {\n  const gen = new GenMapping({\n    file: tree.map.file\n  });\n  const {\n    sources: rootSources,\n    map\n  } = tree;\n  const rootNames = map.names;\n  const rootMappings = decodedMappings(map);\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n    let lastSource = null;\n    let lastSourceLine = null;\n    let lastSourceColumn = null;\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced = SOURCELESS_MAPPING;\n      // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n      if (segment.length !== 1) {\n        const source = rootSources[segment[1]];\n        traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n        // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n        if (traced == null) continue;\n      }\n      // So we traced a segment down into its original source file. Now push a\n      // new segment pointing to this location.\n      const {\n        column,\n        line,\n        name,\n        content,\n        source\n      } = traced;\n      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n        continue;\n      }\n      lastSourceLine = line;\n      lastSourceColumn = column;\n      lastSource = source;\n      // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n      addSegment(gen, i, genCol, source, line, column, name);\n      if (content != null) setSourceContent(gen, source, content);\n    }\n  }\n  return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nfunction originalPositionFor(source, line, column, name) {\n  if (!source.map) {\n    return {\n      column,\n      line,\n      name,\n      source: source.source,\n      content: source.content\n    };\n  }\n  const segment = traceSegment(source.map, line, column);\n  // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n  if (segment == null) return null;\n  // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n  return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nfunction buildSourceMapTree(input, loader) {\n  const maps = asArray(input).map(m => new TraceMap(m, ''));\n  const map = maps.pop();\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(`Transformation map ${i} must have exactly one source file.\\n` + 'Did you specify these with the most recent transformation maps first?');\n    }\n  }\n  let tree = build(map, loader, '', 0);\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n  return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n  const {\n    resolvedSources,\n    sourcesContent\n  } = map;\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile, i) => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined\n    };\n    // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n    const sourceMap = loader(ctx.source, ctx);\n    const {\n      source,\n      content\n    } = ctx;\n    // If there is a sourcemap, then we need to recurse into it to load its source files.\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);\n    // Else, it's an an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n    const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    return OriginalSource(source, sourceContent);\n  });\n  return MapSource(map, children);\n}\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nclass SourceMap {\n  constructor(map, options) {\n    const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n    this.file = out.file;\n    this.mappings = out.mappings;\n    this.names = out.names;\n    this.sourceRoot = out.sourceRoot;\n    this.sources = out.sources;\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n}\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nfunction remapping(input, loader, options) {\n  const opts = typeof options === 'object' ? options : {\n    excludeContent: !!options,\n    decodedMappings: false\n  };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\nexport { remapping as default };","map":{"version":3,"names":["decodedMappings","traceSegment","TraceMap","GenMapping","addSegment","setSourceContent","decodedMap","encodedMap","SOURCELESS_MAPPING","source","column","line","name","content","EMPTY_SOURCES","Source","map","sources","MapSource","OriginalSource","traceMappings","tree","gen","file","rootSources","rootNames","names","rootMappings","i","length","segments","lastSource","lastSourceLine","lastSourceColumn","j","segment","genCol","traced","originalPositionFor","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","pop","Error","build","importer","importerDepth","resolvedSources","sourcesContent","depth","children","sourceFile","ctx","undefined","sourceMap","sourceContent","SourceMap","constructor","options","out","version","mappings","sourceRoot","excludeContent","toString","JSON","stringify","remapping","opts","default"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@ampproject/remapping/dist/remapping.mjs"],"sourcesContent":["import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\n\nconst SOURCELESS_MAPPING = {\n    source: null,\n    column: null,\n    line: null,\n    name: null,\n    content: null,\n};\nconst EMPTY_SOURCES = [];\nfunction Source(map, sources, source, content) {\n    return {\n        map,\n        sources,\n        source,\n        content,\n    };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nfunction MapSource(map, sources) {\n    return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nfunction OriginalSource(source, content) {\n    return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nfunction traceMappings(tree) {\n    const gen = new GenMapping({ file: tree.map.file });\n    const { sources: rootSources, map } = tree;\n    const rootNames = map.names;\n    const rootMappings = decodedMappings(map);\n    for (let i = 0; i < rootMappings.length; i++) {\n        const segments = rootMappings[i];\n        let lastSource = null;\n        let lastSourceLine = null;\n        let lastSourceColumn = null;\n        for (let j = 0; j < segments.length; j++) {\n            const segment = segments[j];\n            const genCol = segment[0];\n            let traced = SOURCELESS_MAPPING;\n            // 1-length segments only move the current generated column, there's no source information\n            // to gather from it.\n            if (segment.length !== 1) {\n                const source = rootSources[segment[1]];\n                traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n                // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n                // respective segment into an original source.\n                if (traced == null)\n                    continue;\n            }\n            // So we traced a segment down into its original source file. Now push a\n            // new segment pointing to this location.\n            const { column, line, name, content, source } = traced;\n            if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n                continue;\n            }\n            lastSourceLine = line;\n            lastSourceColumn = column;\n            lastSource = source;\n            // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n            addSegment(gen, i, genCol, source, line, column, name);\n            if (content != null)\n                setSourceContent(gen, source, content);\n        }\n    }\n    return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nfunction originalPositionFor(source, line, column, name) {\n    if (!source.map) {\n        return { column, line, name, source: source.source, content: source.content };\n    }\n    const segment = traceSegment(source.map, line, column);\n    // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n    if (segment == null)\n        return null;\n    // 1-length segments only move the current generated column, there's no source information\n    // to gather from it.\n    if (segment.length === 1)\n        return SOURCELESS_MAPPING;\n    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\n\nfunction asArray(value) {\n    if (Array.isArray(value))\n        return value;\n    return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nfunction buildSourceMapTree(input, loader) {\n    const maps = asArray(input).map((m) => new TraceMap(m, ''));\n    const map = maps.pop();\n    for (let i = 0; i < maps.length; i++) {\n        if (maps[i].sources.length > 1) {\n            throw new Error(`Transformation map ${i} must have exactly one source file.\\n` +\n                'Did you specify these with the most recent transformation maps first?');\n        }\n    }\n    let tree = build(map, loader, '', 0);\n    for (let i = maps.length - 1; i >= 0; i--) {\n        tree = MapSource(maps[i], [tree]);\n    }\n    return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n    const { resolvedSources, sourcesContent } = map;\n    const depth = importerDepth + 1;\n    const children = resolvedSources.map((sourceFile, i) => {\n        // The loading context gives the loader more information about why this file is being loaded\n        // (eg, from which importer). It also allows the loader to override the location of the loaded\n        // sourcemap/original source, or to override the content in the sourcesContent field if it's\n        // an unmodified source file.\n        const ctx = {\n            importer,\n            depth,\n            source: sourceFile || '',\n            content: undefined,\n        };\n        // Use the provided loader callback to retrieve the file's sourcemap.\n        // TODO: We should eventually support async loading of sourcemap files.\n        const sourceMap = loader(ctx.source, ctx);\n        const { source, content } = ctx;\n        // If there is a sourcemap, then we need to recurse into it to load its source files.\n        if (sourceMap)\n            return build(new TraceMap(sourceMap, source), loader, source, depth);\n        // Else, it's an an unmodified source file.\n        // The contents of this unmodified source file can be overridden via the loader context,\n        // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n        // the importing sourcemap's `sourcesContent` field.\n        const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n        return OriginalSource(source, sourceContent);\n    });\n    return MapSource(map, children);\n}\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nclass SourceMap {\n    constructor(map, options) {\n        const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n        this.version = out.version; // SourceMap spec says this should be first.\n        this.file = out.file;\n        this.mappings = out.mappings;\n        this.names = out.names;\n        this.sourceRoot = out.sourceRoot;\n        this.sources = out.sources;\n        if (!options.excludeContent) {\n            this.sourcesContent = out.sourcesContent;\n        }\n    }\n    toString() {\n        return JSON.stringify(this);\n    }\n}\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nfunction remapping(input, loader, options) {\n    const opts = typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n    const tree = buildSourceMapTree(input, loader);\n    return new SourceMap(traceMappings(tree), opts);\n}\n\nexport { remapping as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}