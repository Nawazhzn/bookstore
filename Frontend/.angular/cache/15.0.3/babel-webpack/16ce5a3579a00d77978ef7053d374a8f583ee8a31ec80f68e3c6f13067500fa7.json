{"ast":null,"code":"const {\n  createHash\n} = require('crypto');\nconst {\n  template\n} = require('@babel/core');\nconst {\n  defaults\n} = require('@istanbuljs/schema');\nconst {\n  SourceCoverage\n} = require('./source-coverage');\nconst {\n  SHA,\n  MAGIC_KEY,\n  MAGIC_VALUE\n} = require('./constants');\n\n// pattern for istanbul to ignore a section\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/;\n// pattern for istanbul to ignore the whole file\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/;\n// source map URL pattern\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m;\n\n// generate a variable name from hashing the supplied file path\nfunction genVar(filename) {\n  const hash = createHash(SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n}\n\n// VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = [], reportLogic = false) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new SourceCoverage(sourceFilePath);\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n    this.reportLogic = reportLogic;\n  }\n\n  // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  }\n\n  // extract the ignore comment hint (next|if|else) or null\n  hintFor(node) {\n    let hint = null;\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value || /* istanbul ignore next: paranoid check */'').trim();\n        const groups = v.match(COMMENT_RE);\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n    return hint;\n  }\n\n  // extract a source map URL from comments and keep track of it\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n      comments.forEach(c => {\n        const v = (c.value || /* istanbul ignore next: paranoid check */'').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  }\n\n  // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  }\n\n  // all the generic stuff that needs to be done on enter for every node\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n);\n\n    // if already ignoring, nothing more to do\n    if (this.nextIgnore !== null) {\n      return;\n    }\n    // check hint to see if ignore should be turned on\n    const hint = this.hintFor(n);\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    }\n    // else check custom node attribute set by a prior visitor\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    }\n\n    // else check for ignored class methods\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  }\n\n  // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    }\n    // nuke all attributes for the node\n    delete path.node.__cov__;\n  }\n\n  // set a node attribute for the supplied node\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  }\n\n  // retrieve a node attribute for the supplied node or null\n  getAttr(node, name) {\n    const c = node.__cov__;\n    if (!c) {\n      return null;\n    }\n    return c[name];\n  }\n\n  //\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ?\n    // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  // Reads the logic expression conditions and conditionally increments truthy counter.\n  increaseTrue(type, id, index, node) {\n    const T = this.types;\n    const tempName = `${this.varName}_temp`;\n    return T.sequenceExpression([T.assignmentExpression('=', T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName)), node // Only evaluates once.\n    ), T.parenthesizedExpression(T.conditionalExpression(this.validateTrueNonTrivial(T, tempName), this.increase(type, id, index), T.nullLiteral())), T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))]);\n  }\n  validateTrueNonTrivial(T, tempName) {\n    return T.logicalExpression('&&', T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName)), T.logicalExpression('&&', T.parenthesizedExpression(T.logicalExpression('||', T.unaryExpression('!', T.callExpression(T.memberExpression(T.identifier('Array'), T.identifier('isArray')), [T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))])), T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName)), T.identifier('length')))), T.parenthesizedExpression(T.logicalExpression('||', T.binaryExpression('!==', T.callExpression(T.memberExpression(T.identifier('Object'), T.identifier('getPrototypeOf')), [T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))]), T.memberExpression(T.identifier('Object'), T.identifier('prototype'))), T.memberExpression(T.callExpression(T.memberExpression(T.identifier('Object'), T.identifier('values')), [T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))]), T.identifier('length'))))));\n  }\n  insertCounter(path, increment) {\n    const T = this.types;\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    } /* istanbul ignore else: not expected */else if (path.isExpression()) {\n      path.replaceWith(T.sequenceExpression([increment, path.node]));\n    } else {\n      console.error('Unable to insert counter for node type:', path.node.type);\n    }\n  }\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n    const n = path.node;\n    let dloc = null;\n    // get location for declaration\n    switch (n.type) {\n      case 'FunctionDeclaration':\n      case 'FunctionExpression':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n        break;\n    }\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n  getBranchLogicIncrement(path, branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return [this.increase('b', branchName, index), this.increaseTrue('bT', branchName, index, path.node)];\n  }\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n}\n\n// generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function (path, node) {\n    this.onEnter(path);\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n  const exit = function (path, node) {\n    this.onExit(path, node);\n  };\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n\n/* istanbul ignore next: no node.js support */\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\nfunction makeBlock(path) {\n  const T = this.types;\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n    path.node.body[0].leadingComments = path.node.leadingComments;\n    path.node.leadingComments = undefined;\n  }\n}\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n    if (n.expression === true) {\n      n.expression = false;\n    }\n    n.body = T.blockStatement([T.returnStatement(n.body)]);\n    // restore body location\n    n.body.loc = bloc;\n    // set up the location for the return statement so it gets\n    // instrumented\n    n.body.body[0].loc = bloc;\n  }\n}\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc, this.reportLogic);\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n    if (hint === 'next') {\n      continue;\n    }\n    if (this.reportLogic) {\n      const increment = this.getBranchLogicIncrement(leaf, b, leaf.node.loc);\n      if (!increment[0]) {\n        continue;\n      }\n      leaf.parent[leaf.property] = T.sequenceExpression([increment[0], increment[1]]);\n      continue;\n    }\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n    if (!increment) {\n      continue;\n    }\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = template(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = template(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = template(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`);\n// the template to insert at the top of the program.\nconst coverageTemplate = template(`\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`, {\n  preserveComments: true\n});\n// the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types.\n * @param {string} sourceFilePath - the path to source file.\n * @param {Object} opts - additional options.\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = {}) {\n  const T = types;\n  opts = {\n    ...defaults.instrumentVisitor,\n    ...opts\n  };\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods, opts.reportLogic);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n      path.traverse(codeVisitor, visitState);\n    },\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n      coverageData[MAGIC_KEY] = MAGIC_VALUE;\n      const hash = createHash(SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      if (coverageData.inputSourceMap && Object.getPrototypeOf(coverageData.inputSourceMap) !== Object.prototype) {\n        coverageData.inputSourceMap = {\n          ...coverageData.inputSourceMap\n        };\n      }\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_FUNCTION: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      });\n      // explicitly call this.varName to ensure coverage is always initialized\n      path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitState.varName), [])));\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n  };\n}\nmodule.exports = programVisitor;","map":{"version":3,"names":["createHash","require","template","defaults","SourceCoverage","SHA","MAGIC_KEY","MAGIC_VALUE","COMMENT_RE","COMMENT_FILE_RE","SOURCE_MAP_RE","genVar","filename","hash","update","parseInt","digest","substr","toString","VisitState","constructor","types","sourceFilePath","inputSourceMap","ignoreClassMethods","reportLogic","varName","attrs","nextIgnore","cov","sourceMappingURL","shouldIgnore","path","node","loc","hintFor","hint","leadingComments","forEach","c","v","value","trim","groups","match","maybeAssignSourceMapURL","extractURL","comments","trailingComments","counterNeedsHoisting","isFunctionExpression","isArrowFunctionExpression","isClassExpression","onEnter","n","getAttr","some","name","id","isClassMethod","key","onExit","__cov__","setAttr","increase","type","index","T","wrap","x","memberExpression","numericLiteral","updateExpression","callExpression","identifier","increaseTrue","tempName","sequenceExpression","assignmentExpression","parenthesizedExpression","conditionalExpression","validateTrueNonTrivial","nullLiteral","logicalExpression","unaryExpression","binaryExpression","insertCounter","increment","isBlockStatement","body","unshift","expressionStatement","isStatement","insertBefore","isVariableDeclarator","parentPath","parent","isExportNamedDeclaration","isProgram","replaceWith","isExpression","console","error","insertStatementCounter","newStatement","insertFunctionCounter","dloc","start","end","line","column","newFunction","get","getBranchIncrement","branchName","addBranchPath","getBranchLogicIncrement","insertBranchCounter","findLeaves","accumulator","property","left","right","push","entries","enter","wrappedEntry","e","call","exit","coverStatement","coverAssignmentPattern","b","newBranch","coverFunction","coverVariableDeclarator","coverClassPropDeclarator","makeBlock","blockStatement","undefined","blockProp","prop","makeParenthesizedExpressionForNonIdentifier","isIdentifier","parenthesizedExpressionProp","convertArrowExpression","bloc","expression","returnStatement","coverIfBranches","ignoreIf","ignoreElse","branch","consequent","alternate","createSwitchBranch","coverSwitchCase","Error","coverTernary","cHint","aHint","coverLogicalExpression","leaves","i","length","leaf","codeVisitor","ArrowFunctionExpression","AssignmentPattern","BlockStatement","ExportDefaultDeclaration","ExportNamedDeclaration","ClassMethod","ClassDeclaration","ClassProperty","ClassPrivateProperty","ObjectMethod","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","ReturnStatement","ThrowStatement","TryStatement","VariableDeclaration","VariableDeclarator","IfStatement","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","SwitchStatement","SwitchCase","WithStatement","FunctionDeclaration","FunctionExpression","LabeledStatement","ConditionalExpression","LogicalExpression","globalTemplateAlteredFunction","globalTemplateFunction","globalTemplateVariable","coverageTemplate","preserveComments","alreadyInstrumented","visitState","scope","hasBinding","shouldIgnoreFile","programNode","test","programVisitor","opts","instrumentVisitor","find","p","traverse","freeze","coverageData","toJSON","fileCoverage","JSON","stringify","Object","getPrototypeOf","prototype","coverageNode","valueToNode","gvTemplate","coverageGlobalScopeFunc","getBinding","GLOBAL_COVERAGE_SCOPE","stringLiteral","coverageGlobalScope","cv","GLOBAL_COVERAGE_VAR","coverageVariable","GLOBAL_COVERAGE_TEMPLATE","COVERAGE_FUNCTION","PATH","INITIAL","HASH","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/istanbul-lib-instrument/src/visitor.js"],"sourcesContent":["const { createHash } = require('crypto');\nconst { template } = require('@babel/core');\nconst { defaults } = require('@istanbuljs/schema');\nconst { SourceCoverage } = require('./source-coverage');\nconst { SHA, MAGIC_KEY, MAGIC_VALUE } = require('./constants');\n\n// pattern for istanbul to ignore a section\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/;\n// pattern for istanbul to ignore the whole file\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/;\n// source map URL pattern\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m;\n\n// generate a variable name from hashing the supplied file path\nfunction genVar(filename) {\n    const hash = createHash(SHA);\n    hash.update(filename);\n    return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n}\n\n// VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\nclass VisitState {\n    constructor(\n        types,\n        sourceFilePath,\n        inputSourceMap,\n        ignoreClassMethods = [],\n        reportLogic = false\n    ) {\n        this.varName = genVar(sourceFilePath);\n        this.attrs = {};\n        this.nextIgnore = null;\n        this.cov = new SourceCoverage(sourceFilePath);\n\n        if (typeof inputSourceMap !== 'undefined') {\n            this.cov.inputSourceMap(inputSourceMap);\n        }\n        this.ignoreClassMethods = ignoreClassMethods;\n        this.types = types;\n        this.sourceMappingURL = null;\n        this.reportLogic = reportLogic;\n    }\n\n    // should we ignore the node? Yes, if specifically ignoring\n    // or if the node is generated.\n    shouldIgnore(path) {\n        return this.nextIgnore || !path.node.loc;\n    }\n\n    // extract the ignore comment hint (next|if|else) or null\n    hintFor(node) {\n        let hint = null;\n        if (node.leadingComments) {\n            node.leadingComments.forEach(c => {\n                const v = (\n                    c.value || /* istanbul ignore next: paranoid check */ ''\n                ).trim();\n                const groups = v.match(COMMENT_RE);\n                if (groups) {\n                    hint = groups[1];\n                }\n            });\n        }\n        return hint;\n    }\n\n    // extract a source map URL from comments and keep track of it\n    maybeAssignSourceMapURL(node) {\n        const extractURL = comments => {\n            if (!comments) {\n                return;\n            }\n            comments.forEach(c => {\n                const v = (\n                    c.value || /* istanbul ignore next: paranoid check */ ''\n                ).trim();\n                const groups = v.match(SOURCE_MAP_RE);\n                if (groups) {\n                    this.sourceMappingURL = groups[1];\n                }\n            });\n        };\n        extractURL(node.leadingComments);\n        extractURL(node.trailingComments);\n    }\n\n    // for these expressions the statement counter needs to be hoisted, so\n    // function name inference can be preserved\n    counterNeedsHoisting(path) {\n        return (\n            path.isFunctionExpression() ||\n            path.isArrowFunctionExpression() ||\n            path.isClassExpression()\n        );\n    }\n\n    // all the generic stuff that needs to be done on enter for every node\n    onEnter(path) {\n        const n = path.node;\n\n        this.maybeAssignSourceMapURL(n);\n\n        // if already ignoring, nothing more to do\n        if (this.nextIgnore !== null) {\n            return;\n        }\n        // check hint to see if ignore should be turned on\n        const hint = this.hintFor(n);\n        if (hint === 'next') {\n            this.nextIgnore = n;\n            return;\n        }\n        // else check custom node attribute set by a prior visitor\n        if (this.getAttr(path.node, 'skip-all') !== null) {\n            this.nextIgnore = n;\n        }\n\n        // else check for ignored class methods\n        if (\n            path.isFunctionExpression() &&\n            this.ignoreClassMethods.some(\n                name => path.node.id && name === path.node.id.name\n            )\n        ) {\n            this.nextIgnore = n;\n            return;\n        }\n        if (\n            path.isClassMethod() &&\n            this.ignoreClassMethods.some(name => name === path.node.key.name)\n        ) {\n            this.nextIgnore = n;\n            return;\n        }\n    }\n\n    // all the generic stuff on exit of a node,\n    // including reseting ignores and custom node attrs\n    onExit(path) {\n        // restore ignore status, if needed\n        if (path.node === this.nextIgnore) {\n            this.nextIgnore = null;\n        }\n        // nuke all attributes for the node\n        delete path.node.__cov__;\n    }\n\n    // set a node attribute for the supplied node\n    setAttr(node, name, value) {\n        node.__cov__ = node.__cov__ || {};\n        node.__cov__[name] = value;\n    }\n\n    // retrieve a node attribute for the supplied node or null\n    getAttr(node, name) {\n        const c = node.__cov__;\n        if (!c) {\n            return null;\n        }\n        return c[name];\n    }\n\n    //\n    increase(type, id, index) {\n        const T = this.types;\n        const wrap =\n            index !== null\n                ? // If `index` present, turn `x` into `x[index]`.\n                  x => T.memberExpression(x, T.numericLiteral(index), true)\n                : x => x;\n        return T.updateExpression(\n            '++',\n            wrap(\n                T.memberExpression(\n                    T.memberExpression(\n                        T.callExpression(T.identifier(this.varName), []),\n                        T.identifier(type)\n                    ),\n                    T.numericLiteral(id),\n                    true\n                )\n            )\n        );\n    }\n\n    // Reads the logic expression conditions and conditionally increments truthy counter.\n    increaseTrue(type, id, index, node) {\n        const T = this.types;\n        const tempName = `${this.varName}_temp`;\n\n        return T.sequenceExpression([\n            T.assignmentExpression(\n                '=',\n                T.memberExpression(\n                    T.callExpression(T.identifier(this.varName), []),\n                    T.identifier(tempName)\n                ),\n                node // Only evaluates once.\n            ),\n            T.parenthesizedExpression(\n                T.conditionalExpression(\n                    this.validateTrueNonTrivial(T, tempName),\n                    this.increase(type, id, index),\n                    T.nullLiteral()\n                )\n            ),\n            T.memberExpression(\n                T.callExpression(T.identifier(this.varName), []),\n                T.identifier(tempName)\n            )\n        ]);\n    }\n\n    validateTrueNonTrivial(T, tempName) {\n        return T.logicalExpression(\n            '&&',\n            T.memberExpression(\n                T.callExpression(T.identifier(this.varName), []),\n                T.identifier(tempName)\n            ),\n            T.logicalExpression(\n                '&&',\n                T.parenthesizedExpression(\n                    T.logicalExpression(\n                        '||',\n                        T.unaryExpression(\n                            '!',\n                            T.callExpression(\n                                T.memberExpression(\n                                    T.identifier('Array'),\n                                    T.identifier('isArray')\n                                ),\n                                [\n                                    T.memberExpression(\n                                        T.callExpression(\n                                            T.identifier(this.varName),\n                                            []\n                                        ),\n                                        T.identifier(tempName)\n                                    )\n                                ]\n                            )\n                        ),\n                        T.memberExpression(\n                            T.memberExpression(\n                                T.callExpression(\n                                    T.identifier(this.varName),\n                                    []\n                                ),\n                                T.identifier(tempName)\n                            ),\n                            T.identifier('length')\n                        )\n                    )\n                ),\n                T.parenthesizedExpression(\n                    T.logicalExpression(\n                        '||',\n                        T.binaryExpression(\n                            '!==',\n                            T.callExpression(\n                                T.memberExpression(\n                                    T.identifier('Object'),\n                                    T.identifier('getPrototypeOf')\n                                ),\n                                [\n                                    T.memberExpression(\n                                        T.callExpression(\n                                            T.identifier(this.varName),\n                                            []\n                                        ),\n                                        T.identifier(tempName)\n                                    )\n                                ]\n                            ),\n                            T.memberExpression(\n                                T.identifier('Object'),\n                                T.identifier('prototype')\n                            )\n                        ),\n                        T.memberExpression(\n                            T.callExpression(\n                                T.memberExpression(\n                                    T.identifier('Object'),\n                                    T.identifier('values')\n                                ),\n                                [\n                                    T.memberExpression(\n                                        T.callExpression(\n                                            T.identifier(this.varName),\n                                            []\n                                        ),\n                                        T.identifier(tempName)\n                                    )\n                                ]\n                            ),\n                            T.identifier('length')\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    insertCounter(path, increment) {\n        const T = this.types;\n        if (path.isBlockStatement()) {\n            path.node.body.unshift(T.expressionStatement(increment));\n        } else if (path.isStatement()) {\n            path.insertBefore(T.expressionStatement(increment));\n        } else if (\n            this.counterNeedsHoisting(path) &&\n            T.isVariableDeclarator(path.parentPath)\n        ) {\n            // make an attempt to hoist the statement counter, so that\n            // function names are maintained.\n            const parent = path.parentPath.parentPath;\n            if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n                parent.parentPath.insertBefore(\n                    T.expressionStatement(increment)\n                );\n            } else if (\n                parent &&\n                (T.isProgram(parent.parentPath) ||\n                    T.isBlockStatement(parent.parentPath))\n            ) {\n                parent.insertBefore(T.expressionStatement(increment));\n            } else {\n                path.replaceWith(T.sequenceExpression([increment, path.node]));\n            }\n        } /* istanbul ignore else: not expected */ else if (\n            path.isExpression()\n        ) {\n            path.replaceWith(T.sequenceExpression([increment, path.node]));\n        } else {\n            console.error(\n                'Unable to insert counter for node type:',\n                path.node.type\n            );\n        }\n    }\n\n    insertStatementCounter(path) {\n        /* istanbul ignore if: paranoid check */\n        if (!(path.node && path.node.loc)) {\n            return;\n        }\n        const index = this.cov.newStatement(path.node.loc);\n        const increment = this.increase('s', index, null);\n        this.insertCounter(path, increment);\n    }\n\n    insertFunctionCounter(path) {\n        const T = this.types;\n        /* istanbul ignore if: paranoid check */\n        if (!(path.node && path.node.loc)) {\n            return;\n        }\n        const n = path.node;\n\n        let dloc = null;\n        // get location for declaration\n        switch (n.type) {\n            case 'FunctionDeclaration':\n            case 'FunctionExpression':\n                /* istanbul ignore else: paranoid check */\n                if (n.id) {\n                    dloc = n.id.loc;\n                }\n                break;\n        }\n        if (!dloc) {\n            dloc = {\n                start: n.loc.start,\n                end: { line: n.loc.start.line, column: n.loc.start.column + 1 }\n            };\n        }\n\n        const name = path.node.id ? path.node.id.name : path.node.name;\n        const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n        const increment = this.increase('f', index, null);\n        const body = path.get('body');\n        /* istanbul ignore else: not expected */\n        if (body.isBlockStatement()) {\n            body.node.body.unshift(T.expressionStatement(increment));\n        } else {\n            console.error(\n                'Unable to process function body node type:',\n                path.node.type\n            );\n        }\n    }\n\n    getBranchIncrement(branchName, loc) {\n        const index = this.cov.addBranchPath(branchName, loc);\n        return this.increase('b', branchName, index);\n    }\n\n    getBranchLogicIncrement(path, branchName, loc) {\n        const index = this.cov.addBranchPath(branchName, loc);\n        return [\n            this.increase('b', branchName, index),\n            this.increaseTrue('bT', branchName, index, path.node)\n        ];\n    }\n\n    insertBranchCounter(path, branchName, loc) {\n        const increment = this.getBranchIncrement(\n            branchName,\n            loc || path.node.loc\n        );\n        this.insertCounter(path, increment);\n    }\n\n    findLeaves(node, accumulator, parent, property) {\n        if (!node) {\n            return;\n        }\n        if (node.type === 'LogicalExpression') {\n            const hint = this.hintFor(node);\n            if (hint !== 'next') {\n                this.findLeaves(node.left, accumulator, node, 'left');\n                this.findLeaves(node.right, accumulator, node, 'right');\n            }\n        } else {\n            accumulator.push({\n                node,\n                parent,\n                property\n            });\n        }\n    }\n}\n\n// generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\nfunction entries(...enter) {\n    // the enter function\n    const wrappedEntry = function(path, node) {\n        this.onEnter(path);\n        if (this.shouldIgnore(path)) {\n            return;\n        }\n        enter.forEach(e => {\n            e.call(this, path, node);\n        });\n    };\n    const exit = function(path, node) {\n        this.onExit(path, node);\n    };\n    return {\n        enter: wrappedEntry,\n        exit\n    };\n}\n\nfunction coverStatement(path) {\n    this.insertStatementCounter(path);\n}\n\n/* istanbul ignore next: no node.js support */\nfunction coverAssignmentPattern(path) {\n    const n = path.node;\n    const b = this.cov.newBranch('default-arg', n.loc);\n    this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n    this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n    this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n    this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n    const T = this.types;\n    if (!path.node) {\n        path.replaceWith(T.blockStatement([]));\n    }\n    if (!path.isBlockStatement()) {\n        path.replaceWith(T.blockStatement([path.node]));\n        path.node.loc = path.node.body[0].loc;\n        path.node.body[0].leadingComments = path.node.leadingComments;\n        path.node.leadingComments = undefined;\n    }\n}\n\nfunction blockProp(prop) {\n    return function(path) {\n        makeBlock.call(this, path.get(prop));\n    };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n    const T = this.types;\n    if (path.node && !path.isIdentifier()) {\n        path.replaceWith(T.parenthesizedExpression(path.node));\n    }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n    return function(path) {\n        makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n    };\n}\n\nfunction convertArrowExpression(path) {\n    const n = path.node;\n    const T = this.types;\n    if (!T.isBlockStatement(n.body)) {\n        const bloc = n.body.loc;\n        if (n.expression === true) {\n            n.expression = false;\n        }\n        n.body = T.blockStatement([T.returnStatement(n.body)]);\n        // restore body location\n        n.body.loc = bloc;\n        // set up the location for the return statement so it gets\n        // instrumented\n        n.body.body[0].loc = bloc;\n    }\n}\n\nfunction coverIfBranches(path) {\n    const n = path.node;\n    const hint = this.hintFor(n);\n    const ignoreIf = hint === 'if';\n    const ignoreElse = hint === 'else';\n    const branch = this.cov.newBranch('if', n.loc);\n\n    if (ignoreIf) {\n        this.setAttr(n.consequent, 'skip-all', true);\n    } else {\n        this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n    }\n    if (ignoreElse) {\n        this.setAttr(n.alternate, 'skip-all', true);\n    } else {\n        this.insertBranchCounter(path.get('alternate'), branch);\n    }\n}\n\nfunction createSwitchBranch(path) {\n    const b = this.cov.newBranch('switch', path.node.loc);\n    this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n    const T = this.types;\n    const b = this.getAttr(path.parentPath.node, 'branchName');\n    /* istanbul ignore if: paranoid check */\n    if (b === null) {\n        throw new Error('Unable to get switch branch name');\n    }\n    const increment = this.getBranchIncrement(b, path.node.loc);\n    path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n    const n = path.node;\n    const branch = this.cov.newBranch('cond-expr', path.node.loc);\n    const cHint = this.hintFor(n.consequent);\n    const aHint = this.hintFor(n.alternate);\n\n    if (cHint !== 'next') {\n        this.insertBranchCounter(path.get('consequent'), branch);\n    }\n    if (aHint !== 'next') {\n        this.insertBranchCounter(path.get('alternate'), branch);\n    }\n}\n\nfunction coverLogicalExpression(path) {\n    const T = this.types;\n    if (path.parentPath.node.type === 'LogicalExpression') {\n        return; // already processed\n    }\n    const leaves = [];\n    this.findLeaves(path.node, leaves);\n    const b = this.cov.newBranch(\n        'binary-expr',\n        path.node.loc,\n        this.reportLogic\n    );\n    for (let i = 0; i < leaves.length; i += 1) {\n        const leaf = leaves[i];\n        const hint = this.hintFor(leaf.node);\n        if (hint === 'next') {\n            continue;\n        }\n\n        if (this.reportLogic) {\n            const increment = this.getBranchLogicIncrement(\n                leaf,\n                b,\n                leaf.node.loc\n            );\n            if (!increment[0]) {\n                continue;\n            }\n            leaf.parent[leaf.property] = T.sequenceExpression([\n                increment[0],\n                increment[1]\n            ]);\n            continue;\n        }\n\n        const increment = this.getBranchIncrement(b, leaf.node.loc);\n        if (!increment) {\n            continue;\n        }\n        leaf.parent[leaf.property] = T.sequenceExpression([\n            increment,\n            leaf.node\n        ]);\n    }\n}\n\nconst codeVisitor = {\n    ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n    AssignmentPattern: entries(coverAssignmentPattern),\n    BlockStatement: entries(), // ignore processing only\n    ExportDefaultDeclaration: entries(), // ignore processing only\n    ExportNamedDeclaration: entries(), // ignore processing only\n    ClassMethod: entries(coverFunction),\n    ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n    ClassProperty: entries(coverClassPropDeclarator),\n    ClassPrivateProperty: entries(coverClassPropDeclarator),\n    ObjectMethod: entries(coverFunction),\n    ExpressionStatement: entries(coverStatement),\n    BreakStatement: entries(coverStatement),\n    ContinueStatement: entries(coverStatement),\n    DebuggerStatement: entries(coverStatement),\n    ReturnStatement: entries(coverStatement),\n    ThrowStatement: entries(coverStatement),\n    TryStatement: entries(coverStatement),\n    VariableDeclaration: entries(), // ignore processing only\n    VariableDeclarator: entries(coverVariableDeclarator),\n    IfStatement: entries(\n        blockProp('consequent'),\n        blockProp('alternate'),\n        coverStatement,\n        coverIfBranches\n    ),\n    ForStatement: entries(blockProp('body'), coverStatement),\n    ForInStatement: entries(blockProp('body'), coverStatement),\n    ForOfStatement: entries(blockProp('body'), coverStatement),\n    WhileStatement: entries(blockProp('body'), coverStatement),\n    DoWhileStatement: entries(blockProp('body'), coverStatement),\n    SwitchStatement: entries(createSwitchBranch, coverStatement),\n    SwitchCase: entries(coverSwitchCase),\n    WithStatement: entries(blockProp('body'), coverStatement),\n    FunctionDeclaration: entries(coverFunction),\n    FunctionExpression: entries(coverFunction),\n    LabeledStatement: entries(coverStatement),\n    ConditionalExpression: entries(coverTernary),\n    LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = template(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = template(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = template(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`);\n// the template to insert at the top of the program.\nconst coverageTemplate = template(\n    `\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`,\n    { preserveComments: true }\n);\n// the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\nfunction alreadyInstrumented(path, visitState) {\n    return path.scope.hasBinding(visitState.varName);\n}\nfunction shouldIgnoreFile(programNode) {\n    return (\n        programNode.parent &&\n        programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value))\n    );\n}\n\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types.\n * @param {string} sourceFilePath - the path to source file.\n * @param {Object} opts - additional options.\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = {}) {\n    const T = types;\n    opts = {\n        ...defaults.instrumentVisitor,\n        ...opts\n    };\n    const visitState = new VisitState(\n        types,\n        sourceFilePath,\n        opts.inputSourceMap,\n        opts.ignoreClassMethods,\n        opts.reportLogic\n    );\n    return {\n        enter(path) {\n            if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n                return;\n            }\n            if (alreadyInstrumented(path, visitState)) {\n                return;\n            }\n            path.traverse(codeVisitor, visitState);\n        },\n        exit(path) {\n            if (alreadyInstrumented(path, visitState)) {\n                return;\n            }\n            visitState.cov.freeze();\n            const coverageData = visitState.cov.toJSON();\n            if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n                return {\n                    fileCoverage: coverageData,\n                    sourceMappingURL: visitState.sourceMappingURL\n                };\n            }\n            coverageData[MAGIC_KEY] = MAGIC_VALUE;\n            const hash = createHash(SHA)\n                .update(JSON.stringify(coverageData))\n                .digest('hex');\n            coverageData.hash = hash;\n            if (\n                coverageData.inputSourceMap &&\n                Object.getPrototypeOf(coverageData.inputSourceMap) !==\n                    Object.prototype\n            ) {\n                coverageData.inputSourceMap = {\n                    ...coverageData.inputSourceMap\n                };\n            }\n            const coverageNode = T.valueToNode(coverageData);\n            delete coverageData[MAGIC_KEY];\n            delete coverageData.hash;\n            let gvTemplate;\n            if (opts.coverageGlobalScopeFunc) {\n                if (path.scope.getBinding('Function')) {\n                    gvTemplate = globalTemplateAlteredFunction({\n                        GLOBAL_COVERAGE_SCOPE: T.stringLiteral(\n                            'return ' + opts.coverageGlobalScope\n                        )\n                    });\n                } else {\n                    gvTemplate = globalTemplateFunction({\n                        GLOBAL_COVERAGE_SCOPE: T.stringLiteral(\n                            'return ' + opts.coverageGlobalScope\n                        )\n                    });\n                }\n            } else {\n                gvTemplate = globalTemplateVariable({\n                    GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n                });\n            }\n            const cv = coverageTemplate({\n                GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n                GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n                COVERAGE_FUNCTION: T.identifier(visitState.varName),\n                PATH: T.stringLiteral(sourceFilePath),\n                INITIAL: coverageNode,\n                HASH: T.stringLiteral(hash)\n            });\n            // explicitly call this.varName to ensure coverage is always initialized\n            path.node.body.unshift(\n                T.expressionStatement(\n                    T.callExpression(T.identifier(visitState.varName), [])\n                )\n            );\n            path.node.body.unshift(cv);\n            return {\n                fileCoverage: coverageData,\n                sourceMappingURL: visitState.sourceMappingURL\n            };\n        }\n    };\n}\n\nmodule.exports = programVisitor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}