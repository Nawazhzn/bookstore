{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getKeywords = void 0;\nconst core_1 = require(\"@babel/core\");\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\nfunction getKeywords() {\n  return ['var'];\n}\nexports.getKeywords = getKeywords;\n/**\n * A babel plugin factory function for adjusting TypeScript emitted enums.\n *\n * @returns A babel plugin object instance.\n */\nfunction default_1() {\n  return {\n    visitor: {\n      VariableDeclaration(path, state) {\n        const {\n          parentPath,\n          node\n        } = path;\n        const {\n          loose\n        } = state.opts;\n        if (node.kind !== 'var' || node.declarations.length !== 1) {\n          return;\n        }\n        const declaration = path.get('declarations')[0];\n        if (declaration.node.init) {\n          return;\n        }\n        const declarationId = declaration.node.id;\n        if (!core_1.types.isIdentifier(declarationId)) {\n          return;\n        }\n        const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n        const origin = hasExport ? parentPath : path;\n        const nextStatement = origin.getSibling(+origin.key + 1);\n        if (!nextStatement.isExpressionStatement()) {\n          return;\n        }\n        const nextExpression = nextStatement.get('expression');\n        if (!nextExpression.isCallExpression() || nextExpression.node.arguments.length !== 1) {\n          return;\n        }\n        const enumCallArgument = nextExpression.node.arguments[0];\n        if (!core_1.types.isLogicalExpression(enumCallArgument, {\n          operator: '||'\n        })) {\n          return;\n        }\n        // Check if identifiers match var declaration\n        if (!core_1.types.isIdentifier(enumCallArgument.left) || !nextExpression.scope.bindingIdentifierEquals(enumCallArgument.left.name, declarationId)) {\n          return;\n        }\n        const enumCallee = nextExpression.get('callee');\n        if (!enumCallee.isFunctionExpression() || enumCallee.node.params.length !== 1) {\n          return;\n        }\n        const enumCalleeParam = enumCallee.node.params[0];\n        const isEnumCalleeMatching = core_1.types.isIdentifier(enumCalleeParam) && enumCalleeParam.name === declarationId.name;\n        // Loose mode rewrites the enum to a shorter but less TypeScript-like form\n        // Note: We only can apply the `loose` mode transformation if the callee parameter matches\n        // with the declaration identifier name. This is necessary in case the the declaration id has\n        // been renamed to avoid collisions, as the loose transform would then break the enum assignments\n        // which rely on the differently-named callee identifier name.\n        let enumAssignments;\n        if (loose && isEnumCalleeMatching) {\n          enumAssignments = [];\n        }\n        // Check if all enum member values are pure.\n        // If not, leave as-is due to potential side efects\n        let hasElements = false;\n        for (const enumStatement of enumCallee.get('body').get('body')) {\n          if (!enumStatement.isExpressionStatement()) {\n            return;\n          }\n          const enumValueAssignment = enumStatement.get('expression');\n          if (!enumValueAssignment.isAssignmentExpression() || !enumValueAssignment.get('right').isPure()) {\n            return;\n          }\n          hasElements = true;\n          enumAssignments === null || enumAssignments === void 0 ? void 0 : enumAssignments.push(enumStatement.node);\n        }\n        // If there are no enum elements then there is nothing to wrap\n        if (!hasElements) {\n          return;\n        }\n        // Remove existing enum initializer\n        const enumInitializer = nextExpression.node;\n        nextExpression.remove();\n        // Create IIFE block contents\n        let blockContents;\n        if (enumAssignments) {\n          // Loose mode\n          blockContents = [core_1.types.expressionStatement(core_1.types.assignmentExpression('=', core_1.types.cloneNode(declarationId), core_1.types.logicalExpression('||', core_1.types.cloneNode(declarationId), core_1.types.objectExpression([])))), ...enumAssignments];\n        } else {\n          blockContents = [core_1.types.expressionStatement(enumInitializer)];\n        }\n        // Wrap existing enum initializer in a pure annotated IIFE\n        const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([...blockContents, core_1.types.returnStatement(core_1.types.cloneNode(declarationId))]));\n        const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n        (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n        // Add the wrapped enum initializer directly to the variable declaration\n        declaration.get('init').replaceWith(replacementInitializer);\n      }\n    }\n  };\n}\nexports.default = default_1;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getKeywords","core_1","require","helper_annotate_as_pure_1","default_1","visitor","VariableDeclaration","path","state","parentPath","node","loose","opts","kind","declarations","length","declaration","get","init","declarationId","id","types","isIdentifier","hasExport","isExportNamedDeclaration","isExportDefaultDeclaration","origin","nextStatement","getSibling","key","isExpressionStatement","nextExpression","isCallExpression","arguments","enumCallArgument","isLogicalExpression","operator","left","scope","bindingIdentifierEquals","name","enumCallee","isFunctionExpression","params","enumCalleeParam","isEnumCalleeMatching","enumAssignments","hasElements","enumStatement","enumValueAssignment","isAssignmentExpression","isPure","push","enumInitializer","remove","blockContents","expressionStatement","assignmentExpression","cloneNode","logicalExpression","objectExpression","container","arrowFunctionExpression","blockStatement","returnStatement","replacementInitializer","callExpression","parenthesizedExpression","default","replaceWith"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@angular-devkit/build-angular/src/babel/plugins/adjust-typescript-enums.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getKeywords = void 0;\nconst core_1 = require(\"@babel/core\");\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\nfunction getKeywords() {\n    return ['var'];\n}\nexports.getKeywords = getKeywords;\n/**\n * A babel plugin factory function for adjusting TypeScript emitted enums.\n *\n * @returns A babel plugin object instance.\n */\nfunction default_1() {\n    return {\n        visitor: {\n            VariableDeclaration(path, state) {\n                const { parentPath, node } = path;\n                const { loose } = state.opts;\n                if (node.kind !== 'var' || node.declarations.length !== 1) {\n                    return;\n                }\n                const declaration = path.get('declarations')[0];\n                if (declaration.node.init) {\n                    return;\n                }\n                const declarationId = declaration.node.id;\n                if (!core_1.types.isIdentifier(declarationId)) {\n                    return;\n                }\n                const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n                const origin = hasExport ? parentPath : path;\n                const nextStatement = origin.getSibling(+origin.key + 1);\n                if (!nextStatement.isExpressionStatement()) {\n                    return;\n                }\n                const nextExpression = nextStatement.get('expression');\n                if (!nextExpression.isCallExpression() || nextExpression.node.arguments.length !== 1) {\n                    return;\n                }\n                const enumCallArgument = nextExpression.node.arguments[0];\n                if (!core_1.types.isLogicalExpression(enumCallArgument, { operator: '||' })) {\n                    return;\n                }\n                // Check if identifiers match var declaration\n                if (!core_1.types.isIdentifier(enumCallArgument.left) ||\n                    !nextExpression.scope.bindingIdentifierEquals(enumCallArgument.left.name, declarationId)) {\n                    return;\n                }\n                const enumCallee = nextExpression.get('callee');\n                if (!enumCallee.isFunctionExpression() || enumCallee.node.params.length !== 1) {\n                    return;\n                }\n                const enumCalleeParam = enumCallee.node.params[0];\n                const isEnumCalleeMatching = core_1.types.isIdentifier(enumCalleeParam) && enumCalleeParam.name === declarationId.name;\n                // Loose mode rewrites the enum to a shorter but less TypeScript-like form\n                // Note: We only can apply the `loose` mode transformation if the callee parameter matches\n                // with the declaration identifier name. This is necessary in case the the declaration id has\n                // been renamed to avoid collisions, as the loose transform would then break the enum assignments\n                // which rely on the differently-named callee identifier name.\n                let enumAssignments;\n                if (loose && isEnumCalleeMatching) {\n                    enumAssignments = [];\n                }\n                // Check if all enum member values are pure.\n                // If not, leave as-is due to potential side efects\n                let hasElements = false;\n                for (const enumStatement of enumCallee.get('body').get('body')) {\n                    if (!enumStatement.isExpressionStatement()) {\n                        return;\n                    }\n                    const enumValueAssignment = enumStatement.get('expression');\n                    if (!enumValueAssignment.isAssignmentExpression() ||\n                        !enumValueAssignment.get('right').isPure()) {\n                        return;\n                    }\n                    hasElements = true;\n                    enumAssignments === null || enumAssignments === void 0 ? void 0 : enumAssignments.push(enumStatement.node);\n                }\n                // If there are no enum elements then there is nothing to wrap\n                if (!hasElements) {\n                    return;\n                }\n                // Remove existing enum initializer\n                const enumInitializer = nextExpression.node;\n                nextExpression.remove();\n                // Create IIFE block contents\n                let blockContents;\n                if (enumAssignments) {\n                    // Loose mode\n                    blockContents = [\n                        core_1.types.expressionStatement(core_1.types.assignmentExpression('=', core_1.types.cloneNode(declarationId), core_1.types.logicalExpression('||', core_1.types.cloneNode(declarationId), core_1.types.objectExpression([])))),\n                        ...enumAssignments,\n                    ];\n                }\n                else {\n                    blockContents = [core_1.types.expressionStatement(enumInitializer)];\n                }\n                // Wrap existing enum initializer in a pure annotated IIFE\n                const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([\n                    ...blockContents,\n                    core_1.types.returnStatement(core_1.types.cloneNode(declarationId)),\n                ]));\n                const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n                (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n                // Add the wrapped enum initializer directly to the variable declaration\n                declaration.get('init').replaceWith(replacementInitializer);\n            },\n        },\n    };\n}\nexports.default = default_1;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B,MAAMC,MAAM,GAAGC,OAAO,CAAC,aAAa,CAAC;AACrC,MAAMC,yBAAyB,GAAGV,eAAe,CAACS,OAAO,CAAC,gCAAgC,CAAC,CAAC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,WAAW,GAAG;EACnB,OAAO,CAAC,KAAK,CAAC;AAClB;AACAF,OAAO,CAACE,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA,SAASI,SAAS,GAAG;EACjB,OAAO;IACHC,OAAO,EAAE;MACLC,mBAAmB,CAACC,IAAI,EAAEC,KAAK,EAAE;QAC7B,MAAM;UAAEC,UAAU;UAAEC;QAAK,CAAC,GAAGH,IAAI;QACjC,MAAM;UAAEI;QAAM,CAAC,GAAGH,KAAK,CAACI,IAAI;QAC5B,IAAIF,IAAI,CAACG,IAAI,KAAK,KAAK,IAAIH,IAAI,CAACI,YAAY,CAACC,MAAM,KAAK,CAAC,EAAE;UACvD;QACJ;QACA,MAAMC,WAAW,GAAGT,IAAI,CAACU,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAID,WAAW,CAACN,IAAI,CAACQ,IAAI,EAAE;UACvB;QACJ;QACA,MAAMC,aAAa,GAAGH,WAAW,CAACN,IAAI,CAACU,EAAE;QACzC,IAAI,CAACnB,MAAM,CAACoB,KAAK,CAACC,YAAY,CAACH,aAAa,CAAC,EAAE;UAC3C;QACJ;QACA,MAAMI,SAAS,GAAGd,UAAU,CAACe,wBAAwB,EAAE,IAAIf,UAAU,CAACgB,0BAA0B,EAAE;QAClG,MAAMC,MAAM,GAAGH,SAAS,GAAGd,UAAU,GAAGF,IAAI;QAC5C,MAAMoB,aAAa,GAAGD,MAAM,CAACE,UAAU,CAAC,CAACF,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC;QACxD,IAAI,CAACF,aAAa,CAACG,qBAAqB,EAAE,EAAE;UACxC;QACJ;QACA,MAAMC,cAAc,GAAGJ,aAAa,CAACV,GAAG,CAAC,YAAY,CAAC;QACtD,IAAI,CAACc,cAAc,CAACC,gBAAgB,EAAE,IAAID,cAAc,CAACrB,IAAI,CAACuB,SAAS,CAAClB,MAAM,KAAK,CAAC,EAAE;UAClF;QACJ;QACA,MAAMmB,gBAAgB,GAAGH,cAAc,CAACrB,IAAI,CAACuB,SAAS,CAAC,CAAC,CAAC;QACzD,IAAI,CAAChC,MAAM,CAACoB,KAAK,CAACc,mBAAmB,CAACD,gBAAgB,EAAE;UAAEE,QAAQ,EAAE;QAAK,CAAC,CAAC,EAAE;UACzE;QACJ;QACA;QACA,IAAI,CAACnC,MAAM,CAACoB,KAAK,CAACC,YAAY,CAACY,gBAAgB,CAACG,IAAI,CAAC,IACjD,CAACN,cAAc,CAACO,KAAK,CAACC,uBAAuB,CAACL,gBAAgB,CAACG,IAAI,CAACG,IAAI,EAAErB,aAAa,CAAC,EAAE;UAC1F;QACJ;QACA,MAAMsB,UAAU,GAAGV,cAAc,CAACd,GAAG,CAAC,QAAQ,CAAC;QAC/C,IAAI,CAACwB,UAAU,CAACC,oBAAoB,EAAE,IAAID,UAAU,CAAC/B,IAAI,CAACiC,MAAM,CAAC5B,MAAM,KAAK,CAAC,EAAE;UAC3E;QACJ;QACA,MAAM6B,eAAe,GAAGH,UAAU,CAAC/B,IAAI,CAACiC,MAAM,CAAC,CAAC,CAAC;QACjD,MAAME,oBAAoB,GAAG5C,MAAM,CAACoB,KAAK,CAACC,YAAY,CAACsB,eAAe,CAAC,IAAIA,eAAe,CAACJ,IAAI,KAAKrB,aAAa,CAACqB,IAAI;QACtH;QACA;QACA;QACA;QACA;QACA,IAAIM,eAAe;QACnB,IAAInC,KAAK,IAAIkC,oBAAoB,EAAE;UAC/BC,eAAe,GAAG,EAAE;QACxB;QACA;QACA;QACA,IAAIC,WAAW,GAAG,KAAK;QACvB,KAAK,MAAMC,aAAa,IAAIP,UAAU,CAACxB,GAAG,CAAC,MAAM,CAAC,CAACA,GAAG,CAAC,MAAM,CAAC,EAAE;UAC5D,IAAI,CAAC+B,aAAa,CAAClB,qBAAqB,EAAE,EAAE;YACxC;UACJ;UACA,MAAMmB,mBAAmB,GAAGD,aAAa,CAAC/B,GAAG,CAAC,YAAY,CAAC;UAC3D,IAAI,CAACgC,mBAAmB,CAACC,sBAAsB,EAAE,IAC7C,CAACD,mBAAmB,CAAChC,GAAG,CAAC,OAAO,CAAC,CAACkC,MAAM,EAAE,EAAE;YAC5C;UACJ;UACAJ,WAAW,GAAG,IAAI;UAClBD,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACM,IAAI,CAACJ,aAAa,CAACtC,IAAI,CAAC;QAC9G;QACA;QACA,IAAI,CAACqC,WAAW,EAAE;UACd;QACJ;QACA;QACA,MAAMM,eAAe,GAAGtB,cAAc,CAACrB,IAAI;QAC3CqB,cAAc,CAACuB,MAAM,EAAE;QACvB;QACA,IAAIC,aAAa;QACjB,IAAIT,eAAe,EAAE;UACjB;UACAS,aAAa,GAAG,CACZtD,MAAM,CAACoB,KAAK,CAACmC,mBAAmB,CAACvD,MAAM,CAACoB,KAAK,CAACoC,oBAAoB,CAAC,GAAG,EAAExD,MAAM,CAACoB,KAAK,CAACqC,SAAS,CAACvC,aAAa,CAAC,EAAElB,MAAM,CAACoB,KAAK,CAACsC,iBAAiB,CAAC,IAAI,EAAE1D,MAAM,CAACoB,KAAK,CAACqC,SAAS,CAACvC,aAAa,CAAC,EAAElB,MAAM,CAACoB,KAAK,CAACuC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAC/N,GAAGd,eAAe,CACrB;QACL,CAAC,MACI;UACDS,aAAa,GAAG,CAACtD,MAAM,CAACoB,KAAK,CAACmC,mBAAmB,CAACH,eAAe,CAAC,CAAC;QACvE;QACA;QACA,MAAMQ,SAAS,GAAG5D,MAAM,CAACoB,KAAK,CAACyC,uBAAuB,CAAC,EAAE,EAAE7D,MAAM,CAACoB,KAAK,CAAC0C,cAAc,CAAC,CACnF,GAAGR,aAAa,EAChBtD,MAAM,CAACoB,KAAK,CAAC2C,eAAe,CAAC/D,MAAM,CAACoB,KAAK,CAACqC,SAAS,CAACvC,aAAa,CAAC,CAAC,CACtE,CAAC,CAAC;QACH,MAAM8C,sBAAsB,GAAGhE,MAAM,CAACoB,KAAK,CAAC6C,cAAc,CAACjE,MAAM,CAACoB,KAAK,CAAC8C,uBAAuB,CAACN,SAAS,CAAC,EAAE,EAAE,CAAC;QAC/G,CAAC,CAAC,EAAE1D,yBAAyB,CAACiE,OAAO,EAAEH,sBAAsB,CAAC;QAC9D;QACAjD,WAAW,CAACC,GAAG,CAAC,MAAM,CAAC,CAACoD,WAAW,CAACJ,sBAAsB,CAAC;MAC/D;IACJ;EACJ,CAAC;AACL;AACAnE,OAAO,CAACsE,OAAO,GAAGhE,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}