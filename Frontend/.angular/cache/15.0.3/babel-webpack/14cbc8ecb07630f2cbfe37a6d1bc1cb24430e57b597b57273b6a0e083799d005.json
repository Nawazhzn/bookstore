{"ast":null,"code":"const path = require('path');\nconst log = require('../logger').create('launcher');\nconst env = process.env;\nfunction ProcessLauncher(spawn, tempDir, timer, processKillTimeout) {\n  const self = this;\n  let onExitCallback;\n  const killTimeout = processKillTimeout || 2000;\n  // Will hold output from the spawned child process\n  const streamedOutputs = {\n    stdout: '',\n    stderr: ''\n  };\n  this._tempDir = tempDir.getPath(`/karma-${this.id.toString()}`);\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir);\n    self._start(url);\n  });\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done);\n    }\n    onExitCallback = done;\n    self._process.kill();\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout);\n  });\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url));\n  };\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform];\n  };\n  this._getOptions = function (url) {\n    return [url];\n  };\n\n  // Normalize the command, remove quotes (spawn does not like them).\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.includes(cmd.charAt(0))) {\n      cmd = cmd.slice(1, -1);\n      log.warn(`The path should not be quoted.\\n  Normalized the path to ${cmd}`);\n    }\n    return path.normalize(cmd);\n  };\n  this._onStdout = function (data) {\n    streamedOutputs.stdout += data;\n  };\n  this._onStderr = function (data) {\n    streamedOutputs.stderr += data;\n  };\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error(`No binary for ${self.name} browser on your platform.\\n  Please, set \"${self.ENV_CMD}\" env variable.`);\n\n      // disable restarting\n      self._retryLimit = -1;\n      return self._clearTempDirAndReportDone('no binary');\n    }\n    cmd = this._normalizeCommand(cmd);\n    log.debug(cmd + ' ' + args.join(' '));\n    self._process = spawn(cmd, args);\n    let errorOutput = '';\n    self._process.stdout.on('data', self._onStdout);\n    self._process.stderr.on('data', self._onStderr);\n    self._process.on('exit', function (code, signal) {\n      self._onProcessExit(code, signal, errorOutput);\n    });\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1;\n        errorOutput = `Can not find the binary ${cmd}\\n\\tPlease set env variable ${self.ENV_CMD}`;\n      } else if (err.code === 'EACCES') {\n        self._retryLimit = -1;\n        errorOutput = `Permission denied accessing the binary ${cmd}\\n\\tMaybe it's a directory?`;\n      } else {\n        errorOutput += err.toString();\n      }\n      self._onProcessExit(-1, null, errorOutput);\n    });\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString();\n    });\n  };\n  this._onProcessExit = function (code, signal, errorOutput) {\n    if (!self._process) {\n      // Both exit and error events trigger _onProcessExit(), but we only need one cleanup.\n      return;\n    }\n    log.debug(`Process ${self.name} exited with code ${code} and signal ${signal}`);\n    let error = null;\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error(`Cannot start ${self.name}\\n\\t${errorOutput}`);\n      error = 'cannot start';\n    }\n    if (self.state === self.STATE_CAPTURED) {\n      log.error(`${self.name} crashed.\\n\\t${errorOutput}`);\n      error = 'crashed';\n    }\n    if (error) {\n      log.error(`${self.name} stdout: ${streamedOutputs.stdout}`);\n      log.error(`${self.name} stderr: ${streamedOutputs.stderr}`);\n    }\n    self._process = null;\n    streamedOutputs.stdout = '';\n    streamedOutputs.stderr = '';\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer);\n      self._killTimer = null;\n    }\n    self._clearTempDirAndReportDone(error);\n  };\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error);\n      if (onExitCallback) {\n        onExitCallback();\n        onExitCallback = null;\n      }\n    });\n  };\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return;\n    }\n    log.warn(`${self.name} was not killed in ${killTimeout} ms, sending SIGKILL.`);\n    self._process.kill('SIGKILL');\n\n    // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n    self._killTimer = timer.setTimeout(function () {\n      log.warn(`${self.name} was not killed by SIGKILL in ${killTimeout} ms, continuing.`);\n      self._onProcessExit(-1, null, '');\n    }, killTimeout);\n  };\n}\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    const spawn = require('child_process').spawn;\n    function spawnWithoutOutput() {\n      const proc = spawn.apply(null, arguments);\n      proc.stdout.resume();\n      proc.stderr.resume();\n      return proc;\n    }\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout);\n  };\n};\nmodule.exports = ProcessLauncher;","map":{"version":3,"names":["path","require","log","create","env","process","ProcessLauncher","spawn","tempDir","timer","processKillTimeout","self","onExitCallback","killTimeout","streamedOutputs","stdout","stderr","_tempDir","getPath","id","toString","on","url","_start","done","_process","nextTick","kill","_killTimer","setTimeout","_onKillTimeout","_execCommand","_getCommand","_getOptions","ENV_CMD","DEFAULT_CMD","platform","_normalizeCommand","cmd","charAt","length","includes","slice","warn","normalize","_onStdout","data","_onStderr","args","error","name","_retryLimit","_clearTempDirAndReportDone","debug","join","errorOutput","code","signal","_onProcessExit","err","errBuff","state","STATE_BEING_CAPTURED","STATE_CAPTURED","clearTimeout","remove","_done","STATE_BEING_KILLED","STATE_BEING_FORCE_KILLED","decoratorFactory","launcher","spawnWithoutOutput","proc","apply","arguments","resume","call","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/karma/lib/launchers/process.js"],"sourcesContent":["const path = require('path')\nconst log = require('../logger').create('launcher')\nconst env = process.env\n\nfunction ProcessLauncher (spawn, tempDir, timer, processKillTimeout) {\n  const self = this\n  let onExitCallback\n  const killTimeout = processKillTimeout || 2000\n  // Will hold output from the spawned child process\n  const streamedOutputs = {\n    stdout: '',\n    stderr: ''\n  }\n\n  this._tempDir = tempDir.getPath(`/karma-${this.id.toString()}`)\n\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir)\n    self._start(url)\n  })\n\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done)\n    }\n\n    onExitCallback = done\n    self._process.kill()\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)\n  })\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url))\n  }\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]\n  }\n\n  this._getOptions = function (url) {\n    return [url]\n  }\n\n  // Normalize the command, remove quotes (spawn does not like them).\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.includes(cmd.charAt(0))) {\n      cmd = cmd.slice(1, -1)\n      log.warn(`The path should not be quoted.\\n  Normalized the path to ${cmd}`)\n    }\n\n    return path.normalize(cmd)\n  }\n\n  this._onStdout = function (data) {\n    streamedOutputs.stdout += data\n  }\n\n  this._onStderr = function (data) {\n    streamedOutputs.stderr += data\n  }\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error(`No binary for ${self.name} browser on your platform.\\n  Please, set \"${self.ENV_CMD}\" env variable.`)\n\n      // disable restarting\n      self._retryLimit = -1\n\n      return self._clearTempDirAndReportDone('no binary')\n    }\n\n    cmd = this._normalizeCommand(cmd)\n\n    log.debug(cmd + ' ' + args.join(' '))\n    self._process = spawn(cmd, args)\n    let errorOutput = ''\n\n    self._process.stdout.on('data', self._onStdout)\n\n    self._process.stderr.on('data', self._onStderr)\n\n    self._process.on('exit', function (code, signal) {\n      self._onProcessExit(code, signal, errorOutput)\n    })\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1\n        errorOutput = `Can not find the binary ${cmd}\\n\\tPlease set env variable ${self.ENV_CMD}`\n      } else if (err.code === 'EACCES') {\n        self._retryLimit = -1\n        errorOutput = `Permission denied accessing the binary ${cmd}\\n\\tMaybe it's a directory?`\n      } else {\n        errorOutput += err.toString()\n      }\n      self._onProcessExit(-1, null, errorOutput)\n    })\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString()\n    })\n  }\n\n  this._onProcessExit = function (code, signal, errorOutput) {\n    if (!self._process) {\n      // Both exit and error events trigger _onProcessExit(), but we only need one cleanup.\n      return\n    }\n    log.debug(`Process ${self.name} exited with code ${code} and signal ${signal}`)\n\n    let error = null\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error(`Cannot start ${self.name}\\n\\t${errorOutput}`)\n      error = 'cannot start'\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error(`${self.name} crashed.\\n\\t${errorOutput}`)\n      error = 'crashed'\n    }\n\n    if (error) {\n      log.error(`${self.name} stdout: ${streamedOutputs.stdout}`)\n      log.error(`${self.name} stderr: ${streamedOutputs.stderr}`)\n    }\n\n    self._process = null\n    streamedOutputs.stdout = ''\n    streamedOutputs.stderr = ''\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer)\n      self._killTimer = null\n    }\n    self._clearTempDirAndReportDone(error)\n  }\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error)\n      if (onExitCallback) {\n        onExitCallback()\n        onExitCallback = null\n      }\n    })\n  }\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return\n    }\n\n    log.warn(`${self.name} was not killed in ${killTimeout} ms, sending SIGKILL.`)\n    self._process.kill('SIGKILL')\n\n    // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n    self._killTimer = timer.setTimeout(function () {\n      log.warn(`${self.name} was not killed by SIGKILL in ${killTimeout} ms, continuing.`)\n      self._onProcessExit(-1, null, '')\n    }, killTimeout)\n  }\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    const spawn = require('child_process').spawn\n\n    function spawnWithoutOutput () {\n      const proc = spawn.apply(null, arguments)\n      proc.stdout.resume()\n      proc.stderr.resume()\n\n      return proc\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout)\n  }\n}\n\nmodule.exports = ProcessLauncher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}