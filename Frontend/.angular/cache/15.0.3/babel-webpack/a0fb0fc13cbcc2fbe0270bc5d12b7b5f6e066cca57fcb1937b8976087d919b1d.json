{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBinaryFileSync = exports.isBinaryFile = void 0;\nconst fs = require(\"fs\");\nconst util_1 = require(\"util\");\nconst statAsync = util_1.promisify(fs.stat);\nconst openAsync = util_1.promisify(fs.open);\nconst closeAsync = util_1.promisify(fs.close);\nconst MAX_BYTES = 512;\n// A very basic non-exception raising reader. Read bytes and\n// at the end use hasError() to check whether this worked.\nclass Reader {\n  constructor(fileBuffer, size) {\n    this.fileBuffer = fileBuffer;\n    this.size = size;\n    this.offset = 0;\n    this.error = false;\n  }\n  hasError() {\n    return this.error;\n  }\n  nextByte() {\n    if (this.offset === this.size || this.hasError()) {\n      this.error = true;\n      return 0xff;\n    }\n    return this.fileBuffer[this.offset++];\n  }\n  next(len) {\n    const n = new Array();\n    for (let i = 0; i < len; i++) {\n      n[i] = this.nextByte();\n    }\n    return n;\n  }\n}\n// Read a Google Protobuf var(iable)int from the buffer.\nfunction readProtoVarInt(reader) {\n  let idx = 0;\n  let varInt = 0;\n  while (!reader.hasError()) {\n    const b = reader.nextByte();\n    varInt = varInt | (b & 0x7f) << 7 * idx;\n    if ((b & 0x80) === 0) {\n      break;\n    }\n    idx++;\n  }\n  return varInt;\n}\n// Attempt to taste a full Google Protobuf message.\nfunction readProtoMessage(reader) {\n  const varInt = readProtoVarInt(reader);\n  const wireType = varInt & 0x7;\n  switch (wireType) {\n    case 0:\n      readProtoVarInt(reader);\n      return true;\n    case 1:\n      reader.next(8);\n      return true;\n    case 2:\n      const len = readProtoVarInt(reader);\n      reader.next(len);\n      return true;\n    case 5:\n      reader.next(4);\n      return true;\n  }\n  return false;\n}\n// Check whether this seems to be a valid protobuf file.\nfunction isBinaryProto(fileBuffer, totalBytes) {\n  const reader = new Reader(fileBuffer, totalBytes);\n  let numMessages = 0;\n  while (true) {\n    // Definitely not a valid protobuf\n    if (!readProtoMessage(reader) && !reader.hasError()) {\n      return false;\n    }\n    // Short read?\n    if (reader.hasError()) {\n      break;\n    }\n    numMessages++;\n  }\n  return numMessages > 0;\n}\nfunction isBinaryFile(file, size) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (isString(file)) {\n      const stat = yield statAsync(file);\n      isStatFile(stat);\n      const fileDescriptor = yield openAsync(file, 'r');\n      const allocBuffer = Buffer.alloc(MAX_BYTES);\n      // Read the file with no encoding for raw buffer access.\n      // NB: something is severely wrong with promisify, had to construct my own Promise\n      return new Promise((fulfill, reject) => {\n        fs.read(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0, (err, bytesRead, _) => {\n          closeAsync(fileDescriptor);\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(isBinaryCheck(allocBuffer, bytesRead));\n          }\n        });\n      });\n    } else {\n      if (size === undefined) {\n        size = file.length;\n      }\n      return isBinaryCheck(file, size);\n    }\n  });\n}\nexports.isBinaryFile = isBinaryFile;\nfunction isBinaryFileSync(file, size) {\n  if (isString(file)) {\n    const stat = fs.statSync(file);\n    isStatFile(stat);\n    const fileDescriptor = fs.openSync(file, 'r');\n    const allocBuffer = Buffer.alloc(MAX_BYTES);\n    const bytesRead = fs.readSync(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0);\n    fs.closeSync(fileDescriptor);\n    return isBinaryCheck(allocBuffer, bytesRead);\n  } else {\n    if (size === undefined) {\n      size = file.length;\n    }\n    return isBinaryCheck(file, size);\n  }\n}\nexports.isBinaryFileSync = isBinaryFileSync;\nfunction isBinaryCheck(fileBuffer, bytesRead) {\n  // empty file. no clue what it is.\n  if (bytesRead === 0) {\n    return false;\n  }\n  let suspiciousBytes = 0;\n  const totalBytes = Math.min(bytesRead, MAX_BYTES);\n  // UTF-8 BOM\n  if (bytesRead >= 3 && fileBuffer[0] === 0xef && fileBuffer[1] === 0xbb && fileBuffer[2] === 0xbf) {\n    return false;\n  }\n  // UTF-32 BOM\n  if (bytesRead >= 4 && fileBuffer[0] === 0x00 && fileBuffer[1] === 0x00 && fileBuffer[2] === 0xfe && fileBuffer[3] === 0xff) {\n    return false;\n  }\n  // UTF-32 LE BOM\n  if (bytesRead >= 4 && fileBuffer[0] === 0xff && fileBuffer[1] === 0xfe && fileBuffer[2] === 0x00 && fileBuffer[3] === 0x00) {\n    return false;\n  }\n  // GB BOM\n  if (bytesRead >= 4 && fileBuffer[0] === 0x84 && fileBuffer[1] === 0x31 && fileBuffer[2] === 0x95 && fileBuffer[3] === 0x33) {\n    return false;\n  }\n  if (totalBytes >= 5 && fileBuffer.slice(0, 5).toString() === '%PDF-') {\n    /* PDF. This is binary. */\n    return true;\n  }\n  // UTF-16 BE BOM\n  if (bytesRead >= 2 && fileBuffer[0] === 0xfe && fileBuffer[1] === 0xff) {\n    return false;\n  }\n  // UTF-16 LE BOM\n  if (bytesRead >= 2 && fileBuffer[0] === 0xff && fileBuffer[1] === 0xfe) {\n    return false;\n  }\n  for (let i = 0; i < totalBytes; i++) {\n    if (fileBuffer[i] === 0) {\n      // NULL byte--it's binary!\n      return true;\n    } else if ((fileBuffer[i] < 7 || fileBuffer[i] > 14) && (fileBuffer[i] < 32 || fileBuffer[i] > 127)) {\n      // UTF-8 detection\n      if (fileBuffer[i] > 193 && fileBuffer[i] < 224 && i + 1 < totalBytes) {\n        i++;\n        if (fileBuffer[i] > 127 && fileBuffer[i] < 192) {\n          continue;\n        }\n      } else if (fileBuffer[i] > 223 && fileBuffer[i] < 240 && i + 2 < totalBytes) {\n        i++;\n        if (fileBuffer[i] > 127 && fileBuffer[i] < 192 && fileBuffer[i + 1] > 127 && fileBuffer[i + 1] < 192) {\n          i++;\n          continue;\n        }\n      }\n      suspiciousBytes++;\n      // Read at least 32 fileBuffer before making a decision\n      if (i >= 32 && suspiciousBytes * 100 / totalBytes > 10) {\n        return true;\n      }\n    }\n  }\n  if (suspiciousBytes * 100 / totalBytes > 10) {\n    return true;\n  }\n  if (suspiciousBytes > 1 && isBinaryProto(fileBuffer, totalBytes)) {\n    return true;\n  }\n  return false;\n}\nfunction isString(x) {\n  return typeof x === 'string';\n}\nfunction isStatFile(stat) {\n  if (!stat.isFile()) {\n    throw new Error(`Path provided was not a file!`);\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","isBinaryFileSync","isBinaryFile","fs","require","util_1","statAsync","promisify","stat","openAsync","open","closeAsync","close","MAX_BYTES","Reader","constructor","fileBuffer","size","offset","error","hasError","nextByte","len","n","Array","i","readProtoVarInt","reader","idx","varInt","b","readProtoMessage","wireType","isBinaryProto","totalBytes","numMessages","file","isString","isStatFile","fileDescriptor","allocBuffer","Buffer","alloc","fulfill","read","err","bytesRead","_","isBinaryCheck","undefined","length","statSync","openSync","readSync","closeSync","suspiciousBytes","Math","min","slice","toString","x","isFile","Error"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/isbinaryfile/lib/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBinaryFileSync = exports.isBinaryFile = void 0;\nconst fs = require(\"fs\");\nconst util_1 = require(\"util\");\nconst statAsync = util_1.promisify(fs.stat);\nconst openAsync = util_1.promisify(fs.open);\nconst closeAsync = util_1.promisify(fs.close);\nconst MAX_BYTES = 512;\n// A very basic non-exception raising reader. Read bytes and\n// at the end use hasError() to check whether this worked.\nclass Reader {\n    constructor(fileBuffer, size) {\n        this.fileBuffer = fileBuffer;\n        this.size = size;\n        this.offset = 0;\n        this.error = false;\n    }\n    hasError() {\n        return this.error;\n    }\n    nextByte() {\n        if (this.offset === this.size || this.hasError()) {\n            this.error = true;\n            return 0xff;\n        }\n        return this.fileBuffer[this.offset++];\n    }\n    next(len) {\n        const n = new Array();\n        for (let i = 0; i < len; i++) {\n            n[i] = this.nextByte();\n        }\n        return n;\n    }\n}\n// Read a Google Protobuf var(iable)int from the buffer.\nfunction readProtoVarInt(reader) {\n    let idx = 0;\n    let varInt = 0;\n    while (!reader.hasError()) {\n        const b = reader.nextByte();\n        varInt = varInt | ((b & 0x7f) << (7 * idx));\n        if ((b & 0x80) === 0) {\n            break;\n        }\n        idx++;\n    }\n    return varInt;\n}\n// Attempt to taste a full Google Protobuf message.\nfunction readProtoMessage(reader) {\n    const varInt = readProtoVarInt(reader);\n    const wireType = varInt & 0x7;\n    switch (wireType) {\n        case 0:\n            readProtoVarInt(reader);\n            return true;\n        case 1:\n            reader.next(8);\n            return true;\n        case 2:\n            const len = readProtoVarInt(reader);\n            reader.next(len);\n            return true;\n        case 5:\n            reader.next(4);\n            return true;\n    }\n    return false;\n}\n// Check whether this seems to be a valid protobuf file.\nfunction isBinaryProto(fileBuffer, totalBytes) {\n    const reader = new Reader(fileBuffer, totalBytes);\n    let numMessages = 0;\n    while (true) {\n        // Definitely not a valid protobuf\n        if (!readProtoMessage(reader) && !reader.hasError()) {\n            return false;\n        }\n        // Short read?\n        if (reader.hasError()) {\n            break;\n        }\n        numMessages++;\n    }\n    return numMessages > 0;\n}\nfunction isBinaryFile(file, size) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (isString(file)) {\n            const stat = yield statAsync(file);\n            isStatFile(stat);\n            const fileDescriptor = yield openAsync(file, 'r');\n            const allocBuffer = Buffer.alloc(MAX_BYTES);\n            // Read the file with no encoding for raw buffer access.\n            // NB: something is severely wrong with promisify, had to construct my own Promise\n            return new Promise((fulfill, reject) => {\n                fs.read(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0, (err, bytesRead, _) => {\n                    closeAsync(fileDescriptor);\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        fulfill(isBinaryCheck(allocBuffer, bytesRead));\n                    }\n                });\n            });\n        }\n        else {\n            if (size === undefined) {\n                size = file.length;\n            }\n            return isBinaryCheck(file, size);\n        }\n    });\n}\nexports.isBinaryFile = isBinaryFile;\nfunction isBinaryFileSync(file, size) {\n    if (isString(file)) {\n        const stat = fs.statSync(file);\n        isStatFile(stat);\n        const fileDescriptor = fs.openSync(file, 'r');\n        const allocBuffer = Buffer.alloc(MAX_BYTES);\n        const bytesRead = fs.readSync(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0);\n        fs.closeSync(fileDescriptor);\n        return isBinaryCheck(allocBuffer, bytesRead);\n    }\n    else {\n        if (size === undefined) {\n            size = file.length;\n        }\n        return isBinaryCheck(file, size);\n    }\n}\nexports.isBinaryFileSync = isBinaryFileSync;\nfunction isBinaryCheck(fileBuffer, bytesRead) {\n    // empty file. no clue what it is.\n    if (bytesRead === 0) {\n        return false;\n    }\n    let suspiciousBytes = 0;\n    const totalBytes = Math.min(bytesRead, MAX_BYTES);\n    // UTF-8 BOM\n    if (bytesRead >= 3 && fileBuffer[0] === 0xef && fileBuffer[1] === 0xbb && fileBuffer[2] === 0xbf) {\n        return false;\n    }\n    // UTF-32 BOM\n    if (bytesRead >= 4 &&\n        fileBuffer[0] === 0x00 &&\n        fileBuffer[1] === 0x00 &&\n        fileBuffer[2] === 0xfe &&\n        fileBuffer[3] === 0xff) {\n        return false;\n    }\n    // UTF-32 LE BOM\n    if (bytesRead >= 4 &&\n        fileBuffer[0] === 0xff &&\n        fileBuffer[1] === 0xfe &&\n        fileBuffer[2] === 0x00 &&\n        fileBuffer[3] === 0x00) {\n        return false;\n    }\n    // GB BOM\n    if (bytesRead >= 4 &&\n        fileBuffer[0] === 0x84 &&\n        fileBuffer[1] === 0x31 &&\n        fileBuffer[2] === 0x95 &&\n        fileBuffer[3] === 0x33) {\n        return false;\n    }\n    if (totalBytes >= 5 && fileBuffer.slice(0, 5).toString() === '%PDF-') {\n        /* PDF. This is binary. */\n        return true;\n    }\n    // UTF-16 BE BOM\n    if (bytesRead >= 2 && fileBuffer[0] === 0xfe && fileBuffer[1] === 0xff) {\n        return false;\n    }\n    // UTF-16 LE BOM\n    if (bytesRead >= 2 && fileBuffer[0] === 0xff && fileBuffer[1] === 0xfe) {\n        return false;\n    }\n    for (let i = 0; i < totalBytes; i++) {\n        if (fileBuffer[i] === 0) {\n            // NULL byte--it's binary!\n            return true;\n        }\n        else if ((fileBuffer[i] < 7 || fileBuffer[i] > 14) && (fileBuffer[i] < 32 || fileBuffer[i] > 127)) {\n            // UTF-8 detection\n            if (fileBuffer[i] > 193 && fileBuffer[i] < 224 && i + 1 < totalBytes) {\n                i++;\n                if (fileBuffer[i] > 127 && fileBuffer[i] < 192) {\n                    continue;\n                }\n            }\n            else if (fileBuffer[i] > 223 && fileBuffer[i] < 240 && i + 2 < totalBytes) {\n                i++;\n                if (fileBuffer[i] > 127 && fileBuffer[i] < 192 && fileBuffer[i + 1] > 127 && fileBuffer[i + 1] < 192) {\n                    i++;\n                    continue;\n                }\n            }\n            suspiciousBytes++;\n            // Read at least 32 fileBuffer before making a decision\n            if (i >= 32 && (suspiciousBytes * 100) / totalBytes > 10) {\n                return true;\n            }\n        }\n    }\n    if ((suspiciousBytes * 100) / totalBytes > 10) {\n        return true;\n    }\n    if (suspiciousBytes > 1 && isBinaryProto(fileBuffer, totalBytes)) {\n        return true;\n    }\n    return false;\n}\nfunction isString(x) {\n    return typeof x === 'string';\n}\nfunction isStatFile(stat) {\n    if (!stat.isFile()) {\n        throw new Error(`Path provided was not a file!`);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}