{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst path = require(\"path\");\nconst mime = require(\"mime-types\");\nconst parseRange = require(\"range-parser\");\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\nconst {\n  getHeaderNames,\n  getHeaderFromRequest,\n  getHeaderFromResponse,\n  setHeaderForResponse,\n  setStatusCode,\n  send\n} = require(\"./utils/compatibleAPI\");\nconst ready = require(\"./utils/ready\");\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\n\nfunction getValueContentRangeHeader(type, size, range) {\n  return `${type} ${range ? `${range.start}-${range.end}` : \"*\"}/${size}`;\n}\n/**\n * @param {string | number} title\n * @param {string} body\n * @returns {string}\n */\n\nfunction createHtmlDocument(title, body) {\n  return `${\"<!DOCTYPE html>\\n\" + '<html lang=\"en\">\\n' + \"<head>\\n\" + '<meta charset=\"utf-8\">\\n' + \"<title>\"}${title}</title>\\n` + `</head>\\n` + `<body>\\n` + `<pre>${body}</pre>\\n` + `</body>\\n` + `</html>\\n`;\n}\nconst BYTES_RANGE_REGEXP = /^ *bytes/i;\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").Context<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\n\nfunction wrapper(context) {\n  return /*#__PURE__*/function () {\n    var _middleware = _asyncToGenerator(function* (req, res, next) {\n      const acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n      // eslint-disable-next-line no-param-reassign\n\n      res.locals = res.locals || {};\n      if (req.method && !acceptedMethods.includes(req.method)) {\n        yield goNext();\n        return;\n      }\n      ready(context, processRequest, req);\n      function goNext() {\n        return _goNext.apply(this, arguments);\n      }\n      function _goNext() {\n        _goNext = _asyncToGenerator(function* () {\n          if (!context.options.serverSideRender) {\n            return next();\n          }\n          return new Promise(resolve => {\n            ready(context, () => {\n              /** @type {any} */\n              // eslint-disable-next-line no-param-reassign\n              res.locals.webpack = {\n                devMiddleware: context\n              };\n              resolve(next());\n            }, req);\n          });\n        });\n        return _goNext.apply(this, arguments);\n      }\n      function processRequest() {\n        return _processRequest.apply(this, arguments);\n      }\n      function _processRequest() {\n        _processRequest = _asyncToGenerator(function* () {\n          const filename = getFilenameFromUrl(context, /** @type {string} */\n          req.url);\n          if (!filename) {\n            yield goNext();\n            return;\n          }\n          let {\n            headers\n          } = context.options;\n          if (typeof headers === \"function\") {\n            // @ts-ignore\n            headers = headers(req, res, context);\n          }\n          /**\n           * @type {{key: string, value: string | number}[]}\n           */\n\n          const allHeaders = [];\n          if (typeof headers !== \"undefined\") {\n            if (!Array.isArray(headers)) {\n              // eslint-disable-next-line guard-for-in\n              for (const name in headers) {\n                // @ts-ignore\n                allHeaders.push({\n                  key: name,\n                  value: headers[name]\n                });\n              }\n              headers = allHeaders;\n            }\n            headers.forEach(\n            /**\n             * @param {{key: string, value: any}} header\n             */\n            header => {\n              setHeaderForResponse(res, header.key, header.value);\n            });\n          }\n          if (!getHeaderFromResponse(res, \"Content-Type\")) {\n            // content-type name(like application/javascript; charset=utf-8) or false\n            const contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known\n            // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n\n            if (contentType) {\n              setHeaderForResponse(res, \"Content-Type\", contentType);\n            }\n          }\n          if (!getHeaderFromResponse(res, \"Accept-Ranges\")) {\n            setHeaderForResponse(res, \"Accept-Ranges\", \"bytes\");\n          }\n          const rangeHeader = getHeaderFromRequest(req, \"range\");\n          let start;\n          let end;\n          if (rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader)) {\n            const size = yield new Promise(resolve => {\n              /** @type {import(\"fs\").lstat} */\n              context.outputFileSystem.lstat(filename, (error, stats) => {\n                if (error) {\n                  context.logger.error(error);\n                  return;\n                }\n                resolve(stats.size);\n              });\n            });\n            const parsedRanges = parseRange(size, rangeHeader, {\n              combine: true\n            });\n            if (parsedRanges === -1) {\n              const message = \"Unsatisfiable range for 'Range' header.\";\n              context.logger.error(message);\n              const existingHeaders = getHeaderNames(res);\n              for (let i = 0; i < existingHeaders.length; i++) {\n                res.removeHeader(existingHeaders[i]);\n              }\n              setStatusCode(res, 416);\n              setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n              setHeaderForResponse(res, \"Content-Type\", \"text/html; charset=utf-8\");\n              const document = createHtmlDocument(416, `Error: ${message}`);\n              const byteLength = Buffer.byteLength(document);\n              setHeaderForResponse(res, \"Content-Length\", Buffer.byteLength(document));\n              send(req, res, document, byteLength);\n              return;\n            } else if (parsedRanges === -2) {\n              context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n            } else if (parsedRanges.length > 1) {\n              context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n            }\n            if (parsedRanges !== -2 && parsedRanges.length === 1) {\n              // Content-Range\n              setStatusCode(res, 206);\n              setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size, /** @type {import(\"range-parser\").Ranges} */\n              parsedRanges[0]));\n              [{\n                start,\n                end\n              }] = parsedRanges;\n            }\n          }\n          const isFsSupportsStream = typeof context.outputFileSystem.createReadStream === \"function\";\n          let bufferOtStream;\n          let byteLength;\n          try {\n            if (typeof start !== \"undefined\" && typeof end !== \"undefined\" && isFsSupportsStream) {\n              bufferOtStream = /** @type {import(\"fs\").createReadStream} */\n              context.outputFileSystem.createReadStream(filename, {\n                start,\n                end\n              });\n              byteLength = end - start + 1;\n            } else {\n              bufferOtStream = /** @type {import(\"fs\").readFileSync} */\n              context.outputFileSystem.readFileSync(filename);\n              ({\n                byteLength\n              } = bufferOtStream);\n            }\n          } catch (_ignoreError) {\n            yield goNext();\n            return;\n          }\n          send(req, res, bufferOtStream, byteLength);\n        });\n        return _processRequest.apply(this, arguments);\n      }\n    });\n    function middleware(_x, _x2, _x3) {\n      return _middleware.apply(this, arguments);\n    }\n    return middleware;\n  }();\n}\nmodule.exports = wrapper;","map":{"version":3,"names":["path","require","mime","parseRange","getFilenameFromUrl","getHeaderNames","getHeaderFromRequest","getHeaderFromResponse","setHeaderForResponse","setStatusCode","send","ready","getValueContentRangeHeader","type","size","range","start","end","createHtmlDocument","title","body","BYTES_RANGE_REGEXP","wrapper","context","req","res","next","acceptedMethods","options","methods","locals","method","includes","goNext","processRequest","serverSideRender","Promise","resolve","webpack","devMiddleware","filename","url","headers","allHeaders","Array","isArray","name","push","key","value","forEach","header","contentType","extname","rangeHeader","test","outputFileSystem","lstat","error","stats","logger","parsedRanges","combine","message","existingHeaders","i","length","removeHeader","document","byteLength","Buffer","isFsSupportsStream","createReadStream","bufferOtStream","readFileSync","_ignoreError","middleware","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/webpack-dev-middleware/dist/middleware.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst mime = require(\"mime-types\");\n\nconst parseRange = require(\"range-parser\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst {\n  getHeaderNames,\n  getHeaderFromRequest,\n  getHeaderFromResponse,\n  setHeaderForResponse,\n  setStatusCode,\n  send\n} = require(\"./utils/compatibleAPI\");\n\nconst ready = require(\"./utils/ready\");\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\n\n\nfunction getValueContentRangeHeader(type, size, range) {\n  return `${type} ${range ? `${range.start}-${range.end}` : \"*\"}/${size}`;\n}\n/**\n * @param {string | number} title\n * @param {string} body\n * @returns {string}\n */\n\n\nfunction createHtmlDocument(title, body) {\n  return `${\"<!DOCTYPE html>\\n\" + '<html lang=\"en\">\\n' + \"<head>\\n\" + '<meta charset=\"utf-8\">\\n' + \"<title>\"}${title}</title>\\n` + `</head>\\n` + `<body>\\n` + `<pre>${body}</pre>\\n` + `</body>\\n` + `</html>\\n`;\n}\n\nconst BYTES_RANGE_REGEXP = /^ *bytes/i;\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").Context<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\n\nfunction wrapper(context) {\n  return async function middleware(req, res, next) {\n    const acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n    // eslint-disable-next-line no-param-reassign\n\n    res.locals = res.locals || {};\n\n    if (req.method && !acceptedMethods.includes(req.method)) {\n      await goNext();\n      return;\n    }\n\n    ready(context, processRequest, req);\n\n    async function goNext() {\n      if (!context.options.serverSideRender) {\n        return next();\n      }\n\n      return new Promise(resolve => {\n        ready(context, () => {\n          /** @type {any} */\n          // eslint-disable-next-line no-param-reassign\n          res.locals.webpack = {\n            devMiddleware: context\n          };\n          resolve(next());\n        }, req);\n      });\n    }\n\n    async function processRequest() {\n      const filename = getFilenameFromUrl(context,\n      /** @type {string} */\n      req.url);\n\n      if (!filename) {\n        await goNext();\n        return;\n      }\n\n      let {\n        headers\n      } = context.options;\n\n      if (typeof headers === \"function\") {\n        // @ts-ignore\n        headers = headers(req, res, context);\n      }\n      /**\n       * @type {{key: string, value: string | number}[]}\n       */\n\n\n      const allHeaders = [];\n\n      if (typeof headers !== \"undefined\") {\n        if (!Array.isArray(headers)) {\n          // eslint-disable-next-line guard-for-in\n          for (const name in headers) {\n            // @ts-ignore\n            allHeaders.push({\n              key: name,\n              value: headers[name]\n            });\n          }\n\n          headers = allHeaders;\n        }\n\n        headers.forEach(\n        /**\n         * @param {{key: string, value: any}} header\n         */\n        header => {\n          setHeaderForResponse(res, header.key, header.value);\n        });\n      }\n\n      if (!getHeaderFromResponse(res, \"Content-Type\")) {\n        // content-type name(like application/javascript; charset=utf-8) or false\n        const contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n\n        if (contentType) {\n          setHeaderForResponse(res, \"Content-Type\", contentType);\n        }\n      }\n\n      if (!getHeaderFromResponse(res, \"Accept-Ranges\")) {\n        setHeaderForResponse(res, \"Accept-Ranges\", \"bytes\");\n      }\n\n      const rangeHeader = getHeaderFromRequest(req, \"range\");\n      let start;\n      let end;\n\n      if (rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader)) {\n        const size = await new Promise(resolve => {\n          /** @type {import(\"fs\").lstat} */\n          context.outputFileSystem.lstat(filename, (error, stats) => {\n            if (error) {\n              context.logger.error(error);\n              return;\n            }\n\n            resolve(stats.size);\n          });\n        });\n        const parsedRanges = parseRange(size, rangeHeader, {\n          combine: true\n        });\n\n        if (parsedRanges === -1) {\n          const message = \"Unsatisfiable range for 'Range' header.\";\n          context.logger.error(message);\n          const existingHeaders = getHeaderNames(res);\n\n          for (let i = 0; i < existingHeaders.length; i++) {\n            res.removeHeader(existingHeaders[i]);\n          }\n\n          setStatusCode(res, 416);\n          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n          setHeaderForResponse(res, \"Content-Type\", \"text/html; charset=utf-8\");\n          const document = createHtmlDocument(416, `Error: ${message}`);\n          const byteLength = Buffer.byteLength(document);\n          setHeaderForResponse(res, \"Content-Length\", Buffer.byteLength(document));\n          send(req, res, document, byteLength);\n          return;\n        } else if (parsedRanges === -2) {\n          context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n        } else if (parsedRanges.length > 1) {\n          context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n        }\n\n        if (parsedRanges !== -2 && parsedRanges.length === 1) {\n          // Content-Range\n          setStatusCode(res, 206);\n          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size,\n          /** @type {import(\"range-parser\").Ranges} */\n          parsedRanges[0]));\n          [{\n            start,\n            end\n          }] = parsedRanges;\n        }\n      }\n\n      const isFsSupportsStream = typeof context.outputFileSystem.createReadStream === \"function\";\n      let bufferOtStream;\n      let byteLength;\n\n      try {\n        if (typeof start !== \"undefined\" && typeof end !== \"undefined\" && isFsSupportsStream) {\n          bufferOtStream =\n          /** @type {import(\"fs\").createReadStream} */\n          context.outputFileSystem.createReadStream(filename, {\n            start,\n            end\n          });\n          byteLength = end - start + 1;\n        } else {\n          bufferOtStream =\n          /** @type {import(\"fs\").readFileSync} */\n          context.outputFileSystem.readFileSync(filename);\n          ({\n            byteLength\n          } = bufferOtStream);\n        }\n      } catch (_ignoreError) {\n        await goNext();\n        return;\n      }\n\n      send(req, res, bufferOtStream, byteLength);\n    }\n  };\n}\n\nmodule.exports = wrapper;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}