{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\nexports.isURL = isURL;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _url = _interopRequireDefault(require(\"url\"));\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\nvar _iconvLite = require(\"iconv-lite\");\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n// Matches only the last occurrence of sourceMappingURL\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\nfunction flattenSourceMap(_x) {\n  return _flattenSourceMap.apply(this, arguments);\n}\nfunction _flattenSourceMap() {\n  _flattenSourceMap = _asyncToGenerator(function* (map) {\n    const consumer = yield new _sourceMapJs.default.SourceMapConsumer(map);\n    const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n      file: map.file\n    }) : new _sourceMapJs.default.SourceMapGenerator();\n    consumer.sources.forEach(sourceFile => {\n      const sourceContent = consumer.sourceContentFor(sourceFile, true);\n      generatedMap.setSourceContent(sourceFile, sourceContent);\n    });\n    consumer.eachMapping(mapping => {\n      const {\n        source\n      } = consumer.originalPositionFor({\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      });\n      const mappings = {\n        source,\n        original: {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        },\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n      if (source) {\n        generatedMap.addMapping(mappings);\n      }\n    });\n    return generatedMap.toJSON();\n  });\n  return _flattenSourceMap.apply(this, arguments);\n}\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n    if (match) {\n      break;\n    }\n  }\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (isURL(sourceRoot)) {\n    return new URL(request, sourceRoot).toString();\n  }\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n    return _path.default.join(context, sourceRoot, request);\n  }\n  return _path.default.join(context, request);\n}\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\nfunction fetchFromFilesystem(_x2, _x3) {\n  return _fetchFromFilesystem.apply(this, arguments);\n}\nfunction _fetchFromFilesystem() {\n  _fetchFromFilesystem = _asyncToGenerator(function* (loaderContext, sourceURL) {\n    let buffer;\n    if (isURL(sourceURL)) {\n      return {\n        path: sourceURL\n      };\n    }\n    try {\n      buffer = yield new Promise((resolve, reject) => {\n        loaderContext.fs.readFile(sourceURL, (error, data) => {\n          if (error) {\n            return reject(error);\n          }\n          return resolve(data);\n        });\n      });\n    } catch (error) {\n      throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n    }\n    return {\n      path: sourceURL,\n      data: buffer.toString()\n    };\n  });\n  return _fetchFromFilesystem.apply(this, arguments);\n}\nfunction fetchPathsFromFilesystem(_x4, _x5) {\n  return _fetchPathsFromFilesystem.apply(this, arguments);\n}\nfunction _fetchPathsFromFilesystem() {\n  _fetchPathsFromFilesystem = _asyncToGenerator(function* (loaderContext, possibleRequests, errorsAccumulator = \"\") {\n    let result;\n    try {\n      result = yield fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n    } catch (error) {\n      // eslint-disable-next-line no-param-reassign\n      errorsAccumulator += `${error.message}\\n\\n`;\n      const [, ...tailPossibleRequests] = possibleRequests;\n      if (tailPossibleRequests.length === 0) {\n        error.message = errorsAccumulator;\n        throw error;\n      }\n      return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n    }\n    return result;\n  });\n  return _fetchPathsFromFilesystem.apply(this, arguments);\n}\nfunction isURL(value) {\n  return /^[a-z][a-z0-9+.-]*:/i.test(value) && !_path.default.win32.isAbsolute(value);\n}\nfunction fetchFromURL(_x6, _x7, _x8, _x9) {\n  return _fetchFromURL.apply(this, arguments);\n}\nfunction _fetchFromURL() {\n  _fetchFromURL = _asyncToGenerator(function* (loaderContext, context, url, sourceRoot, skipReading = false) {\n    // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n    if (isURL(url)) {\n      const {\n        protocol\n      } = _url.default.parse(url);\n      if (protocol === \"data:\") {\n        if (skipReading) {\n          return {\n            sourceURL: \"\"\n          };\n        }\n        const sourceContent = fetchFromDataURL(loaderContext, url);\n        return {\n          sourceURL: \"\",\n          sourceContent\n        };\n      }\n      if (skipReading) {\n        return {\n          sourceURL: url\n        };\n      }\n      if (protocol === \"file:\") {\n        const pathFromURL = _url.default.fileURLToPath(url);\n        const sourceURL = _path.default.normalize(pathFromURL);\n        const {\n          data: sourceContent\n        } = yield fetchFromFilesystem(loaderContext, sourceURL);\n        return {\n          sourceURL,\n          sourceContent\n        };\n      }\n      throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n    } // 2. It's a scheme-relative\n\n    if (/^\\/\\//.test(url)) {\n      throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n    } // 3. Absolute path\n\n    if (_path.default.isAbsolute(url)) {\n      let sourceURL = _path.default.normalize(url);\n      let sourceContent;\n      if (!skipReading) {\n        const possibleRequests = [sourceURL];\n        if (url.startsWith(\"/\")) {\n          possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n        }\n        const result = yield fetchPathsFromFilesystem(loaderContext, possibleRequests);\n        sourceURL = result.path;\n        sourceContent = result.data;\n      }\n      return {\n        sourceURL,\n        sourceContent\n      };\n    } // 4. Relative path\n\n    const sourceURL = getAbsolutePath(context, url, sourceRoot);\n    let sourceContent;\n    if (!skipReading) {\n      const {\n        data\n      } = yield fetchFromFilesystem(loaderContext, sourceURL);\n      sourceContent = data;\n    }\n    return {\n      sourceURL,\n      sourceContent\n    };\n  });\n  return _fetchFromURL.apply(this, arguments);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","fetchFromURL","flattenSourceMap","getSourceMappingURL","isURL","_path","_interopRequireDefault","require","_url","_sourceMapJs","_iconvLite","_parseDataUrl","_labelsToNames","obj","__esModule","default","innerRegex","sourceMappingURLRegex","RegExp","source","labelToName","label","labelLowercase","String","trim","toLowerCase","map","consumer","SourceMapConsumer","generatedMap","file","SourceMapGenerator","sources","forEach","sourceFile","sourceContent","sourceContentFor","setSourceContent","eachMapping","mapping","originalPositionFor","line","generatedLine","column","generatedColumn","mappings","original","originalLine","originalColumn","generated","addMapping","toJSON","code","lines","split","match","i","length","sourceMappingURL","decodeURI","replacementString","getAbsolutePath","context","request","sourceRoot","URL","toString","isAbsolute","join","fetchFromDataURL","loaderContext","sourceURL","dataURL","encodingName","parameters","get","decode","body","Error","fetchFromFilesystem","buffer","path","Promise","resolve","reject","fs","readFile","error","data","fetchPathsFromFilesystem","possibleRequests","errorsAccumulator","result","message","tailPossibleRequests","test","win32","url","skipReading","protocol","parse","pathFromURL","fileURLToPath","normalize","startsWith","push","slice"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/source-map-loader/dist/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\nexports.isURL = isURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Matches only the last occurrence of sourceMappingURL\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nasync function flattenSourceMap(map) {\n  const consumer = await new _sourceMapJs.default.SourceMapConsumer(map);\n  const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n    file: map.file\n  }) : new _sourceMapJs.default.SourceMapGenerator();\n  consumer.sources.forEach(sourceFile => {\n    const sourceContent = consumer.sourceContentFor(sourceFile, true);\n    generatedMap.setSourceContent(sourceFile, sourceContent);\n  });\n  consumer.eachMapping(mapping => {\n    const {\n      source\n    } = consumer.originalPositionFor({\n      line: mapping.generatedLine,\n      column: mapping.generatedColumn\n    });\n    const mappings = {\n      source,\n      original: {\n        line: mapping.originalLine,\n        column: mapping.originalColumn\n      },\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      }\n    };\n\n    if (source) {\n      generatedMap.addMapping(mappings);\n    }\n  });\n  return generatedMap.toJSON();\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (isURL(sourceRoot)) {\n    return new URL(request, sourceRoot).toString();\n  }\n\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nasync function fetchFromFilesystem(loaderContext, sourceURL) {\n  let buffer;\n\n  if (isURL(sourceURL)) {\n    return {\n      path: sourceURL\n    };\n  }\n\n  try {\n    buffer = await new Promise((resolve, reject) => {\n      loaderContext.fs.readFile(sourceURL, (error, data) => {\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(data);\n      });\n    });\n  } catch (error) {\n    throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n  }\n\n  return {\n    path: sourceURL,\n    data: buffer.toString()\n  };\n}\n\nasync function fetchPathsFromFilesystem(loaderContext, possibleRequests, errorsAccumulator = \"\") {\n  let result;\n\n  try {\n    result = await fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n  } catch (error) {\n    // eslint-disable-next-line no-param-reassign\n    errorsAccumulator += `${error.message}\\n\\n`;\n    const [, ...tailPossibleRequests] = possibleRequests;\n\n    if (tailPossibleRequests.length === 0) {\n      error.message = errorsAccumulator;\n      throw error;\n    }\n\n    return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n  }\n\n  return result;\n}\n\nfunction isURL(value) {\n  return /^[a-z][a-z0-9+.-]*:/i.test(value) && !_path.default.win32.isAbsolute(value);\n}\n\nasync function fetchFromURL(loaderContext, context, url, sourceRoot, skipReading = false) {\n  // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n  if (isURL(url)) {\n    const {\n      protocol\n    } = _url.default.parse(url);\n\n    if (protocol === \"data:\") {\n      if (skipReading) {\n        return {\n          sourceURL: \"\"\n        };\n      }\n\n      const sourceContent = fetchFromDataURL(loaderContext, url);\n      return {\n        sourceURL: \"\",\n        sourceContent\n      };\n    }\n\n    if (skipReading) {\n      return {\n        sourceURL: url\n      };\n    }\n\n    if (protocol === \"file:\") {\n      const pathFromURL = _url.default.fileURLToPath(url);\n\n      const sourceURL = _path.default.normalize(pathFromURL);\n\n      const {\n        data: sourceContent\n      } = await fetchFromFilesystem(loaderContext, sourceURL);\n      return {\n        sourceURL,\n        sourceContent\n      };\n    }\n\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 2. It's a scheme-relative\n\n\n  if (/^\\/\\//.test(url)) {\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 3. Absolute path\n\n\n  if (_path.default.isAbsolute(url)) {\n    let sourceURL = _path.default.normalize(url);\n\n    let sourceContent;\n\n    if (!skipReading) {\n      const possibleRequests = [sourceURL];\n\n      if (url.startsWith(\"/\")) {\n        possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n      }\n\n      const result = await fetchPathsFromFilesystem(loaderContext, possibleRequests);\n      sourceURL = result.path;\n      sourceContent = result.data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  } // 4. Relative path\n\n\n  const sourceURL = getAbsolutePath(context, url, sourceRoot);\n  let sourceContent;\n\n  if (!skipReading) {\n    const {\n      data\n    } = await fetchFromFilesystem(loaderContext, sourceURL);\n    sourceContent = data;\n  }\n\n  return {\n    sourceURL,\n    sourceContent\n  };\n}"],"mappings":"AAAA,YAAY;;AAAC;AAEbA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,YAAY,GAAGA,YAAY;AACnCF,OAAO,CAACG,gBAAgB,GAAGA,gBAAgB;AAC3CH,OAAO,CAACI,mBAAmB,GAAGA,mBAAmB;AACjDJ,OAAO,CAACK,KAAK,GAAGA,KAAK;AAErB,IAAIC,KAAK,GAAGC,sBAAsB,CAACC,OAAO,CAAC,MAAM,CAAC,CAAC;AAEnD,IAAIC,IAAI,GAAGF,sBAAsB,CAACC,OAAO,CAAC,KAAK,CAAC,CAAC;AAEjD,IAAIE,YAAY,GAAGH,sBAAsB,CAACC,OAAO,CAAC,eAAe,CAAC,CAAC;AAEnE,IAAIG,UAAU,GAAGH,OAAO,CAAC,YAAY,CAAC;AAEtC,IAAII,aAAa,GAAGL,sBAAsB,CAACC,OAAO,CAAC,kBAAkB,CAAC,CAAC;AAEvE,IAAIK,cAAc,GAAGN,sBAAsB,CAACC,OAAO,CAAC,mBAAmB,CAAC,CAAC;AAEzE,SAASD,sBAAsB,CAACO,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAEE,OAAO,EAAEF;EAAI,CAAC;AAAE;;AAE9F;AACA,MAAMG,UAAU,GAAG,gDAAgD;AACnE;;AAEA,MAAMC,qBAAqB,GAAGC,MAAM,CAAC,KAAK,GAAG,MAAM,GAAG,uBAAuB,GAAG,KAAK,GAAGF,UAAU,CAACG,MAAM,GAAG,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,GAAG,GAAG,OAAO,GAAGH,UAAU,CAACG,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC;AAC3L;;AAEA,SAASC,WAAW,CAACC,KAAK,EAAE;EAC1B,MAAMC,cAAc,GAAGC,MAAM,CAACF,KAAK,CAAC,CAACG,IAAI,EAAE,CAACC,WAAW,EAAE;EACzD,OAAOb,cAAc,CAACG,OAAO,CAACO,cAAc,CAAC,IAAI,IAAI;AACvD;AAAC,SAEcpB,gBAAgB;EAAA;AAAA;AAAA;EAAA,sCAA/B,WAAgCwB,GAAG,EAAE;IACnC,MAAMC,QAAQ,SAAS,IAAIlB,YAAY,CAACM,OAAO,CAACa,iBAAiB,CAACF,GAAG,CAAC;IACtE,MAAMG,YAAY,GAAGH,GAAG,CAACI,IAAI,GAAG,IAAIrB,YAAY,CAACM,OAAO,CAACgB,kBAAkB,CAAC;MAC1ED,IAAI,EAAEJ,GAAG,CAACI;IACZ,CAAC,CAAC,GAAG,IAAIrB,YAAY,CAACM,OAAO,CAACgB,kBAAkB,EAAE;IAClDJ,QAAQ,CAACK,OAAO,CAACC,OAAO,CAACC,UAAU,IAAI;MACrC,MAAMC,aAAa,GAAGR,QAAQ,CAACS,gBAAgB,CAACF,UAAU,EAAE,IAAI,CAAC;MACjEL,YAAY,CAACQ,gBAAgB,CAACH,UAAU,EAAEC,aAAa,CAAC;IAC1D,CAAC,CAAC;IACFR,QAAQ,CAACW,WAAW,CAACC,OAAO,IAAI;MAC9B,MAAM;QACJpB;MACF,CAAC,GAAGQ,QAAQ,CAACa,mBAAmB,CAAC;QAC/BC,IAAI,EAAEF,OAAO,CAACG,aAAa;QAC3BC,MAAM,EAAEJ,OAAO,CAACK;MAClB,CAAC,CAAC;MACF,MAAMC,QAAQ,GAAG;QACf1B,MAAM;QACN2B,QAAQ,EAAE;UACRL,IAAI,EAAEF,OAAO,CAACQ,YAAY;UAC1BJ,MAAM,EAAEJ,OAAO,CAACS;QAClB,CAAC;QACDC,SAAS,EAAE;UACTR,IAAI,EAAEF,OAAO,CAACG,aAAa;UAC3BC,MAAM,EAAEJ,OAAO,CAACK;QAClB;MACF,CAAC;MAED,IAAIzB,MAAM,EAAE;QACVU,YAAY,CAACqB,UAAU,CAACL,QAAQ,CAAC;MACnC;IACF,CAAC,CAAC;IACF,OAAOhB,YAAY,CAACsB,MAAM,EAAE;EAC9B,CAAC;EAAA;AAAA;AAED,SAAShD,mBAAmB,CAACiD,IAAI,EAAE;EACjC,MAAMC,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAC,IAAI,CAAC;EAC9B,IAAIC,KAAK;EAET,KAAK,IAAIC,CAAC,GAAGH,KAAK,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1CD,KAAK,GAAGF,KAAK,CAACG,CAAC,CAAC,CAACD,KAAK,CAACtC,qBAAqB,CAAC;IAE7C,IAAIsC,KAAK,EAAE;MACT;IACF;EACF;EAEA,MAAMG,gBAAgB,GAAGH,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,IAAI;EAClE,OAAO;IACLG,gBAAgB,EAAEA,gBAAgB,GAAGC,SAAS,CAACD,gBAAgB,CAAC,GAAGA,gBAAgB;IACnFE,iBAAiB,EAAEL,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG;EACxC,CAAC;AACH;AAEA,SAASM,eAAe,CAACC,OAAO,EAAEC,OAAO,EAAEC,UAAU,EAAE;EACrD,IAAI5D,KAAK,CAAC4D,UAAU,CAAC,EAAE;IACrB,OAAO,IAAIC,GAAG,CAACF,OAAO,EAAEC,UAAU,CAAC,CAACE,QAAQ,EAAE;EAChD;EAEA,IAAIF,UAAU,EAAE;IACd,IAAI3D,KAAK,CAACU,OAAO,CAACoD,UAAU,CAACH,UAAU,CAAC,EAAE;MACxC,OAAO3D,KAAK,CAACU,OAAO,CAACqD,IAAI,CAACJ,UAAU,EAAED,OAAO,CAAC;IAChD;IAEA,OAAO1D,KAAK,CAACU,OAAO,CAACqD,IAAI,CAACN,OAAO,EAAEE,UAAU,EAAED,OAAO,CAAC;EACzD;EAEA,OAAO1D,KAAK,CAACU,OAAO,CAACqD,IAAI,CAACN,OAAO,EAAEC,OAAO,CAAC;AAC7C;AAEA,SAASM,gBAAgB,CAACC,aAAa,EAAEC,SAAS,EAAE;EAClD,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAE7D,aAAa,CAACI,OAAO,EAAEwD,SAAS,CAAC;EAErD,IAAIC,OAAO,EAAE;IACX;IACA;IACA,MAAMC,YAAY,GAAGrD,WAAW,CAACoD,OAAO,CAACE,UAAU,CAACC,GAAG,CAAC,SAAS,CAAC,CAAC,IAAI,OAAO;IAC9E,OAAO,CAAC,CAAC,EAAEjE,UAAU,CAACkE,MAAM,EAAEJ,OAAO,CAACK,IAAI,EAAEJ,YAAY,CAAC;EAC3D;EAEA,MAAM,IAAIK,KAAK,CAAE,+CAA8CP,SAAU,EAAC,CAAC;AAC7E;AAAC,SAEcQ,mBAAmB;EAAA;AAAA;AAAA;EAAA,yCAAlC,WAAmCT,aAAa,EAAEC,SAAS,EAAE;IAC3D,IAAIS,MAAM;IAEV,IAAI5E,KAAK,CAACmE,SAAS,CAAC,EAAE;MACpB,OAAO;QACLU,IAAI,EAAEV;MACR,CAAC;IACH;IAEA,IAAI;MACFS,MAAM,SAAS,IAAIE,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QAC9Cd,aAAa,CAACe,EAAE,CAACC,QAAQ,CAACf,SAAS,EAAE,CAACgB,KAAK,EAAEC,IAAI,KAAK;UACpD,IAAID,KAAK,EAAE;YACT,OAAOH,MAAM,CAACG,KAAK,CAAC;UACtB;UAEA,OAAOJ,OAAO,CAACK,IAAI,CAAC;QACtB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOD,KAAK,EAAE;MACd,MAAM,IAAIT,KAAK,CAAE,oCAAmCP,SAAU,WAAUgB,KAAM,EAAC,CAAC;IAClF;IAEA,OAAO;MACLN,IAAI,EAAEV,SAAS;MACfiB,IAAI,EAAER,MAAM,CAACd,QAAQ;IACvB,CAAC;EACH,CAAC;EAAA;AAAA;AAAA,SAEcuB,wBAAwB;EAAA;AAAA;AAAA;EAAA,8CAAvC,WAAwCnB,aAAa,EAAEoB,gBAAgB,EAAEC,iBAAiB,GAAG,EAAE,EAAE;IAC/F,IAAIC,MAAM;IAEV,IAAI;MACFA,MAAM,SAASb,mBAAmB,CAACT,aAAa,EAAEoB,gBAAgB,CAAC,CAAC,CAAC,EAAEC,iBAAiB,CAAC;IAC3F,CAAC,CAAC,OAAOJ,KAAK,EAAE;MACd;MACAI,iBAAiB,IAAK,GAAEJ,KAAK,CAACM,OAAQ,MAAK;MAC3C,MAAM,GAAG,GAAGC,oBAAoB,CAAC,GAAGJ,gBAAgB;MAEpD,IAAII,oBAAoB,CAACrC,MAAM,KAAK,CAAC,EAAE;QACrC8B,KAAK,CAACM,OAAO,GAAGF,iBAAiB;QACjC,MAAMJ,KAAK;MACb;MAEA,OAAOE,wBAAwB,CAACnB,aAAa,EAAEwB,oBAAoB,EAAEH,iBAAiB,CAAC;IACzF;IAEA,OAAOC,MAAM;EACf,CAAC;EAAA;AAAA;AAED,SAASxF,KAAK,CAACJ,KAAK,EAAE;EACpB,OAAO,sBAAsB,CAAC+F,IAAI,CAAC/F,KAAK,CAAC,IAAI,CAACK,KAAK,CAACU,OAAO,CAACiF,KAAK,CAAC7B,UAAU,CAACnE,KAAK,CAAC;AACrF;AAAC,SAEcC,YAAY;EAAA;AAAA;AAAA;EAAA,kCAA3B,WAA4BqE,aAAa,EAAER,OAAO,EAAEmC,GAAG,EAAEjC,UAAU,EAAEkC,WAAW,GAAG,KAAK,EAAE;IACxF;IACA,IAAI9F,KAAK,CAAC6F,GAAG,CAAC,EAAE;MACd,MAAM;QACJE;MACF,CAAC,GAAG3F,IAAI,CAACO,OAAO,CAACqF,KAAK,CAACH,GAAG,CAAC;MAE3B,IAAIE,QAAQ,KAAK,OAAO,EAAE;QACxB,IAAID,WAAW,EAAE;UACf,OAAO;YACL3B,SAAS,EAAE;UACb,CAAC;QACH;QAEA,MAAMpC,aAAa,GAAGkC,gBAAgB,CAACC,aAAa,EAAE2B,GAAG,CAAC;QAC1D,OAAO;UACL1B,SAAS,EAAE,EAAE;UACbpC;QACF,CAAC;MACH;MAEA,IAAI+D,WAAW,EAAE;QACf,OAAO;UACL3B,SAAS,EAAE0B;QACb,CAAC;MACH;MAEA,IAAIE,QAAQ,KAAK,OAAO,EAAE;QACxB,MAAME,WAAW,GAAG7F,IAAI,CAACO,OAAO,CAACuF,aAAa,CAACL,GAAG,CAAC;QAEnD,MAAM1B,SAAS,GAAGlE,KAAK,CAACU,OAAO,CAACwF,SAAS,CAACF,WAAW,CAAC;QAEtD,MAAM;UACJb,IAAI,EAAErD;QACR,CAAC,SAAS4C,mBAAmB,CAACT,aAAa,EAAEC,SAAS,CAAC;QACvD,OAAO;UACLA,SAAS;UACTpC;QACF,CAAC;MACH;MAEA,MAAM,IAAI2C,KAAK,CAAE,gCAA+BmB,GAAI,wBAAuB,CAAC;IAC9E,CAAC,CAAC;;IAGF,IAAI,OAAO,CAACF,IAAI,CAACE,GAAG,CAAC,EAAE;MACrB,MAAM,IAAInB,KAAK,CAAE,gCAA+BmB,GAAI,wBAAuB,CAAC;IAC9E,CAAC,CAAC;;IAGF,IAAI5F,KAAK,CAACU,OAAO,CAACoD,UAAU,CAAC8B,GAAG,CAAC,EAAE;MACjC,IAAI1B,SAAS,GAAGlE,KAAK,CAACU,OAAO,CAACwF,SAAS,CAACN,GAAG,CAAC;MAE5C,IAAI9D,aAAa;MAEjB,IAAI,CAAC+D,WAAW,EAAE;QAChB,MAAMR,gBAAgB,GAAG,CAACnB,SAAS,CAAC;QAEpC,IAAI0B,GAAG,CAACO,UAAU,CAAC,GAAG,CAAC,EAAE;UACvBd,gBAAgB,CAACe,IAAI,CAAC5C,eAAe,CAACC,OAAO,EAAES,SAAS,CAACmC,KAAK,CAAC,CAAC,CAAC,EAAE1C,UAAU,CAAC,CAAC;QACjF;QAEA,MAAM4B,MAAM,SAASH,wBAAwB,CAACnB,aAAa,EAAEoB,gBAAgB,CAAC;QAC9EnB,SAAS,GAAGqB,MAAM,CAACX,IAAI;QACvB9C,aAAa,GAAGyD,MAAM,CAACJ,IAAI;MAC7B;MAEA,OAAO;QACLjB,SAAS;QACTpC;MACF,CAAC;IACH,CAAC,CAAC;;IAGF,MAAMoC,SAAS,GAAGV,eAAe,CAACC,OAAO,EAAEmC,GAAG,EAAEjC,UAAU,CAAC;IAC3D,IAAI7B,aAAa;IAEjB,IAAI,CAAC+D,WAAW,EAAE;MAChB,MAAM;QACJV;MACF,CAAC,SAAST,mBAAmB,CAACT,aAAa,EAAEC,SAAS,CAAC;MACvDpC,aAAa,GAAGqD,IAAI;IACtB;IAEA,OAAO;MACLjB,SAAS;MACTpC;IACF,CAAC;EACH,CAAC;EAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}