{"ast":null,"code":"\"use strict\";\n\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst zlib = require(\"zlib\");\nconst crypto = require(\"crypto\");\nconst findCacheDir = require(\"find-cache-dir\");\nconst {\n  promisify\n} = require(\"util\");\nconst {\n  readFile,\n  writeFile,\n  mkdir\n} = require(\"fs/promises\");\nconst transform = require(\"./transform\");\n// Lazily instantiated when needed\nlet defaultCacheDirectory = null;\nlet hashType = \"sha256\";\n// use md5 hashing if sha256 is not available\ntry {\n  crypto.createHash(hashType);\n} catch (err) {\n  hashType = \"md5\";\n}\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\n\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n */\nconst read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (filename, compress) {\n    const data = yield readFile(filename + (compress ? \".gz\" : \"\"));\n    const content = compress ? yield gunzip(data) : data;\n    return JSON.parse(content.toString());\n  });\n  return function read(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n * @params {String} result\n */\nconst write = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (filename, compress, result) {\n    const content = JSON.stringify(result);\n    const data = compress ? yield gzip(content) : content;\n    return yield writeFile(filename + (compress ? \".gz\" : \"\"), data);\n  });\n  return function write(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\nconst filename = function (source, identifier, options) {\n  const hash = crypto.createHash(hashType);\n  const contents = JSON.stringify({\n    source,\n    options,\n    identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\nconst handleCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (directory, params) {\n    const {\n      source,\n      options = {},\n      cacheIdentifier,\n      cacheDirectory,\n      cacheCompression\n    } = params;\n    const file = path.join(directory, filename(source, cacheIdentifier, options));\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      return yield read(file, cacheCompression);\n    } catch (err) {}\n    const fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir();\n\n    // Make sure the directory exists.\n    try {\n      // overwrite directory if exists\n      yield mkdir(directory, {\n        recursive: true\n      });\n    } catch (err) {\n      if (fallback) {\n        return handleCache(os.tmpdir(), params);\n      }\n      throw err;\n    }\n\n    // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n    const result = yield transform(source, options);\n\n    // Do not cache if there are external dependencies,\n    // since they might change and we cannot control it.\n    if (!result.externalDependencies.length) {\n      try {\n        yield write(file, cacheCompression, result);\n      } catch (err) {\n        if (fallback) {\n          // Fallback to tmpdir if node_modules folder not writable\n          return handleCache(os.tmpdir(), params);\n        }\n        throw err;\n      }\n    }\n    return result;\n  });\n  return function handleCache(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.cacheDirectory   Directory to store cached files\n * @param  {String}   params.cacheIdentifier  Unique identifier to bust cache\n * @param  {Boolean}  params.cacheCompression Whether compressing cached files\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n *\n * @example\n *\n *   const result = await cache({\n *     cacheDirectory: '.tmp/cache',\n *     cacheIdentifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *   });\n */\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (params) {\n    let directory;\n    if (typeof params.cacheDirectory === \"string\") {\n      directory = params.cacheDirectory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: \"babel-loader\"\n        }) || os.tmpdir();\n      }\n      directory = defaultCacheDirectory;\n    }\n    return yield handleCache(directory, params);\n  });\n  return function (_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["os","require","path","zlib","crypto","findCacheDir","promisify","readFile","writeFile","mkdir","transform","defaultCacheDirectory","hashType","createHash","err","gunzip","gzip","read","filename","compress","data","content","JSON","parse","toString","write","result","stringify","source","identifier","options","hash","contents","update","digest","handleCache","directory","params","cacheIdentifier","cacheDirectory","cacheCompression","file","join","fallback","tmpdir","recursive","externalDependencies","length","module","exports","name"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/babel-loader/lib/cache.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst zlib = require(\"zlib\");\nconst crypto = require(\"crypto\");\nconst findCacheDir = require(\"find-cache-dir\");\nconst {\n  promisify\n} = require(\"util\");\nconst {\n  readFile,\n  writeFile,\n  mkdir\n} = require(\"fs/promises\");\nconst transform = require(\"./transform\");\n// Lazily instantiated when needed\nlet defaultCacheDirectory = null;\nlet hashType = \"sha256\";\n// use md5 hashing if sha256 is not available\ntry {\n  crypto.createHash(hashType);\n} catch (err) {\n  hashType = \"md5\";\n}\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\n\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n */\nconst read = async function (filename, compress) {\n  const data = await readFile(filename + (compress ? \".gz\" : \"\"));\n  const content = compress ? await gunzip(data) : data;\n  return JSON.parse(content.toString());\n};\n\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n * @params {String} result\n */\nconst write = async function (filename, compress, result) {\n  const content = JSON.stringify(result);\n  const data = compress ? await gzip(content) : content;\n  return await writeFile(filename + (compress ? \".gz\" : \"\"), data);\n};\n\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\nconst filename = function (source, identifier, options) {\n  const hash = crypto.createHash(hashType);\n  const contents = JSON.stringify({\n    source,\n    options,\n    identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\nconst handleCache = async function (directory, params) {\n  const {\n    source,\n    options = {},\n    cacheIdentifier,\n    cacheDirectory,\n    cacheCompression\n  } = params;\n  const file = path.join(directory, filename(source, cacheIdentifier, options));\n  try {\n    // No errors mean that the file was previously cached\n    // we just need to return it\n    return await read(file, cacheCompression);\n  } catch (err) {}\n  const fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir();\n\n  // Make sure the directory exists.\n  try {\n    // overwrite directory if exists\n    await mkdir(directory, {\n      recursive: true\n    });\n  } catch (err) {\n    if (fallback) {\n      return handleCache(os.tmpdir(), params);\n    }\n    throw err;\n  }\n\n  // Otherwise just transform the file\n  // return it to the user asap and write it in cache\n  const result = await transform(source, options);\n\n  // Do not cache if there are external dependencies,\n  // since they might change and we cannot control it.\n  if (!result.externalDependencies.length) {\n    try {\n      await write(file, cacheCompression, result);\n    } catch (err) {\n      if (fallback) {\n        // Fallback to tmpdir if node_modules folder not writable\n        return handleCache(os.tmpdir(), params);\n      }\n      throw err;\n    }\n  }\n  return result;\n};\n\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.cacheDirectory   Directory to store cached files\n * @param  {String}   params.cacheIdentifier  Unique identifier to bust cache\n * @param  {Boolean}  params.cacheCompression Whether compressing cached files\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n *\n * @example\n *\n *   const result = await cache({\n *     cacheDirectory: '.tmp/cache',\n *     cacheIdentifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *   });\n */\n\nmodule.exports = async function (params) {\n  let directory;\n  if (typeof params.cacheDirectory === \"string\") {\n    directory = params.cacheDirectory;\n  } else {\n    if (defaultCacheDirectory === null) {\n      defaultCacheDirectory = findCacheDir({\n        name: \"babel-loader\"\n      }) || os.tmpdir();\n    }\n    directory = defaultCacheDirectory;\n  }\n  return await handleCache(directory, params);\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}