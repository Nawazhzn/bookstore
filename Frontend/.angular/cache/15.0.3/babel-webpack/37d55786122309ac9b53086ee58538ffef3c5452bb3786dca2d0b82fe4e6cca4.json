{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseDataUrl;\nvar _abab = require(\"abab\");\nconst removeLeadingAndTrailingHTTPWhitespace = string => string.replace(/^[ \\t\\n\\r]+/, \"\").replace(/[ \\t\\n\\r]+$/, \"\");\nconst removeTrailingHTTPWhitespace = string => string.replace(/[ \\t\\n\\r]+$/, \"\");\nconst isHTTPWhitespaceChar = char => char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\nconst solelyContainsHTTPTokenCodePoints = string => /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/.test(string);\nconst soleyContainsHTTPQuotedStringTokenCodePoints = string => /^[\\t\\u0020-\\u007E\\u0080-\\u00FF]*$/.test(string);\nconst asciiLowercase = string => string.replace(/[A-Z]/g, l => l.toLowerCase());\nconst collectAnHTTPQuotedString = (input, position) => {\n  let value = \"\"; // eslint-disable-next-line no-param-reassign\n\n  position += 1; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    while (position < input.length && input[position] !== '\"' && input[position] !== \"\\\\\") {\n      value += input[position]; // eslint-disable-next-line no-param-reassign\n\n      position += 1;\n    }\n    if (position >= input.length) {\n      break;\n    }\n    const quoteOrBackslash = input[position]; // eslint-disable-next-line no-param-reassign\n\n    position += 1;\n    if (quoteOrBackslash === \"\\\\\") {\n      if (position >= input.length) {\n        value += \"\\\\\";\n        break;\n      }\n      value += input[position]; // eslint-disable-next-line no-param-reassign\n\n      position += 1;\n    } else {\n      break;\n    }\n  }\n  return [value, position];\n};\nfunction isASCIIHex(c) {\n  return c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;\n}\nfunction percentDecodeBytes(input) {\n  const output = new Uint8Array(input.byteLength);\n  let outputIndex = 0;\n  for (let i = 0; i < input.byteLength; ++i) {\n    const byte = input[i];\n    if (byte !== 0x25) {\n      output[outputIndex] = byte;\n    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {\n      output[outputIndex] = byte;\n    } else {\n      output[outputIndex] = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);\n      i += 2;\n    }\n    outputIndex += 1;\n  }\n  return output.slice(0, outputIndex);\n}\nfunction parseDataUrl(stringInput) {\n  let parsedUrl;\n  try {\n    parsedUrl = new URL(stringInput);\n  } catch (error) {\n    return null;\n  }\n  if (parsedUrl.protocol !== \"data:\") {\n    return null;\n  }\n  parsedUrl.hash = \"\"; // `5` is value of `'data:'.length`\n\n  const input = parsedUrl.toString().substring(5);\n  let position = 0;\n  let mediaType = \"\";\n  while (position < input.length && input[position] !== \",\") {\n    mediaType += input[position];\n    position += 1;\n  }\n  mediaType = mediaType.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n  if (position === input.length) {\n    return null;\n  }\n  position += 1;\n  const encodedBody = input.substring(position);\n  let body = Buffer.from(percentDecodeBytes(Buffer.from(encodedBody, \"utf-8\"))); // Can't use /i regexp flag because it isn't restricted to ASCII.\n\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mediaType);\n  if (mimeTypeBase64MatchResult) {\n    const stringBody = body.toString(\"binary\");\n    const asString = (0, _abab.atob)(stringBody);\n    if (asString === null) {\n      return null;\n    }\n    body = Buffer.from(asString, \"binary\");\n    [, mediaType] = mimeTypeBase64MatchResult;\n  }\n  if (mediaType.startsWith(\";\")) {\n    mediaType = `text/plain ${mediaType}`;\n  }\n  const result = {\n    // eslint-disable-next-line no-undefined\n    type: undefined,\n    // eslint-disable-next-line no-undefined\n    subtype: undefined,\n    parameters: new Map(),\n    isBase64: Boolean(mimeTypeBase64MatchResult),\n    body\n  };\n  if (!mediaType) {\n    return result;\n  }\n  const inputMediaType = removeLeadingAndTrailingHTTPWhitespace(mediaType);\n  let positionMediaType = 0;\n  let type = \"\";\n  while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \"/\") {\n    type += inputMediaType[positionMediaType];\n    positionMediaType += 1;\n  }\n  if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {\n    return result;\n  }\n  if (positionMediaType >= inputMediaType.length) {\n    return result;\n  } // Skips past \"/\"\n\n  positionMediaType += 1;\n  let subtype = \"\";\n  while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\") {\n    subtype += inputMediaType[positionMediaType];\n    positionMediaType += 1;\n  }\n  subtype = removeTrailingHTTPWhitespace(subtype);\n  if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {\n    return result;\n  }\n  result.type = asciiLowercase(type);\n  result.subtype = asciiLowercase(subtype);\n  while (positionMediaType < inputMediaType.length) {\n    // Skip past \";\"\n    positionMediaType += 1;\n    while (isHTTPWhitespaceChar(inputMediaType[positionMediaType])) {\n      positionMediaType += 1;\n    }\n    let parameterName = \"\";\n    while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\" && inputMediaType[positionMediaType] !== \"=\") {\n      parameterName += inputMediaType[positionMediaType];\n      positionMediaType += 1;\n    }\n    parameterName = asciiLowercase(parameterName);\n    if (positionMediaType < inputMediaType.length) {\n      if (inputMediaType[positionMediaType] === \";\") {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // Skip past \"=\"\n\n      positionMediaType += 1;\n    }\n    let parameterValue = \"\";\n    if (inputMediaType[positionMediaType] === '\"') {\n      [parameterValue, positionMediaType] = collectAnHTTPQuotedString(inputMediaType, positionMediaType);\n      while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\") {\n        positionMediaType += 1;\n      }\n    } else {\n      while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\") {\n        parameterValue += inputMediaType[positionMediaType];\n        positionMediaType += 1;\n      }\n      parameterValue = removeTrailingHTTPWhitespace(parameterValue);\n      if (parameterValue === \"\") {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !result.parameters.has(parameterName)) {\n      result.parameters.set(parameterName, parameterValue);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","parseDataUrl","_abab","require","removeLeadingAndTrailingHTTPWhitespace","string","replace","removeTrailingHTTPWhitespace","isHTTPWhitespaceChar","char","solelyContainsHTTPTokenCodePoints","test","soleyContainsHTTPQuotedStringTokenCodePoints","asciiLowercase","l","toLowerCase","collectAnHTTPQuotedString","input","position","length","quoteOrBackslash","isASCIIHex","c","percentDecodeBytes","output","Uint8Array","byteLength","outputIndex","i","byte","parseInt","String","fromCodePoint","slice","stringInput","parsedUrl","URL","error","protocol","hash","toString","substring","mediaType","encodedBody","body","Buffer","from","mimeTypeBase64MatchResult","exec","stringBody","asString","atob","startsWith","result","type","undefined","subtype","parameters","Map","isBase64","Boolean","inputMediaType","positionMediaType","parameterName","parameterValue","has","set"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/source-map-loader/dist/parse-data-url.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseDataUrl;\n\nvar _abab = require(\"abab\");\n\nconst removeLeadingAndTrailingHTTPWhitespace = string => string.replace(/^[ \\t\\n\\r]+/, \"\").replace(/[ \\t\\n\\r]+$/, \"\");\n\nconst removeTrailingHTTPWhitespace = string => string.replace(/[ \\t\\n\\r]+$/, \"\");\n\nconst isHTTPWhitespaceChar = char => char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n\nconst solelyContainsHTTPTokenCodePoints = string => /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/.test(string);\n\nconst soleyContainsHTTPQuotedStringTokenCodePoints = string => /^[\\t\\u0020-\\u007E\\u0080-\\u00FF]*$/.test(string);\n\nconst asciiLowercase = string => string.replace(/[A-Z]/g, l => l.toLowerCase());\n\nconst collectAnHTTPQuotedString = (input, position) => {\n  let value = \"\"; // eslint-disable-next-line no-param-reassign\n\n  position += 1; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    while (position < input.length && input[position] !== '\"' && input[position] !== \"\\\\\") {\n      value += input[position]; // eslint-disable-next-line no-param-reassign\n\n      position += 1;\n    }\n\n    if (position >= input.length) {\n      break;\n    }\n\n    const quoteOrBackslash = input[position]; // eslint-disable-next-line no-param-reassign\n\n    position += 1;\n\n    if (quoteOrBackslash === \"\\\\\") {\n      if (position >= input.length) {\n        value += \"\\\\\";\n        break;\n      }\n\n      value += input[position]; // eslint-disable-next-line no-param-reassign\n\n      position += 1;\n    } else {\n      break;\n    }\n  }\n\n  return [value, position];\n};\n\nfunction isASCIIHex(c) {\n  return c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;\n}\n\nfunction percentDecodeBytes(input) {\n  const output = new Uint8Array(input.byteLength);\n  let outputIndex = 0;\n\n  for (let i = 0; i < input.byteLength; ++i) {\n    const byte = input[i];\n\n    if (byte !== 0x25) {\n      output[outputIndex] = byte;\n    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {\n      output[outputIndex] = byte;\n    } else {\n      output[outputIndex] = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);\n      i += 2;\n    }\n\n    outputIndex += 1;\n  }\n\n  return output.slice(0, outputIndex);\n}\n\nfunction parseDataUrl(stringInput) {\n  let parsedUrl;\n\n  try {\n    parsedUrl = new URL(stringInput);\n  } catch (error) {\n    return null;\n  }\n\n  if (parsedUrl.protocol !== \"data:\") {\n    return null;\n  }\n\n  parsedUrl.hash = \"\"; // `5` is value of `'data:'.length`\n\n  const input = parsedUrl.toString().substring(5);\n  let position = 0;\n  let mediaType = \"\";\n\n  while (position < input.length && input[position] !== \",\") {\n    mediaType += input[position];\n    position += 1;\n  }\n\n  mediaType = mediaType.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n\n  if (position === input.length) {\n    return null;\n  }\n\n  position += 1;\n  const encodedBody = input.substring(position);\n  let body = Buffer.from(percentDecodeBytes(Buffer.from(encodedBody, \"utf-8\"))); // Can't use /i regexp flag because it isn't restricted to ASCII.\n\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mediaType);\n\n  if (mimeTypeBase64MatchResult) {\n    const stringBody = body.toString(\"binary\");\n    const asString = (0, _abab.atob)(stringBody);\n\n    if (asString === null) {\n      return null;\n    }\n\n    body = Buffer.from(asString, \"binary\");\n    [, mediaType] = mimeTypeBase64MatchResult;\n  }\n\n  if (mediaType.startsWith(\";\")) {\n    mediaType = `text/plain ${mediaType}`;\n  }\n\n  const result = {\n    // eslint-disable-next-line no-undefined\n    type: undefined,\n    // eslint-disable-next-line no-undefined\n    subtype: undefined,\n    parameters: new Map(),\n    isBase64: Boolean(mimeTypeBase64MatchResult),\n    body\n  };\n\n  if (!mediaType) {\n    return result;\n  }\n\n  const inputMediaType = removeLeadingAndTrailingHTTPWhitespace(mediaType);\n  let positionMediaType = 0;\n  let type = \"\";\n\n  while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \"/\") {\n    type += inputMediaType[positionMediaType];\n    positionMediaType += 1;\n  }\n\n  if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {\n    return result;\n  }\n\n  if (positionMediaType >= inputMediaType.length) {\n    return result;\n  } // Skips past \"/\"\n\n\n  positionMediaType += 1;\n  let subtype = \"\";\n\n  while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\") {\n    subtype += inputMediaType[positionMediaType];\n    positionMediaType += 1;\n  }\n\n  subtype = removeTrailingHTTPWhitespace(subtype);\n\n  if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {\n    return result;\n  }\n\n  result.type = asciiLowercase(type);\n  result.subtype = asciiLowercase(subtype);\n\n  while (positionMediaType < inputMediaType.length) {\n    // Skip past \";\"\n    positionMediaType += 1;\n\n    while (isHTTPWhitespaceChar(inputMediaType[positionMediaType])) {\n      positionMediaType += 1;\n    }\n\n    let parameterName = \"\";\n\n    while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\" && inputMediaType[positionMediaType] !== \"=\") {\n      parameterName += inputMediaType[positionMediaType];\n      positionMediaType += 1;\n    }\n\n    parameterName = asciiLowercase(parameterName);\n\n    if (positionMediaType < inputMediaType.length) {\n      if (inputMediaType[positionMediaType] === \";\") {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // Skip past \"=\"\n\n\n      positionMediaType += 1;\n    }\n\n    let parameterValue = \"\";\n\n    if (inputMediaType[positionMediaType] === '\"') {\n      [parameterValue, positionMediaType] = collectAnHTTPQuotedString(inputMediaType, positionMediaType);\n\n      while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\") {\n        positionMediaType += 1;\n      }\n    } else {\n      while (positionMediaType < inputMediaType.length && inputMediaType[positionMediaType] !== \";\") {\n        parameterValue += inputMediaType[positionMediaType];\n        positionMediaType += 1;\n      }\n\n      parameterValue = removeTrailingHTTPWhitespace(parameterValue);\n\n      if (parameterValue === \"\") {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n\n    if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !result.parameters.has(parameterName)) {\n      result.parameters.set(parameterName, parameterValue);\n    }\n  }\n\n  return result;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}