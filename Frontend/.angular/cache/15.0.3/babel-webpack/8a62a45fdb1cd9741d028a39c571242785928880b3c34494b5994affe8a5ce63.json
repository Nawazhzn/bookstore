{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst {\n  transformSync\n} = require('@babel/core');\nconst {\n  defaults\n} = require('@istanbuljs/schema');\nconst programVisitor = require('./visitor');\nconst readInitialCoverage = require('./read-coverage');\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output.\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on.\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n */\nclass Instrumenter {\n  constructor(opts = {}) {\n    this.opts = {\n      ...defaults.instrumenter,\n      ...opts\n    };\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n    filename = filename || String(new Date().getTime()) + '.js';\n    const {\n      opts\n    } = this;\n    let output = {};\n    const babelOpts = {\n      configFile: false,\n      babelrc: false,\n      ast: true,\n      filename: filename || String(new Date().getTime()) + '.js',\n      inputSourceMap,\n      sourceMaps: opts.produceSourceMap,\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      parserOpts: {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? 'module' : 'script',\n        plugins: opts.parserPlugins\n      },\n      plugins: [[({\n        types\n      }) => {\n        const ee = programVisitor(types, filename, {\n          coverageVariable: opts.coverageVariable,\n          reportLogic: opts.reportLogic,\n          coverageGlobalScope: opts.coverageGlobalScope,\n          coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n          ignoreClassMethods: opts.ignoreClassMethods,\n          inputSourceMap\n        });\n        return {\n          visitor: {\n            Program: {\n              enter: ee.enter,\n              exit(path) {\n                output = ee.exit(path);\n              }\n            }\n          }\n        };\n      }]]\n    };\n    const codeMap = transformSync(code, babelOpts);\n    if (!output || !output.fileCoverage) {\n      const initialCoverage = readInitialCoverage(codeMap.ast) || /* istanbul ignore next: paranoid check */{};\n      this.fileCoverage = initialCoverage.coverageData;\n      this.sourceMap = inputSourceMap;\n      return code;\n    }\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n}\nmodule.exports = Instrumenter;","map":{"version":3,"names":["transformSync","require","defaults","programVisitor","readInitialCoverage","Instrumenter","constructor","opts","instrumenter","fileCoverage","sourceMap","instrumentSync","code","filename","inputSourceMap","Error","String","Date","getTime","output","babelOpts","configFile","babelrc","ast","sourceMaps","produceSourceMap","compact","comments","preserveComments","parserOpts","allowReturnOutsideFunction","autoWrap","sourceType","esModules","plugins","parserPlugins","types","ee","coverageVariable","reportLogic","coverageGlobalScope","coverageGlobalScopeFunc","ignoreClassMethods","visitor","Program","enter","exit","path","codeMap","initialCoverage","coverageData","map","cb","sourceMapUrlCallback","sourceMappingURL","instrument","callback","out","ex","lastFileCoverage","lastSourceMap","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/istanbul-lib-instrument/src/instrumenter.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst { transformSync } = require('@babel/core');\nconst { defaults } = require('@istanbuljs/schema');\nconst programVisitor = require('./visitor');\nconst readInitialCoverage = require('./read-coverage');\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output.\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on.\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n */\nclass Instrumenter {\n    constructor(opts = {}) {\n        this.opts = {\n            ...defaults.instrumenter,\n            ...opts\n        };\n        this.fileCoverage = null;\n        this.sourceMap = null;\n    }\n    /**\n     * instrument the supplied code and track coverage against the supplied\n     * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n     * is supported. To instrument ES6 modules, make sure that you set the\n     * `esModules` property to `true` when creating the instrumenter.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     * @returns {string} the instrumented code.\n     */\n    instrumentSync(code, filename, inputSourceMap) {\n        if (typeof code !== 'string') {\n            throw new Error('Code must be a string');\n        }\n        filename = filename || String(new Date().getTime()) + '.js';\n        const { opts } = this;\n        let output = {};\n        const babelOpts = {\n            configFile: false,\n            babelrc: false,\n            ast: true,\n            filename: filename || String(new Date().getTime()) + '.js',\n            inputSourceMap,\n            sourceMaps: opts.produceSourceMap,\n            compact: opts.compact,\n            comments: opts.preserveComments,\n            parserOpts: {\n                allowReturnOutsideFunction: opts.autoWrap,\n                sourceType: opts.esModules ? 'module' : 'script',\n                plugins: opts.parserPlugins\n            },\n            plugins: [\n                [\n                    ({ types }) => {\n                        const ee = programVisitor(types, filename, {\n                            coverageVariable: opts.coverageVariable,\n                            reportLogic: opts.reportLogic,\n                            coverageGlobalScope: opts.coverageGlobalScope,\n                            coverageGlobalScopeFunc:\n                                opts.coverageGlobalScopeFunc,\n                            ignoreClassMethods: opts.ignoreClassMethods,\n                            inputSourceMap\n                        });\n\n                        return {\n                            visitor: {\n                                Program: {\n                                    enter: ee.enter,\n                                    exit(path) {\n                                        output = ee.exit(path);\n                                    }\n                                }\n                            }\n                        };\n                    }\n                ]\n            ]\n        };\n\n        const codeMap = transformSync(code, babelOpts);\n\n        if (!output || !output.fileCoverage) {\n            const initialCoverage =\n                readInitialCoverage(codeMap.ast) ||\n                /* istanbul ignore next: paranoid check */ {};\n            this.fileCoverage = initialCoverage.coverageData;\n            this.sourceMap = inputSourceMap;\n            return code;\n        }\n\n        this.fileCoverage = output.fileCoverage;\n        this.sourceMap = codeMap.map;\n        const cb = this.opts.sourceMapUrlCallback;\n        if (cb && output.sourceMappingURL) {\n            cb(filename, output.sourceMappingURL);\n        }\n\n        return codeMap.code;\n    }\n    /**\n     * callback-style instrument method that calls back with an error\n     * as opposed to throwing one. Note that in the current implementation,\n     * the callback will be called in the same process tick and is not asynchronous.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {Function} callback - the callback\n     * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     */\n    instrument(code, filename, callback, inputSourceMap) {\n        if (!callback && typeof filename === 'function') {\n            callback = filename;\n            filename = null;\n        }\n        try {\n            const out = this.instrumentSync(code, filename, inputSourceMap);\n            callback(null, out);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n    /**\n     * returns the file coverage object for the last file instrumented.\n     * @returns {Object} the file coverage object.\n     */\n    lastFileCoverage() {\n        return this.fileCoverage;\n    }\n    /**\n     * returns the source map produced for the last file instrumented.\n     * @returns {null|Object} the source map object.\n     */\n    lastSourceMap() {\n        return this.sourceMap;\n    }\n}\n\nmodule.exports = Instrumenter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}