{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getKeywords = void 0;\nconst core_1 = require(\"@babel/core\");\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * The name of the Typescript decorator helper function created by the TypeScript compiler.\n */\nconst TSLIB_DECORATE_HELPER_NAME = '__decorate';\n/**\n * The set of Angular static fields that should always be wrapped.\n * These fields may appear to have side effects but are safe to remove if the associated class\n * is otherwise unused within the output.\n */\nconst angularStaticsToWrap = new Set(['ɵcmp', 'ɵdir', 'ɵfac', 'ɵinj', 'ɵmod', 'ɵpipe', 'ɵprov', 'INJECTOR_KEY']);\n/**\n * An object map of static fields and related value checks for discovery of Angular generated\n * JIT related static fields.\n */\nconst angularStaticsToElide = {\n  'ctorParameters'(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression();\n  },\n  'decorators'(path) {\n    return path.isArrayExpression();\n  },\n  'propDecorators'(path) {\n    return path.isObjectExpression();\n  }\n};\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\nfunction getKeywords() {\n  return ['class'];\n}\nexports.getKeywords = getKeywords;\n/**\n * Determines whether a property and its initializer value can be safely wrapped in a pure\n * annotated IIFE. Values that may cause side effects are not considered safe to wrap.\n * Wrapping such values may cause runtime errors and/or incorrect runtime behavior.\n *\n * @param propertyName The name of the property to analyze.\n * @param assignmentValue The initializer value that will be assigned to the property.\n * @returns If the property can be safely wrapped, then true; otherwise, false.\n */\nfunction canWrapProperty(propertyName, assignmentValue) {\n  if (angularStaticsToWrap.has(propertyName)) {\n    return true;\n  }\n  const {\n    leadingComments\n  } = assignmentValue.node;\n  if (leadingComments === null || leadingComments === void 0 ? void 0 : leadingComments.some(\n  // `@pureOrBreakMyCode` is used by closure and is present in Angular code\n  ({\n    value\n  }) => value.includes('@__PURE__') || value.includes('#__PURE__') || value.includes('@pureOrBreakMyCode'))) {\n    return true;\n  }\n  return assignmentValue.isPure();\n}\n/**\n * Analyze the sibling nodes of a class to determine if any downlevel elements should be\n * wrapped in a pure annotated IIFE. Also determines if any elements have potential side\n * effects.\n *\n * @param origin The starting NodePath location for analyzing siblings.\n * @param classIdentifier The identifier node that represents the name of the class.\n * @param allowWrappingDecorators Whether to allow decorators to be wrapped.\n * @returns An object containing the results of the analysis.\n */\nfunction analyzeClassSiblings(origin, classIdentifier, allowWrappingDecorators) {\n  var _a;\n  const wrapStatementPaths = [];\n  let hasPotentialSideEffects = false;\n  for (let i = 1;; ++i) {\n    const nextStatement = origin.getSibling(+origin.key + i);\n    if (!nextStatement.isExpressionStatement()) {\n      break;\n    }\n    // Valid sibling statements for class declarations are only assignment expressions\n    // and TypeScript decorator helper call expressions\n    const nextExpression = nextStatement.get('expression');\n    if (nextExpression.isCallExpression()) {\n      if (!core_1.types.isIdentifier(nextExpression.node.callee) || nextExpression.node.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n        break;\n      }\n      if (allowWrappingDecorators) {\n        wrapStatementPaths.push(nextStatement);\n      } else {\n        // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n        // The statement will prevent even a wrapped class from being optimized away.\n        hasPotentialSideEffects = true;\n      }\n      continue;\n    } else if (!nextExpression.isAssignmentExpression()) {\n      break;\n    }\n    // Valid assignment expressions should be member access expressions using the class\n    // name as the object and an identifier as the property for static fields or only\n    // the class name for decorators.\n    const left = nextExpression.get('left');\n    if (left.isIdentifier()) {\n      if (!left.scope.bindingIdentifierEquals(left.node.name, classIdentifier) || !core_1.types.isCallExpression(nextExpression.node.right) || !core_1.types.isIdentifier(nextExpression.node.right.callee) || nextExpression.node.right.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n        break;\n      }\n      if (allowWrappingDecorators) {\n        wrapStatementPaths.push(nextStatement);\n      } else {\n        // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n        // The statement will prevent even a wrapped class from being optimized away.\n        hasPotentialSideEffects = true;\n      }\n      continue;\n    } else if (!left.isMemberExpression() || !core_1.types.isIdentifier(left.node.object) || !left.scope.bindingIdentifierEquals(left.node.object.name, classIdentifier) || !core_1.types.isIdentifier(left.node.property)) {\n      break;\n    }\n    const propertyName = left.node.property.name;\n    const assignmentValue = nextExpression.get('right');\n    if ((_a = angularStaticsToElide[propertyName]) === null || _a === void 0 ? void 0 : _a.call(angularStaticsToElide, assignmentValue)) {\n      nextStatement.remove();\n      --i;\n    } else if (canWrapProperty(propertyName, assignmentValue)) {\n      wrapStatementPaths.push(nextStatement);\n    } else {\n      // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n      // The statement will prevent even a wrapped class from being optimized away.\n      hasPotentialSideEffects = true;\n    }\n  }\n  return {\n    hasPotentialSideEffects,\n    wrapStatementPaths\n  };\n}\n/**\n * The set of classed already visited and analyzed during the plugin's execution.\n * This is used to prevent adjusted classes from being repeatedly analyzed which can lead\n * to an infinite loop.\n */\nconst visitedClasses = new WeakSet();\n/**\n * A babel plugin factory function for adjusting classes; primarily with Angular metadata.\n * The adjustments include wrapping classes with known safe or no side effects with pure\n * annotations to support dead code removal of unused classes. Angular compiler generated\n * metadata static fields not required in AOT mode are also elided to better support bundler-\n * level treeshaking.\n *\n * @returns A babel plugin object instance.\n */\nfunction default_1() {\n  return {\n    visitor: {\n      ClassDeclaration(path, state) {\n        const {\n          node: classNode,\n          parentPath\n        } = path;\n        const {\n          wrapDecorators\n        } = state.opts;\n        if (visitedClasses.has(classNode)) {\n          return;\n        }\n        // Analyze sibling statements for elements of the class that were downleveled\n        const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n        const origin = hasExport ? parentPath : path;\n        const {\n          wrapStatementPaths,\n          hasPotentialSideEffects\n        } = analyzeClassSiblings(origin, classNode.id, wrapDecorators);\n        visitedClasses.add(classNode);\n        if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n          return;\n        }\n        const wrapStatementNodes = [];\n        for (const statementPath of wrapStatementPaths) {\n          wrapStatementNodes.push(statementPath.node);\n          statementPath.remove();\n        }\n        // Wrap class and safe static assignments in a pure annotated IIFE\n        const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([classNode, ...wrapStatementNodes, core_1.types.returnStatement(core_1.types.cloneNode(classNode.id))]));\n        const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n        (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n        // Replace class with IIFE wrapped class\n        const declaration = core_1.types.variableDeclaration('let', [core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), replacementInitializer)]);\n        if (parentPath.isExportDefaultDeclaration()) {\n          // When converted to a variable declaration, the default export must be moved\n          // to a subsequent statement to prevent a JavaScript syntax error.\n          parentPath.replaceWithMultiple([declaration, core_1.types.exportNamedDeclaration(undefined, [core_1.types.exportSpecifier(core_1.types.cloneNode(classNode.id), core_1.types.identifier('default'))])]);\n        } else {\n          path.replaceWith(declaration);\n        }\n      },\n      ClassExpression(path, state) {\n        const {\n          node: classNode,\n          parentPath\n        } = path;\n        const {\n          wrapDecorators\n        } = state.opts;\n        // Class expressions are used by TypeScript to represent downlevel class/constructor decorators.\n        // If not wrapping decorators, they do not need to be processed.\n        if (!wrapDecorators || visitedClasses.has(classNode)) {\n          return;\n        }\n        if (!classNode.id || !parentPath.isVariableDeclarator() || !core_1.types.isIdentifier(parentPath.node.id) || parentPath.node.id.name !== classNode.id.name) {\n          return;\n        }\n        const origin = parentPath.parentPath;\n        if (!origin.isVariableDeclaration() || origin.node.declarations.length !== 1) {\n          return;\n        }\n        const {\n          wrapStatementPaths,\n          hasPotentialSideEffects\n        } = analyzeClassSiblings(origin, parentPath.node.id, wrapDecorators);\n        visitedClasses.add(classNode);\n        if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n          return;\n        }\n        const wrapStatementNodes = [];\n        for (const statementPath of wrapStatementPaths) {\n          wrapStatementNodes.push(statementPath.node);\n          statementPath.remove();\n        }\n        // Wrap class and safe static assignments in a pure annotated IIFE\n        const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([core_1.types.variableDeclaration('let', [core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), classNode)]), ...wrapStatementNodes, core_1.types.returnStatement(core_1.types.cloneNode(classNode.id))]));\n        const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n        (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n        // Add the wrapped class directly to the variable declaration\n        parentPath.get('init').replaceWith(replacementInitializer);\n      }\n    }\n  };\n}\nexports.default = default_1;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getKeywords","core_1","require","helper_annotate_as_pure_1","TSLIB_DECORATE_HELPER_NAME","angularStaticsToWrap","Set","angularStaticsToElide","path","isFunctionExpression","isArrowFunctionExpression","isArrayExpression","isObjectExpression","canWrapProperty","propertyName","assignmentValue","has","leadingComments","node","some","includes","isPure","analyzeClassSiblings","origin","classIdentifier","allowWrappingDecorators","_a","wrapStatementPaths","hasPotentialSideEffects","i","nextStatement","getSibling","key","isExpressionStatement","nextExpression","get","isCallExpression","types","isIdentifier","callee","name","push","isAssignmentExpression","left","scope","bindingIdentifierEquals","right","isMemberExpression","object","property","call","remove","visitedClasses","WeakSet","default_1","visitor","ClassDeclaration","state","classNode","parentPath","wrapDecorators","opts","hasExport","isExportNamedDeclaration","isExportDefaultDeclaration","id","add","length","wrapStatementNodes","statementPath","container","arrowFunctionExpression","blockStatement","returnStatement","cloneNode","replacementInitializer","callExpression","parenthesizedExpression","default","declaration","variableDeclaration","variableDeclarator","replaceWithMultiple","exportNamedDeclaration","undefined","exportSpecifier","identifier","replaceWith","ClassExpression","isVariableDeclarator","isVariableDeclaration","declarations"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@angular-devkit/build-angular/src/babel/plugins/adjust-static-class-members.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getKeywords = void 0;\nconst core_1 = require(\"@babel/core\");\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * The name of the Typescript decorator helper function created by the TypeScript compiler.\n */\nconst TSLIB_DECORATE_HELPER_NAME = '__decorate';\n/**\n * The set of Angular static fields that should always be wrapped.\n * These fields may appear to have side effects but are safe to remove if the associated class\n * is otherwise unused within the output.\n */\nconst angularStaticsToWrap = new Set([\n    'ɵcmp',\n    'ɵdir',\n    'ɵfac',\n    'ɵinj',\n    'ɵmod',\n    'ɵpipe',\n    'ɵprov',\n    'INJECTOR_KEY',\n]);\n/**\n * An object map of static fields and related value checks for discovery of Angular generated\n * JIT related static fields.\n */\nconst angularStaticsToElide = {\n    'ctorParameters'(path) {\n        return path.isFunctionExpression() || path.isArrowFunctionExpression();\n    },\n    'decorators'(path) {\n        return path.isArrayExpression();\n    },\n    'propDecorators'(path) {\n        return path.isObjectExpression();\n    },\n};\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\nfunction getKeywords() {\n    return ['class'];\n}\nexports.getKeywords = getKeywords;\n/**\n * Determines whether a property and its initializer value can be safely wrapped in a pure\n * annotated IIFE. Values that may cause side effects are not considered safe to wrap.\n * Wrapping such values may cause runtime errors and/or incorrect runtime behavior.\n *\n * @param propertyName The name of the property to analyze.\n * @param assignmentValue The initializer value that will be assigned to the property.\n * @returns If the property can be safely wrapped, then true; otherwise, false.\n */\nfunction canWrapProperty(propertyName, assignmentValue) {\n    if (angularStaticsToWrap.has(propertyName)) {\n        return true;\n    }\n    const { leadingComments } = assignmentValue.node;\n    if (leadingComments === null || leadingComments === void 0 ? void 0 : leadingComments.some(\n    // `@pureOrBreakMyCode` is used by closure and is present in Angular code\n    ({ value }) => value.includes('@__PURE__') ||\n        value.includes('#__PURE__') ||\n        value.includes('@pureOrBreakMyCode'))) {\n        return true;\n    }\n    return assignmentValue.isPure();\n}\n/**\n * Analyze the sibling nodes of a class to determine if any downlevel elements should be\n * wrapped in a pure annotated IIFE. Also determines if any elements have potential side\n * effects.\n *\n * @param origin The starting NodePath location for analyzing siblings.\n * @param classIdentifier The identifier node that represents the name of the class.\n * @param allowWrappingDecorators Whether to allow decorators to be wrapped.\n * @returns An object containing the results of the analysis.\n */\nfunction analyzeClassSiblings(origin, classIdentifier, allowWrappingDecorators) {\n    var _a;\n    const wrapStatementPaths = [];\n    let hasPotentialSideEffects = false;\n    for (let i = 1;; ++i) {\n        const nextStatement = origin.getSibling(+origin.key + i);\n        if (!nextStatement.isExpressionStatement()) {\n            break;\n        }\n        // Valid sibling statements for class declarations are only assignment expressions\n        // and TypeScript decorator helper call expressions\n        const nextExpression = nextStatement.get('expression');\n        if (nextExpression.isCallExpression()) {\n            if (!core_1.types.isIdentifier(nextExpression.node.callee) ||\n                nextExpression.node.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n                break;\n            }\n            if (allowWrappingDecorators) {\n                wrapStatementPaths.push(nextStatement);\n            }\n            else {\n                // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n                // The statement will prevent even a wrapped class from being optimized away.\n                hasPotentialSideEffects = true;\n            }\n            continue;\n        }\n        else if (!nextExpression.isAssignmentExpression()) {\n            break;\n        }\n        // Valid assignment expressions should be member access expressions using the class\n        // name as the object and an identifier as the property for static fields or only\n        // the class name for decorators.\n        const left = nextExpression.get('left');\n        if (left.isIdentifier()) {\n            if (!left.scope.bindingIdentifierEquals(left.node.name, classIdentifier) ||\n                !core_1.types.isCallExpression(nextExpression.node.right) ||\n                !core_1.types.isIdentifier(nextExpression.node.right.callee) ||\n                nextExpression.node.right.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n                break;\n            }\n            if (allowWrappingDecorators) {\n                wrapStatementPaths.push(nextStatement);\n            }\n            else {\n                // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n                // The statement will prevent even a wrapped class from being optimized away.\n                hasPotentialSideEffects = true;\n            }\n            continue;\n        }\n        else if (!left.isMemberExpression() ||\n            !core_1.types.isIdentifier(left.node.object) ||\n            !left.scope.bindingIdentifierEquals(left.node.object.name, classIdentifier) ||\n            !core_1.types.isIdentifier(left.node.property)) {\n            break;\n        }\n        const propertyName = left.node.property.name;\n        const assignmentValue = nextExpression.get('right');\n        if ((_a = angularStaticsToElide[propertyName]) === null || _a === void 0 ? void 0 : _a.call(angularStaticsToElide, assignmentValue)) {\n            nextStatement.remove();\n            --i;\n        }\n        else if (canWrapProperty(propertyName, assignmentValue)) {\n            wrapStatementPaths.push(nextStatement);\n        }\n        else {\n            // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n            // The statement will prevent even a wrapped class from being optimized away.\n            hasPotentialSideEffects = true;\n        }\n    }\n    return { hasPotentialSideEffects, wrapStatementPaths };\n}\n/**\n * The set of classed already visited and analyzed during the plugin's execution.\n * This is used to prevent adjusted classes from being repeatedly analyzed which can lead\n * to an infinite loop.\n */\nconst visitedClasses = new WeakSet();\n/**\n * A babel plugin factory function for adjusting classes; primarily with Angular metadata.\n * The adjustments include wrapping classes with known safe or no side effects with pure\n * annotations to support dead code removal of unused classes. Angular compiler generated\n * metadata static fields not required in AOT mode are also elided to better support bundler-\n * level treeshaking.\n *\n * @returns A babel plugin object instance.\n */\nfunction default_1() {\n    return {\n        visitor: {\n            ClassDeclaration(path, state) {\n                const { node: classNode, parentPath } = path;\n                const { wrapDecorators } = state.opts;\n                if (visitedClasses.has(classNode)) {\n                    return;\n                }\n                // Analyze sibling statements for elements of the class that were downleveled\n                const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n                const origin = hasExport ? parentPath : path;\n                const { wrapStatementPaths, hasPotentialSideEffects } = analyzeClassSiblings(origin, classNode.id, wrapDecorators);\n                visitedClasses.add(classNode);\n                if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n                    return;\n                }\n                const wrapStatementNodes = [];\n                for (const statementPath of wrapStatementPaths) {\n                    wrapStatementNodes.push(statementPath.node);\n                    statementPath.remove();\n                }\n                // Wrap class and safe static assignments in a pure annotated IIFE\n                const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([\n                    classNode,\n                    ...wrapStatementNodes,\n                    core_1.types.returnStatement(core_1.types.cloneNode(classNode.id)),\n                ]));\n                const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n                (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n                // Replace class with IIFE wrapped class\n                const declaration = core_1.types.variableDeclaration('let', [\n                    core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), replacementInitializer),\n                ]);\n                if (parentPath.isExportDefaultDeclaration()) {\n                    // When converted to a variable declaration, the default export must be moved\n                    // to a subsequent statement to prevent a JavaScript syntax error.\n                    parentPath.replaceWithMultiple([\n                        declaration,\n                        core_1.types.exportNamedDeclaration(undefined, [\n                            core_1.types.exportSpecifier(core_1.types.cloneNode(classNode.id), core_1.types.identifier('default')),\n                        ]),\n                    ]);\n                }\n                else {\n                    path.replaceWith(declaration);\n                }\n            },\n            ClassExpression(path, state) {\n                const { node: classNode, parentPath } = path;\n                const { wrapDecorators } = state.opts;\n                // Class expressions are used by TypeScript to represent downlevel class/constructor decorators.\n                // If not wrapping decorators, they do not need to be processed.\n                if (!wrapDecorators || visitedClasses.has(classNode)) {\n                    return;\n                }\n                if (!classNode.id ||\n                    !parentPath.isVariableDeclarator() ||\n                    !core_1.types.isIdentifier(parentPath.node.id) ||\n                    parentPath.node.id.name !== classNode.id.name) {\n                    return;\n                }\n                const origin = parentPath.parentPath;\n                if (!origin.isVariableDeclaration() || origin.node.declarations.length !== 1) {\n                    return;\n                }\n                const { wrapStatementPaths, hasPotentialSideEffects } = analyzeClassSiblings(origin, parentPath.node.id, wrapDecorators);\n                visitedClasses.add(classNode);\n                if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n                    return;\n                }\n                const wrapStatementNodes = [];\n                for (const statementPath of wrapStatementPaths) {\n                    wrapStatementNodes.push(statementPath.node);\n                    statementPath.remove();\n                }\n                // Wrap class and safe static assignments in a pure annotated IIFE\n                const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([\n                    core_1.types.variableDeclaration('let', [\n                        core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), classNode),\n                    ]),\n                    ...wrapStatementNodes,\n                    core_1.types.returnStatement(core_1.types.cloneNode(classNode.id)),\n                ]));\n                const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n                (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n                // Add the wrapped class directly to the variable declaration\n                parentPath.get('init').replaceWith(replacementInitializer);\n            },\n        },\n    };\n}\nexports.default = default_1;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}