{"ast":null,"code":"const {\n  parseSync,\n  traverse\n} = require('@babel/core');\nconst {\n  defaults\n} = require('@istanbuljs/schema');\nconst {\n  MAGIC_KEY,\n  MAGIC_VALUE\n} = require('./constants');\nfunction getAst(code) {\n  if (typeof code === 'object' && typeof code.type === 'string') {\n    // Assume code is already a babel ast.\n    return code;\n  }\n  if (typeof code !== 'string') {\n    throw new Error('Code must be a string');\n  }\n\n  // Parse as leniently as possible\n  return parseSync(code, {\n    babelrc: false,\n    configFile: false,\n    parserOpts: {\n      allowAwaitOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      allowReturnOutsideFunction: true,\n      allowSuperOutsideMethod: true,\n      sourceType: 'script',\n      plugins: defaults.instrumenter.parserPlugins\n    }\n  });\n}\nmodule.exports = function readInitialCoverage(code) {\n  const ast = getAst(code);\n  let covScope;\n  traverse(ast, {\n    ObjectProperty(path) {\n      const {\n        node\n      } = path;\n      if (!node.computed && path.get('key').isIdentifier() && node.key.name === MAGIC_KEY) {\n        const magicValue = path.get('value').evaluate();\n        if (!magicValue.confident || magicValue.value !== MAGIC_VALUE) {\n          return;\n        }\n        covScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        path.stop();\n      }\n    }\n  });\n  if (!covScope) {\n    return null;\n  }\n  const result = {};\n  for (const key of ['path', 'hash', 'gcv', 'coverageData']) {\n    const binding = covScope.getOwnBinding(key);\n    if (!binding) {\n      return null;\n    }\n    const valuePath = binding.path.get('init');\n    const value = valuePath.evaluate();\n    if (!value.confident) {\n      return null;\n    }\n    result[key] = value.value;\n  }\n  delete result.coverageData[MAGIC_KEY];\n  delete result.coverageData.hash;\n  return result;\n};","map":{"version":3,"names":["parseSync","traverse","require","defaults","MAGIC_KEY","MAGIC_VALUE","getAst","code","type","Error","babelrc","configFile","parserOpts","allowAwaitOutsideFunction","allowImportExportEverywhere","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","plugins","instrumenter","parserPlugins","module","exports","readInitialCoverage","ast","covScope","ObjectProperty","path","node","computed","get","isIdentifier","key","name","magicValue","evaluate","confident","value","scope","getFunctionParent","getProgramParent","stop","result","binding","getOwnBinding","valuePath","coverageData","hash"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/istanbul-lib-instrument/src/read-coverage.js"],"sourcesContent":["const { parseSync, traverse } = require('@babel/core');\nconst { defaults } = require('@istanbuljs/schema');\nconst { MAGIC_KEY, MAGIC_VALUE } = require('./constants');\n\nfunction getAst(code) {\n    if (typeof code === 'object' && typeof code.type === 'string') {\n        // Assume code is already a babel ast.\n        return code;\n    }\n\n    if (typeof code !== 'string') {\n        throw new Error('Code must be a string');\n    }\n\n    // Parse as leniently as possible\n    return parseSync(code, {\n        babelrc: false,\n        configFile: false,\n        parserOpts: {\n            allowAwaitOutsideFunction: true,\n            allowImportExportEverywhere: true,\n            allowReturnOutsideFunction: true,\n            allowSuperOutsideMethod: true,\n            sourceType: 'script',\n            plugins: defaults.instrumenter.parserPlugins\n        }\n    });\n}\n\nmodule.exports = function readInitialCoverage(code) {\n    const ast = getAst(code);\n\n    let covScope;\n    traverse(ast, {\n        ObjectProperty(path) {\n            const { node } = path;\n            if (\n                !node.computed &&\n                path.get('key').isIdentifier() &&\n                node.key.name === MAGIC_KEY\n            ) {\n                const magicValue = path.get('value').evaluate();\n                if (!magicValue.confident || magicValue.value !== MAGIC_VALUE) {\n                    return;\n                }\n                covScope =\n                    path.scope.getFunctionParent() ||\n                    path.scope.getProgramParent();\n                path.stop();\n            }\n        }\n    });\n\n    if (!covScope) {\n        return null;\n    }\n\n    const result = {};\n\n    for (const key of ['path', 'hash', 'gcv', 'coverageData']) {\n        const binding = covScope.getOwnBinding(key);\n        if (!binding) {\n            return null;\n        }\n        const valuePath = binding.path.get('init');\n        const value = valuePath.evaluate();\n        if (!value.confident) {\n            return null;\n        }\n        result[key] = value.value;\n    }\n\n    delete result.coverageData[MAGIC_KEY];\n    delete result.coverageData.hash;\n\n    return result;\n};\n"],"mappings":"AAAA,MAAM;EAAEA,SAAS;EAAEC;AAAS,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;AACtD,MAAM;EAAEC;AAAS,CAAC,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AAClD,MAAM;EAAEE,SAAS;EAAEC;AAAY,CAAC,GAAGH,OAAO,CAAC,aAAa,CAAC;AAEzD,SAASI,MAAM,CAACC,IAAI,EAAE;EAClB,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,OAAOA,IAAI,CAACC,IAAI,KAAK,QAAQ,EAAE;IAC3D;IACA,OAAOD,IAAI;EACf;EAEA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC1B,MAAM,IAAIE,KAAK,CAAC,uBAAuB,CAAC;EAC5C;;EAEA;EACA,OAAOT,SAAS,CAACO,IAAI,EAAE;IACnBG,OAAO,EAAE,KAAK;IACdC,UAAU,EAAE,KAAK;IACjBC,UAAU,EAAE;MACRC,yBAAyB,EAAE,IAAI;MAC/BC,2BAA2B,EAAE,IAAI;MACjCC,0BAA0B,EAAE,IAAI;MAChCC,uBAAuB,EAAE,IAAI;MAC7BC,UAAU,EAAE,QAAQ;MACpBC,OAAO,EAAEf,QAAQ,CAACgB,YAAY,CAACC;IACnC;EACJ,CAAC,CAAC;AACN;AAEAC,MAAM,CAACC,OAAO,GAAG,SAASC,mBAAmB,CAAChB,IAAI,EAAE;EAChD,MAAMiB,GAAG,GAAGlB,MAAM,CAACC,IAAI,CAAC;EAExB,IAAIkB,QAAQ;EACZxB,QAAQ,CAACuB,GAAG,EAAE;IACVE,cAAc,CAACC,IAAI,EAAE;MACjB,MAAM;QAAEC;MAAK,CAAC,GAAGD,IAAI;MACrB,IACI,CAACC,IAAI,CAACC,QAAQ,IACdF,IAAI,CAACG,GAAG,CAAC,KAAK,CAAC,CAACC,YAAY,EAAE,IAC9BH,IAAI,CAACI,GAAG,CAACC,IAAI,KAAK7B,SAAS,EAC7B;QACE,MAAM8B,UAAU,GAAGP,IAAI,CAACG,GAAG,CAAC,OAAO,CAAC,CAACK,QAAQ,EAAE;QAC/C,IAAI,CAACD,UAAU,CAACE,SAAS,IAAIF,UAAU,CAACG,KAAK,KAAKhC,WAAW,EAAE;UAC3D;QACJ;QACAoB,QAAQ,GACJE,IAAI,CAACW,KAAK,CAACC,iBAAiB,EAAE,IAC9BZ,IAAI,CAACW,KAAK,CAACE,gBAAgB,EAAE;QACjCb,IAAI,CAACc,IAAI,EAAE;MACf;IACJ;EACJ,CAAC,CAAC;EAEF,IAAI,CAAChB,QAAQ,EAAE;IACX,OAAO,IAAI;EACf;EAEA,MAAMiB,MAAM,GAAG,CAAC,CAAC;EAEjB,KAAK,MAAMV,GAAG,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,cAAc,CAAC,EAAE;IACvD,MAAMW,OAAO,GAAGlB,QAAQ,CAACmB,aAAa,CAACZ,GAAG,CAAC;IAC3C,IAAI,CAACW,OAAO,EAAE;MACV,OAAO,IAAI;IACf;IACA,MAAME,SAAS,GAAGF,OAAO,CAAChB,IAAI,CAACG,GAAG,CAAC,MAAM,CAAC;IAC1C,MAAMO,KAAK,GAAGQ,SAAS,CAACV,QAAQ,EAAE;IAClC,IAAI,CAACE,KAAK,CAACD,SAAS,EAAE;MAClB,OAAO,IAAI;IACf;IACAM,MAAM,CAACV,GAAG,CAAC,GAAGK,KAAK,CAACA,KAAK;EAC7B;EAEA,OAAOK,MAAM,CAACI,YAAY,CAAC1C,SAAS,CAAC;EACrC,OAAOsC,MAAM,CAACI,YAAY,CAACC,IAAI;EAE/B,OAAOL,MAAM;AACjB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}