{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;\nconst worker_threads_1 = require(\"worker_threads\");\nconst events_1 = require(\"events\");\nconst eventemitter_asyncresource_1 = __importDefault(require(\"eventemitter-asyncresource\"));\nconst async_hooks_1 = require(\"async_hooks\");\nconst os_1 = require(\"os\");\nconst url_1 = require(\"url\");\nconst path_1 = require(\"path\");\nconst util_1 = require(\"util\");\nconst assert_1 = __importDefault(require(\"assert\"));\nconst hdr_histogram_js_1 = require(\"hdr-histogram-js\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst hdr_histogram_percentiles_obj_1 = __importDefault(require(\"hdr-histogram-percentiles-obj\"));\nconst common_1 = require(\"./common\");\nconst package_json_1 = require(\"../package.json\");\nconst cpuCount = (() => {\n  try {\n    return os_1.cpus().length;\n  } catch {\n    /* istanbul ignore next */\n    return 1;\n  }\n})();\n;\nfunction onabort(abortSignal, listener) {\n  if ('addEventListener' in abortSignal) {\n    abortSignal.addEventListener('abort', listener, {\n      once: true\n    });\n  } else {\n    abortSignal.once('abort', listener);\n  }\n}\nclass AbortError extends Error {\n  constructor() {\n    super('The task has been aborted');\n  }\n  get name() {\n    return 'AbortError';\n  }\n}\nclass ArrayTaskQueue {\n  constructor() {\n    this.tasks = [];\n  }\n  get size() {\n    return this.tasks.length;\n  }\n  shift() {\n    return this.tasks.shift();\n  }\n  push(task) {\n    this.tasks.push(task);\n  }\n  remove(task) {\n    const index = this.tasks.indexOf(task);\n    assert_1.default.notStrictEqual(index, -1);\n    this.tasks.splice(index, 1);\n  }\n}\nconst kDefaultOptions = {\n  filename: null,\n  name: 'default',\n  minThreads: Math.max(cpuCount / 2, 1),\n  maxThreads: cpuCount * 1.5,\n  idleTimeout: 0,\n  maxQueue: Infinity,\n  concurrentTasksPerWorker: 1,\n  useAtomics: true,\n  taskQueue: new ArrayTaskQueue(),\n  niceIncrement: 0,\n  trackUnmanagedFds: true\n};\nconst kDefaultRunOptions = {\n  transferList: undefined,\n  filename: null,\n  signal: null,\n  name: null\n};\nclass DirectlyTransferable {\n  constructor(value) {\n    _DirectlyTransferable_value.set(this, void 0);\n    __classPrivateFieldSet(this, _DirectlyTransferable_value, value, \"f\");\n  }\n  get [(_DirectlyTransferable_value = new WeakMap(), common_1.kTransferable)]() {\n    return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\");\n  }\n  get [common_1.kValue]() {\n    return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\");\n  }\n}\nclass ArrayBufferViewTransferable {\n  constructor(view) {\n    _ArrayBufferViewTransferable_view.set(this, void 0);\n    __classPrivateFieldSet(this, _ArrayBufferViewTransferable_view, view, \"f\");\n  }\n  get [(_ArrayBufferViewTransferable_view = new WeakMap(), common_1.kTransferable)]() {\n    return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\").buffer;\n  }\n  get [common_1.kValue]() {\n    return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\");\n  }\n}\nlet taskIdCounter = 0;\nfunction maybeFileURLToPath(filename) {\n  return filename.startsWith('file:') ? url_1.fileURLToPath(new url_1.URL(filename)) : filename;\n}\n// Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\nclass TaskInfo extends async_hooks_1.AsyncResource {\n  constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId) {\n    super('Piscina.Task', {\n      requireManualDestroy: true,\n      triggerAsyncId\n    });\n    this.abortListener = null;\n    this.workerInfo = null;\n    this.callback = callback;\n    this.task = task;\n    this.transferList = transferList;\n    // If the task is a Transferable returned by\n    // Piscina.move(), then add it to the transferList\n    // automatically\n    if (common_1.isMovable(task)) {\n      // This condition should never be hit but typescript\n      // complains if we dont do the check.\n      /* istanbul ignore if */\n      if (this.transferList == null) {\n        this.transferList = [];\n      }\n      this.transferList = this.transferList.concat(task[common_1.kTransferable]);\n      this.task = task[common_1.kValue];\n    }\n    this.filename = filename;\n    this.name = name;\n    this.taskId = taskIdCounter++;\n    this.abortSignal = abortSignal;\n    this.created = perf_hooks_1.performance.now();\n    this.started = 0;\n  }\n  releaseTask() {\n    const ret = this.task;\n    this.task = null;\n    return ret;\n  }\n  done(err, result) {\n    this.runInAsyncScope(this.callback, null, err, result);\n    this.emitDestroy(); // `TaskInfo`s are used only once.\n    // If an abort signal was used, remove the listener from it when\n    // done to make sure we do not accidentally leak.\n    if (this.abortSignal && this.abortListener) {\n      if ('removeEventListener' in this.abortSignal && this.abortListener) {\n        this.abortSignal.removeEventListener('abort', this.abortListener);\n      } else {\n        this.abortSignal.off('abort', this.abortListener);\n      }\n    }\n  }\n  get [common_1.kQueueOptions]() {\n    return common_1.kQueueOptions in this.task ? this.task[common_1.kQueueOptions] : null;\n  }\n}\nclass AsynchronouslyCreatedResource {\n  constructor() {\n    this.onreadyListeners = [];\n  }\n  markAsReady() {\n    const listeners = this.onreadyListeners;\n    assert_1.default(listeners !== null);\n    this.onreadyListeners = null;\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n  isReady() {\n    return this.onreadyListeners === null;\n  }\n  onReady(fn) {\n    if (this.onreadyListeners === null) {\n      fn(); // Zalgo is okay here.\n      return;\n    }\n    this.onreadyListeners.push(fn);\n  }\n}\nclass AsynchronouslyCreatedResourcePool {\n  constructor(maximumUsage) {\n    this.pendingItems = new Set();\n    this.readyItems = new Set();\n    this.maximumUsage = maximumUsage;\n    this.onAvailableListeners = [];\n  }\n  add(item) {\n    this.pendingItems.add(item);\n    item.onReady(() => {\n      /* istanbul ignore else */\n      if (this.pendingItems.has(item)) {\n        this.pendingItems.delete(item);\n        this.readyItems.add(item);\n        this.maybeAvailable(item);\n      }\n    });\n  }\n  delete(item) {\n    this.pendingItems.delete(item);\n    this.readyItems.delete(item);\n  }\n  findAvailable() {\n    let minUsage = this.maximumUsage;\n    let candidate = null;\n    for (const item of this.readyItems) {\n      const usage = item.currentUsage();\n      if (usage === 0) return item;\n      if (usage < minUsage) {\n        candidate = item;\n        minUsage = usage;\n      }\n    }\n    return candidate;\n  }\n  *[Symbol.iterator]() {\n    yield* this.pendingItems;\n    yield* this.readyItems;\n  }\n  get size() {\n    return this.pendingItems.size + this.readyItems.size;\n  }\n  maybeAvailable(item) {\n    /* istanbul ignore else */\n    if (item.currentUsage() < this.maximumUsage) {\n      for (const listener of this.onAvailableListeners) {\n        listener(item);\n      }\n    }\n  }\n  onAvailable(fn) {\n    this.onAvailableListeners.push(fn);\n  }\n}\nconst Errors = {\n  ThreadTermination: () => new Error('Terminating worker thread'),\n  FilenameNotProvided: () => new Error('filename must be provided to run() or in options object'),\n  TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n  NoTaskQueueAvailable: () => new Error('No task queue available and all Workers are busy')\n};\nclass WorkerInfo extends AsynchronouslyCreatedResource {\n  constructor(worker, port, onMessage) {\n    super();\n    this.idleTimeout = null; // eslint-disable-line no-undef\n    this.lastSeenResponseCount = 0;\n    this.worker = worker;\n    this.port = port;\n    this.port.on('message', message => this._handleResponse(message));\n    this.onMessage = onMessage;\n    this.taskInfos = new Map();\n    this.sharedBuffer = new Int32Array(new SharedArrayBuffer(common_1.kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n  }\n  destroy() {\n    this.worker.terminate();\n    this.port.close();\n    this.clearIdleTimeout();\n    for (const taskInfo of this.taskInfos.values()) {\n      taskInfo.done(Errors.ThreadTermination());\n    }\n    this.taskInfos.clear();\n  }\n  clearIdleTimeout() {\n    if (this.idleTimeout !== null) {\n      clearTimeout(this.idleTimeout);\n      this.idleTimeout = null;\n    }\n  }\n  ref() {\n    this.port.ref();\n    return this;\n  }\n  unref() {\n    // Note: Do not call ref()/unref() on the Worker itself since that may cause\n    // a hard crash, see https://github.com/nodejs/node/pull/33394.\n    this.port.unref();\n    return this;\n  }\n  _handleResponse(message) {\n    this.onMessage(message);\n    if (this.taskInfos.size === 0) {\n      // No more tasks running on this Worker means it should not keep the\n      // process running.\n      this.unref();\n    }\n  }\n  postTask(taskInfo) {\n    assert_1.default(!this.taskInfos.has(taskInfo.taskId));\n    const message = {\n      task: taskInfo.releaseTask(),\n      taskId: taskInfo.taskId,\n      filename: taskInfo.filename,\n      name: taskInfo.name\n    };\n    try {\n      this.port.postMessage(message, taskInfo.transferList);\n    } catch (err) {\n      // This would mostly happen if e.g. message contains unserializable data\n      // or transferList is invalid.\n      taskInfo.done(err);\n      return;\n    }\n    taskInfo.workerInfo = this;\n    this.taskInfos.set(taskInfo.taskId, taskInfo);\n    this.ref();\n    this.clearIdleTimeout();\n    // Inform the worker that there are new messages posted, and wake it up\n    // if it is waiting for one.\n    Atomics.add(this.sharedBuffer, common_1.kRequestCountField, 1);\n    Atomics.notify(this.sharedBuffer, common_1.kRequestCountField, 1);\n  }\n  processPendingMessages() {\n    // If we *know* that there are more messages than we have received using\n    // 'message' events yet, then try to load and handle them synchronously,\n    // without the need to wait for more expensive events on the event loop.\n    // This would usually break async tracking, but in our case, we already have\n    // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n    const actualResponseCount = Atomics.load(this.sharedBuffer, common_1.kResponseCountField);\n    if (actualResponseCount !== this.lastSeenResponseCount) {\n      this.lastSeenResponseCount = actualResponseCount;\n      let entry;\n      while ((entry = worker_threads_1.receiveMessageOnPort(this.port)) !== undefined) {\n        this._handleResponse(entry.message);\n      }\n    }\n  }\n  isRunningAbortableTask() {\n    // If there are abortable tasks, we are running one at most per Worker.\n    if (this.taskInfos.size !== 1) return false;\n    const [[, task]] = this.taskInfos;\n    return task.abortSignal !== null;\n  }\n  currentUsage() {\n    if (this.isRunningAbortableTask()) return Infinity;\n    return this.taskInfos.size;\n  }\n}\nclass ThreadPool {\n  constructor(publicInterface, options) {\n    var _a;\n    this.skipQueue = [];\n    this.completed = 0;\n    this.start = perf_hooks_1.performance.now();\n    this.inProcessPendingMessages = false;\n    this.startingUp = false;\n    this.workerFailsDuringBootstrap = false;\n    this.publicInterface = publicInterface;\n    this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n    this.runTime = hdr_histogram_js_1.build({\n      lowestDiscernibleValue: 1\n    });\n    this.waitTime = hdr_histogram_js_1.build({\n      lowestDiscernibleValue: 1\n    });\n    const filename = options.filename ? maybeFileURLToPath(options.filename) : null;\n    this.options = {\n      ...kDefaultOptions,\n      ...options,\n      filename,\n      maxQueue: 0\n    };\n    // The >= and <= could be > and < but this way we get 100 % coverage ðŸ™ƒ\n    if (options.maxThreads !== undefined && this.options.minThreads >= options.maxThreads) {\n      this.options.minThreads = options.maxThreads;\n    }\n    if (options.minThreads !== undefined && this.options.maxThreads <= options.minThreads) {\n      this.options.maxThreads = options.minThreads;\n    }\n    if (options.maxQueue === 'auto') {\n      this.options.maxQueue = this.options.maxThreads ** 2;\n    } else {\n      this.options.maxQueue = (_a = options.maxQueue) !== null && _a !== void 0 ? _a : kDefaultOptions.maxQueue;\n    }\n    this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);\n    this.workers.onAvailable(w => this._onWorkerAvailable(w));\n    this.startingUp = true;\n    this._ensureMinimumWorkers();\n    this.startingUp = false;\n  }\n  _ensureMinimumWorkers() {\n    while (this.workers.size < this.options.minThreads) {\n      this._addNewWorker();\n    }\n  }\n  _addNewWorker() {\n    const pool = this;\n    const worker = new worker_threads_1.Worker(path_1.resolve(__dirname, 'worker.js'), {\n      env: this.options.env,\n      argv: this.options.argv,\n      execArgv: this.options.execArgv,\n      resourceLimits: this.options.resourceLimits,\n      workerData: this.options.workerData,\n      trackUnmanagedFds: this.options.trackUnmanagedFds\n    });\n    const {\n      port1,\n      port2\n    } = new worker_threads_1.MessageChannel();\n    const workerInfo = new WorkerInfo(worker, port1, onMessage);\n    if (this.startingUp) {\n      // There is no point in waiting for the initial set of Workers to indicate\n      // that they are ready, we just mark them as such from the start.\n      workerInfo.markAsReady();\n    }\n    const message = {\n      filename: this.options.filename,\n      name: this.options.name,\n      port: port2,\n      sharedBuffer: workerInfo.sharedBuffer,\n      useAtomics: this.options.useAtomics,\n      niceIncrement: this.options.niceIncrement\n    };\n    worker.postMessage(message, [port2]);\n    function onMessage(message) {\n      const {\n        taskId,\n        result\n      } = message;\n      // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n      pool.workers.maybeAvailable(workerInfo);\n      /* istanbul ignore if */\n      if (taskInfo === undefined) {\n        const err = new Error(`Unexpected message from Worker: ${util_1.inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n      pool._processPendingMessages();\n    }\n    worker.on('message', message => {\n      if (message.ready === true) {\n        if (workerInfo.currentUsage() === 0) {\n          workerInfo.unref();\n        }\n        if (!workerInfo.isReady()) {\n          workerInfo.markAsReady();\n        }\n        return;\n      }\n      worker.emit('error', new Error(`Unexpected message on Worker: ${util_1.inspect(message)}`));\n    });\n    worker.on('error', err => {\n      // Work around the bug in https://github.com/nodejs/node/pull/33394\n      worker.ref = () => {};\n      // In case of an uncaught exception: Call the callback that was passed to\n      // `postTask` with the error, or emit an 'error' event if there is none.\n      const taskInfos = [...workerInfo.taskInfos.values()];\n      workerInfo.taskInfos.clear();\n      // Remove the worker from the list and potentially start a new Worker to\n      // replace the current one.\n      this._removeWorker(workerInfo);\n      if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n        this._ensureMinimumWorkers();\n      } else {\n        // Do not start new workers over and over if they already fail during\n        // bootstrap, there's no point.\n        this.workerFailsDuringBootstrap = true;\n      }\n      if (taskInfos.length > 0) {\n        for (const taskInfo of taskInfos) {\n          taskInfo.done(err, null);\n        }\n      } else {\n        this.publicInterface.emit('error', err);\n      }\n    });\n    worker.unref();\n    port1.on('close', () => {\n      // The port is only closed if the Worker stops for some reason, but we\n      // always .unref() the Worker itself. We want to receive e.g. 'error'\n      // events on it, so we ref it once we know it's going to exit anyway.\n      worker.ref();\n    });\n    this.workers.add(workerInfo);\n  }\n  _processPendingMessages() {\n    if (this.inProcessPendingMessages || !this.options.useAtomics) {\n      return;\n    }\n    this.inProcessPendingMessages = true;\n    try {\n      for (const workerInfo of this.workers) {\n        workerInfo.processPendingMessages();\n      }\n    } finally {\n      this.inProcessPendingMessages = false;\n    }\n  }\n  _removeWorker(workerInfo) {\n    workerInfo.destroy();\n    this.workers.delete(workerInfo);\n  }\n  _onWorkerAvailable(workerInfo) {\n    while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) && workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n      // The skipQueue will have tasks that we previously shifted off\n      // the task queue but had to skip over... we have to make sure\n      // we drain that before we drain the taskQueue.\n      const taskInfo = this.skipQueue.shift() || this.taskQueue.shift();\n      // If the task has an abortSignal and the worker has any other\n      // tasks, we cannot distribute the task to it. Skip for now.\n      if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n        this.skipQueue.push(taskInfo);\n        break;\n      }\n      const now = perf_hooks_1.performance.now();\n      this.waitTime.recordValue(now - taskInfo.created);\n      taskInfo.started = now;\n      workerInfo.postTask(taskInfo);\n      this._maybeDrain();\n      return;\n    }\n    if (workerInfo.taskInfos.size === 0 && this.workers.size > this.options.minThreads) {\n      workerInfo.idleTimeout = setTimeout(() => {\n        assert_1.default.strictEqual(workerInfo.taskInfos.size, 0);\n        if (this.workers.size > this.options.minThreads) {\n          this._removeWorker(workerInfo);\n        }\n      }, this.options.idleTimeout).unref();\n    }\n  }\n  runTask(task, options) {\n    let {\n      filename,\n      name\n    } = options;\n    const {\n      transferList = [],\n      signal = null\n    } = options;\n    if (filename == null) {\n      filename = this.options.filename;\n    }\n    if (name == null) {\n      name = this.options.name;\n    }\n    if (typeof filename !== 'string') {\n      return Promise.reject(Errors.FilenameNotProvided());\n    }\n    filename = maybeFileURLToPath(filename);\n    let resolve;\n    let reject;\n    // eslint-disable-next-line\n    const ret = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {\n      this.completed++;\n      if (taskInfo.started) {\n        this.runTime.recordValue(perf_hooks_1.performance.now() - taskInfo.started);\n      }\n      if (err !== null) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    }, signal, this.publicInterface.asyncResource.asyncId());\n    if (signal !== null) {\n      // If the AbortSignal has an aborted property and it's truthy,\n      // reject immediately.\n      if (signal.aborted) {\n        return Promise.reject(new AbortError());\n      }\n      taskInfo.abortListener = () => {\n        // Call reject() first to make sure we always reject with the AbortError\n        // if the task is aborted, not with an Error from the possible\n        // thread termination below.\n        reject(new AbortError());\n        if (taskInfo.workerInfo !== null) {\n          // Already running: We cancel the Worker this is running on.\n          this._removeWorker(taskInfo.workerInfo);\n          this._ensureMinimumWorkers();\n        } else {\n          // Not yet running: Remove it from the queue.\n          this.taskQueue.remove(taskInfo);\n        }\n      };\n      onabort(signal, taskInfo.abortListener);\n    }\n    // If there is a task queue, there's no point in looking for an available\n    // Worker thread. Add this task to the queue, if possible.\n    if (this.taskQueue.size > 0) {\n      const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n      if (this.taskQueue.size >= totalCapacity) {\n        if (this.options.maxQueue === 0) {\n          return Promise.reject(Errors.NoTaskQueueAvailable());\n        } else {\n          return Promise.reject(Errors.TaskQueueAtLimit());\n        }\n      } else {\n        if (this.workers.size < this.options.maxThreads) {\n          this._addNewWorker();\n        }\n        this.taskQueue.push(taskInfo);\n      }\n      return ret;\n    }\n    // Look for a Worker with a minimum number of tasks it is currently running.\n    let workerInfo = this.workers.findAvailable();\n    // If we want the ability to abort this task, use only workers that have\n    // no running tasks.\n    if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n      workerInfo = null;\n    }\n    // If no Worker was found, or that Worker was handling another task in some\n    // way, and we still have the ability to spawn new threads, do so.\n    let waitingForNewWorker = false;\n    if ((workerInfo === null || workerInfo.currentUsage() > 0) && this.workers.size < this.options.maxThreads) {\n      this._addNewWorker();\n      waitingForNewWorker = true;\n    }\n    // If no Worker is found, try to put the task into the queue.\n    if (workerInfo === null) {\n      if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n        return Promise.reject(Errors.NoTaskQueueAvailable());\n      } else {\n        this.taskQueue.push(taskInfo);\n      }\n      return ret;\n    }\n    // TODO(addaleax): Clean up the waitTime/runTime recording.\n    const now = perf_hooks_1.performance.now();\n    this.waitTime.recordValue(now - taskInfo.created);\n    taskInfo.started = now;\n    workerInfo.postTask(taskInfo);\n    this._maybeDrain();\n    return ret;\n  }\n  pendingCapacity() {\n    return this.workers.pendingItems.size * this.options.concurrentTasksPerWorker;\n  }\n  _maybeDrain() {\n    if (this.taskQueue.size === 0 && this.skipQueue.length === 0) {\n      this.publicInterface.emit('drain');\n    }\n  }\n  destroy() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      while (_this.skipQueue.length > 0) {\n        const taskInfo = _this.skipQueue.shift();\n        taskInfo.done(new Error('Terminating worker thread'));\n      }\n      while (_this.taskQueue.size > 0) {\n        const taskInfo = _this.taskQueue.shift();\n        taskInfo.done(new Error('Terminating worker thread'));\n      }\n      const exitEvents = [];\n      while (_this.workers.size > 0) {\n        const [workerInfo] = _this.workers;\n        exitEvents.push(events_1.once(workerInfo.worker, 'exit'));\n        _this._removeWorker(workerInfo);\n      }\n      yield Promise.all(exitEvents);\n    })();\n  }\n}\nclass Piscina extends eventemitter_asyncresource_1.default {\n  constructor(options = {}) {\n    super({\n      ...options,\n      name: 'Piscina'\n    });\n    _Piscina_pool.set(this, void 0);\n    if (typeof options.filename !== 'string' && options.filename != null) {\n      throw new TypeError('options.filename must be a string or null');\n    }\n    if (typeof options.name !== 'string' && options.name != null) {\n      throw new TypeError('options.name must be a string or null');\n    }\n    if (options.minThreads !== undefined && (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n      throw new TypeError('options.minThreads must be a non-negative integer');\n    }\n    if (options.maxThreads !== undefined && (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n      throw new TypeError('options.maxThreads must be a positive integer');\n    }\n    if (options.minThreads !== undefined && options.maxThreads !== undefined && options.minThreads > options.maxThreads) {\n      throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n    }\n    if (options.idleTimeout !== undefined && (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n      throw new TypeError('options.idleTimeout must be a non-negative integer');\n    }\n    if (options.maxQueue !== undefined && options.maxQueue !== 'auto' && (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n      throw new TypeError('options.maxQueue must be a non-negative integer');\n    }\n    if (options.concurrentTasksPerWorker !== undefined && (typeof options.concurrentTasksPerWorker !== 'number' || options.concurrentTasksPerWorker < 1)) {\n      throw new TypeError('options.concurrentTasksPerWorker must be a positive integer');\n    }\n    if (options.useAtomics !== undefined && typeof options.useAtomics !== 'boolean') {\n      throw new TypeError('options.useAtomics must be a boolean value');\n    }\n    if (options.resourceLimits !== undefined && (typeof options.resourceLimits !== 'object' || options.resourceLimits === null)) {\n      throw new TypeError('options.resourceLimits must be an object');\n    }\n    if (options.taskQueue !== undefined && !common_1.isTaskQueue(options.taskQueue)) {\n      throw new TypeError('options.taskQueue must be a TaskQueue object');\n    }\n    if (options.niceIncrement !== undefined && (typeof options.niceIncrement !== 'number' || options.niceIncrement < 0)) {\n      throw new TypeError('options.niceIncrement must be a non-negative integer');\n    }\n    if (options.trackUnmanagedFds !== undefined && typeof options.trackUnmanagedFds !== 'boolean') {\n      throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n    }\n    __classPrivateFieldSet(this, _Piscina_pool, new ThreadPool(this, options), \"f\");\n  }\n  /** @deprecated Use run(task, options) instead **/\n  runTask(task, transferList, filename, signal) {\n    // If transferList is a string or AbortSignal, shift it.\n    if (typeof transferList === 'object' && !Array.isArray(transferList) || typeof transferList === 'string') {\n      signal = filename;\n      filename = transferList;\n      transferList = undefined;\n    }\n    // If filename is an AbortSignal, shift it.\n    if (typeof filename === 'object' && !Array.isArray(filename)) {\n      signal = filename;\n      filename = undefined;\n    }\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(new TypeError('transferList argument must be an Array'));\n    }\n    if (filename !== undefined && typeof filename !== 'string') {\n      return Promise.reject(new TypeError('filename argument must be a string'));\n    }\n    if (signal !== undefined && typeof signal !== 'object') {\n      return Promise.reject(new TypeError('signal argument must be an object'));\n    }\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n      transferList,\n      filename: filename || null,\n      name: 'default',\n      signal: signal || null\n    });\n  }\n  run(task, options = kDefaultRunOptions) {\n    if (options === null || typeof options !== 'object') {\n      return Promise.reject(new TypeError('options must be an object'));\n    }\n    const {\n      transferList,\n      filename,\n      name,\n      signal\n    } = options;\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(new TypeError('transferList argument must be an Array'));\n    }\n    if (filename != null && typeof filename !== 'string') {\n      return Promise.reject(new TypeError('filename argument must be a string'));\n    }\n    if (name != null && typeof name !== 'string') {\n      return Promise.reject(new TypeError('name argument must be a string'));\n    }\n    if (signal != null && typeof signal !== 'object') {\n      return Promise.reject(new TypeError('signal argument must be an object'));\n    }\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n      transferList,\n      filename,\n      name,\n      signal\n    });\n  }\n  destroy() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").destroy();\n  }\n  get options() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").options;\n  }\n  get threads() {\n    const ret = [];\n    for (const workerInfo of __classPrivateFieldGet(this, _Piscina_pool, \"f\").workers) {\n      ret.push(workerInfo.worker);\n    }\n    return ret;\n  }\n  get queueSize() {\n    const pool = __classPrivateFieldGet(this, _Piscina_pool, \"f\");\n    return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n  }\n  get completed() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").completed;\n  }\n  get waitTime() {\n    const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime);\n    return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime, result);\n  }\n  get runTime() {\n    const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime);\n    return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime, result);\n  }\n  get utilization() {\n    // The capacity is the max compute time capacity of the\n    // pool to this point in time as determined by the length\n    // of time the pool has been running multiplied by the\n    // maximum number of threads.\n    const capacity = this.duration * __classPrivateFieldGet(this, _Piscina_pool, \"f\").options.maxThreads;\n    const totalMeanRuntime = __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.mean * __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.totalCount;\n    // We calculate the appoximate pool utilization by multiplying\n    // the mean run time of all tasks by the number of runtime\n    // samples taken and dividing that by the capacity. The\n    // theory here is that capacity represents the absolute upper\n    // limit of compute time this pool could ever attain (but\n    // never will for a variety of reasons. Multiplying the\n    // mean run time by the number of tasks sampled yields an\n    // approximation of the realized compute time. The utilization\n    // then becomes a point-in-time measure of how active the\n    // pool is.\n    return totalMeanRuntime / capacity;\n  }\n  get duration() {\n    return perf_hooks_1.performance.now() - __classPrivateFieldGet(this, _Piscina_pool, \"f\").start;\n  }\n  static get isWorkerThread() {\n    return common_1.commonState.isWorkerThread;\n  }\n  static get workerData() {\n    return common_1.commonState.workerData;\n  }\n  static get version() {\n    return package_json_1.version;\n  }\n  static get Piscina() {\n    return Piscina;\n  }\n  static move(val) {\n    if (val != null && typeof val === 'object' && typeof val !== 'function') {\n      if (!common_1.isTransferable(val)) {\n        if (util_1.types.isArrayBufferView(val)) {\n          val = new ArrayBufferViewTransferable(val);\n        } else {\n          val = new DirectlyTransferable(val);\n        }\n      }\n      common_1.markMovable(val);\n    }\n    return val;\n  }\n  static get transferableSymbol() {\n    return common_1.kTransferable;\n  }\n  static get valueSymbol() {\n    return common_1.kValue;\n  }\n  static get queueOptionsSymbol() {\n    return common_1.kQueueOptions;\n  }\n}\n_Piscina_pool = new WeakMap();\nmodule.exports = Piscina;","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","__importDefault","mod","__esModule","_DirectlyTransferable_value","_ArrayBufferViewTransferable_view","_Piscina_pool","worker_threads_1","require","events_1","eventemitter_asyncresource_1","async_hooks_1","os_1","url_1","path_1","util_1","assert_1","hdr_histogram_js_1","perf_hooks_1","hdr_histogram_percentiles_obj_1","common_1","package_json_1","cpuCount","cpus","length","onabort","abortSignal","listener","addEventListener","once","AbortError","Error","constructor","name","ArrayTaskQueue","tasks","size","shift","push","task","remove","index","indexOf","default","notStrictEqual","splice","kDefaultOptions","filename","minThreads","Math","max","maxThreads","idleTimeout","maxQueue","Infinity","concurrentTasksPerWorker","useAtomics","taskQueue","niceIncrement","trackUnmanagedFds","kDefaultRunOptions","transferList","undefined","signal","DirectlyTransferable","WeakMap","kTransferable","kValue","ArrayBufferViewTransferable","view","buffer","taskIdCounter","maybeFileURLToPath","startsWith","fileURLToPath","URL","TaskInfo","AsyncResource","callback","triggerAsyncId","requireManualDestroy","abortListener","workerInfo","isMovable","concat","taskId","created","performance","now","started","releaseTask","ret","done","err","result","runInAsyncScope","emitDestroy","removeEventListener","off","kQueueOptions","AsynchronouslyCreatedResource","onreadyListeners","markAsReady","listeners","isReady","onReady","fn","AsynchronouslyCreatedResourcePool","maximumUsage","pendingItems","Set","readyItems","onAvailableListeners","add","item","delete","maybeAvailable","findAvailable","minUsage","candidate","usage","currentUsage","Symbol","iterator","onAvailable","Errors","ThreadTermination","FilenameNotProvided","TaskQueueAtLimit","NoTaskQueueAvailable","WorkerInfo","worker","port","onMessage","lastSeenResponseCount","on","message","_handleResponse","taskInfos","Map","sharedBuffer","Int32Array","SharedArrayBuffer","kFieldCount","BYTES_PER_ELEMENT","destroy","terminate","close","clearIdleTimeout","taskInfo","values","clear","clearTimeout","ref","unref","postTask","postMessage","Atomics","kRequestCountField","notify","processPendingMessages","actualResponseCount","load","kResponseCountField","entry","receiveMessageOnPort","isRunningAbortableTask","ThreadPool","publicInterface","options","_a","skipQueue","completed","start","inProcessPendingMessages","startingUp","workerFailsDuringBootstrap","runTime","build","lowestDiscernibleValue","waitTime","workers","w","_onWorkerAvailable","_ensureMinimumWorkers","_addNewWorker","pool","Worker","resolve","__dirname","env","argv","execArgv","resourceLimits","workerData","port1","port2","MessageChannel","inspect","emit","error","_processPendingMessages","ready","_removeWorker","recordValue","_maybeDrain","setTimeout","strictEqual","runTask","Promise","reject","res","rej","asyncResource","asyncId","aborted","totalCapacity","pendingCapacity","waitingForNewWorker","exitEvents","all","Piscina","RangeError","isTaskQueue","Array","isArray","run","threads","queueSize","histAsObj","addPercentiles","utilization","capacity","duration","totalMeanRuntime","mean","totalCount","isWorkerThread","commonState","version","move","val","isTransferable","types","isArrayBufferView","markMovable","transferableSymbol","valueSymbol","queueOptionsSymbol","module","exports"],"sources":["C:/Users/Nawaz/Downloads/mean-stack-authentication-authorization-master/mean-stack-authentication-authorization-master/Frontend/node_modules/piscina/dist/src/index.js"],"sourcesContent":["\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;\nconst worker_threads_1 = require(\"worker_threads\");\nconst events_1 = require(\"events\");\nconst eventemitter_asyncresource_1 = __importDefault(require(\"eventemitter-asyncresource\"));\nconst async_hooks_1 = require(\"async_hooks\");\nconst os_1 = require(\"os\");\nconst url_1 = require(\"url\");\nconst path_1 = require(\"path\");\nconst util_1 = require(\"util\");\nconst assert_1 = __importDefault(require(\"assert\"));\nconst hdr_histogram_js_1 = require(\"hdr-histogram-js\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst hdr_histogram_percentiles_obj_1 = __importDefault(require(\"hdr-histogram-percentiles-obj\"));\nconst common_1 = require(\"./common\");\nconst package_json_1 = require(\"../package.json\");\nconst cpuCount = (() => {\n    try {\n        return os_1.cpus().length;\n    }\n    catch {\n        /* istanbul ignore next */\n        return 1;\n    }\n})();\n;\nfunction onabort(abortSignal, listener) {\n    if ('addEventListener' in abortSignal) {\n        abortSignal.addEventListener('abort', listener, { once: true });\n    }\n    else {\n        abortSignal.once('abort', listener);\n    }\n}\nclass AbortError extends Error {\n    constructor() {\n        super('The task has been aborted');\n    }\n    get name() { return 'AbortError'; }\n}\nclass ArrayTaskQueue {\n    constructor() {\n        this.tasks = [];\n    }\n    get size() { return this.tasks.length; }\n    shift() {\n        return this.tasks.shift();\n    }\n    push(task) {\n        this.tasks.push(task);\n    }\n    remove(task) {\n        const index = this.tasks.indexOf(task);\n        assert_1.default.notStrictEqual(index, -1);\n        this.tasks.splice(index, 1);\n    }\n}\nconst kDefaultOptions = {\n    filename: null,\n    name: 'default',\n    minThreads: Math.max(cpuCount / 2, 1),\n    maxThreads: cpuCount * 1.5,\n    idleTimeout: 0,\n    maxQueue: Infinity,\n    concurrentTasksPerWorker: 1,\n    useAtomics: true,\n    taskQueue: new ArrayTaskQueue(),\n    niceIncrement: 0,\n    trackUnmanagedFds: true\n};\nconst kDefaultRunOptions = {\n    transferList: undefined,\n    filename: null,\n    signal: null,\n    name: null\n};\nclass DirectlyTransferable {\n    constructor(value) {\n        _DirectlyTransferable_value.set(this, void 0);\n        __classPrivateFieldSet(this, _DirectlyTransferable_value, value, \"f\");\n    }\n    get [(_DirectlyTransferable_value = new WeakMap(), common_1.kTransferable)]() { return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\"); }\n    get [common_1.kValue]() { return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\"); }\n}\nclass ArrayBufferViewTransferable {\n    constructor(view) {\n        _ArrayBufferViewTransferable_view.set(this, void 0);\n        __classPrivateFieldSet(this, _ArrayBufferViewTransferable_view, view, \"f\");\n    }\n    get [(_ArrayBufferViewTransferable_view = new WeakMap(), common_1.kTransferable)]() { return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\").buffer; }\n    get [common_1.kValue]() { return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\"); }\n}\nlet taskIdCounter = 0;\nfunction maybeFileURLToPath(filename) {\n    return filename.startsWith('file:')\n        ? url_1.fileURLToPath(new url_1.URL(filename))\n        : filename;\n}\n// Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\nclass TaskInfo extends async_hooks_1.AsyncResource {\n    constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId) {\n        super('Piscina.Task', { requireManualDestroy: true, triggerAsyncId });\n        this.abortListener = null;\n        this.workerInfo = null;\n        this.callback = callback;\n        this.task = task;\n        this.transferList = transferList;\n        // If the task is a Transferable returned by\n        // Piscina.move(), then add it to the transferList\n        // automatically\n        if (common_1.isMovable(task)) {\n            // This condition should never be hit but typescript\n            // complains if we dont do the check.\n            /* istanbul ignore if */\n            if (this.transferList == null) {\n                this.transferList = [];\n            }\n            this.transferList =\n                this.transferList.concat(task[common_1.kTransferable]);\n            this.task = task[common_1.kValue];\n        }\n        this.filename = filename;\n        this.name = name;\n        this.taskId = taskIdCounter++;\n        this.abortSignal = abortSignal;\n        this.created = perf_hooks_1.performance.now();\n        this.started = 0;\n    }\n    releaseTask() {\n        const ret = this.task;\n        this.task = null;\n        return ret;\n    }\n    done(err, result) {\n        this.runInAsyncScope(this.callback, null, err, result);\n        this.emitDestroy(); // `TaskInfo`s are used only once.\n        // If an abort signal was used, remove the listener from it when\n        // done to make sure we do not accidentally leak.\n        if (this.abortSignal && this.abortListener) {\n            if ('removeEventListener' in this.abortSignal && this.abortListener) {\n                this.abortSignal.removeEventListener('abort', this.abortListener);\n            }\n            else {\n                this.abortSignal.off('abort', this.abortListener);\n            }\n        }\n    }\n    get [common_1.kQueueOptions]() {\n        return common_1.kQueueOptions in this.task ? this.task[common_1.kQueueOptions] : null;\n    }\n}\nclass AsynchronouslyCreatedResource {\n    constructor() {\n        this.onreadyListeners = [];\n    }\n    markAsReady() {\n        const listeners = this.onreadyListeners;\n        assert_1.default(listeners !== null);\n        this.onreadyListeners = null;\n        for (const listener of listeners) {\n            listener();\n        }\n    }\n    isReady() {\n        return this.onreadyListeners === null;\n    }\n    onReady(fn) {\n        if (this.onreadyListeners === null) {\n            fn(); // Zalgo is okay here.\n            return;\n        }\n        this.onreadyListeners.push(fn);\n    }\n}\nclass AsynchronouslyCreatedResourcePool {\n    constructor(maximumUsage) {\n        this.pendingItems = new Set();\n        this.readyItems = new Set();\n        this.maximumUsage = maximumUsage;\n        this.onAvailableListeners = [];\n    }\n    add(item) {\n        this.pendingItems.add(item);\n        item.onReady(() => {\n            /* istanbul ignore else */\n            if (this.pendingItems.has(item)) {\n                this.pendingItems.delete(item);\n                this.readyItems.add(item);\n                this.maybeAvailable(item);\n            }\n        });\n    }\n    delete(item) {\n        this.pendingItems.delete(item);\n        this.readyItems.delete(item);\n    }\n    findAvailable() {\n        let minUsage = this.maximumUsage;\n        let candidate = null;\n        for (const item of this.readyItems) {\n            const usage = item.currentUsage();\n            if (usage === 0)\n                return item;\n            if (usage < minUsage) {\n                candidate = item;\n                minUsage = usage;\n            }\n        }\n        return candidate;\n    }\n    *[Symbol.iterator]() {\n        yield* this.pendingItems;\n        yield* this.readyItems;\n    }\n    get size() {\n        return this.pendingItems.size + this.readyItems.size;\n    }\n    maybeAvailable(item) {\n        /* istanbul ignore else */\n        if (item.currentUsage() < this.maximumUsage) {\n            for (const listener of this.onAvailableListeners) {\n                listener(item);\n            }\n        }\n    }\n    onAvailable(fn) {\n        this.onAvailableListeners.push(fn);\n    }\n}\nconst Errors = {\n    ThreadTermination: () => new Error('Terminating worker thread'),\n    FilenameNotProvided: () => new Error('filename must be provided to run() or in options object'),\n    TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n    NoTaskQueueAvailable: () => new Error('No task queue available and all Workers are busy')\n};\nclass WorkerInfo extends AsynchronouslyCreatedResource {\n    constructor(worker, port, onMessage) {\n        super();\n        this.idleTimeout = null; // eslint-disable-line no-undef\n        this.lastSeenResponseCount = 0;\n        this.worker = worker;\n        this.port = port;\n        this.port.on('message', (message) => this._handleResponse(message));\n        this.onMessage = onMessage;\n        this.taskInfos = new Map();\n        this.sharedBuffer = new Int32Array(new SharedArrayBuffer(common_1.kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n    }\n    destroy() {\n        this.worker.terminate();\n        this.port.close();\n        this.clearIdleTimeout();\n        for (const taskInfo of this.taskInfos.values()) {\n            taskInfo.done(Errors.ThreadTermination());\n        }\n        this.taskInfos.clear();\n    }\n    clearIdleTimeout() {\n        if (this.idleTimeout !== null) {\n            clearTimeout(this.idleTimeout);\n            this.idleTimeout = null;\n        }\n    }\n    ref() {\n        this.port.ref();\n        return this;\n    }\n    unref() {\n        // Note: Do not call ref()/unref() on the Worker itself since that may cause\n        // a hard crash, see https://github.com/nodejs/node/pull/33394.\n        this.port.unref();\n        return this;\n    }\n    _handleResponse(message) {\n        this.onMessage(message);\n        if (this.taskInfos.size === 0) {\n            // No more tasks running on this Worker means it should not keep the\n            // process running.\n            this.unref();\n        }\n    }\n    postTask(taskInfo) {\n        assert_1.default(!this.taskInfos.has(taskInfo.taskId));\n        const message = {\n            task: taskInfo.releaseTask(),\n            taskId: taskInfo.taskId,\n            filename: taskInfo.filename,\n            name: taskInfo.name\n        };\n        try {\n            this.port.postMessage(message, taskInfo.transferList);\n        }\n        catch (err) {\n            // This would mostly happen if e.g. message contains unserializable data\n            // or transferList is invalid.\n            taskInfo.done(err);\n            return;\n        }\n        taskInfo.workerInfo = this;\n        this.taskInfos.set(taskInfo.taskId, taskInfo);\n        this.ref();\n        this.clearIdleTimeout();\n        // Inform the worker that there are new messages posted, and wake it up\n        // if it is waiting for one.\n        Atomics.add(this.sharedBuffer, common_1.kRequestCountField, 1);\n        Atomics.notify(this.sharedBuffer, common_1.kRequestCountField, 1);\n    }\n    processPendingMessages() {\n        // If we *know* that there are more messages than we have received using\n        // 'message' events yet, then try to load and handle them synchronously,\n        // without the need to wait for more expensive events on the event loop.\n        // This would usually break async tracking, but in our case, we already have\n        // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n        const actualResponseCount = Atomics.load(this.sharedBuffer, common_1.kResponseCountField);\n        if (actualResponseCount !== this.lastSeenResponseCount) {\n            this.lastSeenResponseCount = actualResponseCount;\n            let entry;\n            while ((entry = worker_threads_1.receiveMessageOnPort(this.port)) !== undefined) {\n                this._handleResponse(entry.message);\n            }\n        }\n    }\n    isRunningAbortableTask() {\n        // If there are abortable tasks, we are running one at most per Worker.\n        if (this.taskInfos.size !== 1)\n            return false;\n        const [[, task]] = this.taskInfos;\n        return task.abortSignal !== null;\n    }\n    currentUsage() {\n        if (this.isRunningAbortableTask())\n            return Infinity;\n        return this.taskInfos.size;\n    }\n}\nclass ThreadPool {\n    constructor(publicInterface, options) {\n        var _a;\n        this.skipQueue = [];\n        this.completed = 0;\n        this.start = perf_hooks_1.performance.now();\n        this.inProcessPendingMessages = false;\n        this.startingUp = false;\n        this.workerFailsDuringBootstrap = false;\n        this.publicInterface = publicInterface;\n        this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n        this.runTime = hdr_histogram_js_1.build({ lowestDiscernibleValue: 1 });\n        this.waitTime = hdr_histogram_js_1.build({ lowestDiscernibleValue: 1 });\n        const filename = options.filename ? maybeFileURLToPath(options.filename) : null;\n        this.options = { ...kDefaultOptions, ...options, filename, maxQueue: 0 };\n        // The >= and <= could be > and < but this way we get 100 % coverage ðŸ™ƒ\n        if (options.maxThreads !== undefined &&\n            this.options.minThreads >= options.maxThreads) {\n            this.options.minThreads = options.maxThreads;\n        }\n        if (options.minThreads !== undefined &&\n            this.options.maxThreads <= options.minThreads) {\n            this.options.maxThreads = options.minThreads;\n        }\n        if (options.maxQueue === 'auto') {\n            this.options.maxQueue = this.options.maxThreads ** 2;\n        }\n        else {\n            this.options.maxQueue = (_a = options.maxQueue) !== null && _a !== void 0 ? _a : kDefaultOptions.maxQueue;\n        }\n        this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);\n        this.workers.onAvailable((w) => this._onWorkerAvailable(w));\n        this.startingUp = true;\n        this._ensureMinimumWorkers();\n        this.startingUp = false;\n    }\n    _ensureMinimumWorkers() {\n        while (this.workers.size < this.options.minThreads) {\n            this._addNewWorker();\n        }\n    }\n    _addNewWorker() {\n        const pool = this;\n        const worker = new worker_threads_1.Worker(path_1.resolve(__dirname, 'worker.js'), {\n            env: this.options.env,\n            argv: this.options.argv,\n            execArgv: this.options.execArgv,\n            resourceLimits: this.options.resourceLimits,\n            workerData: this.options.workerData,\n            trackUnmanagedFds: this.options.trackUnmanagedFds\n        });\n        const { port1, port2 } = new worker_threads_1.MessageChannel();\n        const workerInfo = new WorkerInfo(worker, port1, onMessage);\n        if (this.startingUp) {\n            // There is no point in waiting for the initial set of Workers to indicate\n            // that they are ready, we just mark them as such from the start.\n            workerInfo.markAsReady();\n        }\n        const message = {\n            filename: this.options.filename,\n            name: this.options.name,\n            port: port2,\n            sharedBuffer: workerInfo.sharedBuffer,\n            useAtomics: this.options.useAtomics,\n            niceIncrement: this.options.niceIncrement\n        };\n        worker.postMessage(message, [port2]);\n        function onMessage(message) {\n            const { taskId, result } = message;\n            // In case of success: Call the callback that was passed to `runTask`,\n            // remove the `TaskInfo` associated with the Worker, which marks it as\n            // free again.\n            const taskInfo = workerInfo.taskInfos.get(taskId);\n            workerInfo.taskInfos.delete(taskId);\n            pool.workers.maybeAvailable(workerInfo);\n            /* istanbul ignore if */\n            if (taskInfo === undefined) {\n                const err = new Error(`Unexpected message from Worker: ${util_1.inspect(message)}`);\n                pool.publicInterface.emit('error', err);\n            }\n            else {\n                taskInfo.done(message.error, result);\n            }\n            pool._processPendingMessages();\n        }\n        worker.on('message', (message) => {\n            if (message.ready === true) {\n                if (workerInfo.currentUsage() === 0) {\n                    workerInfo.unref();\n                }\n                if (!workerInfo.isReady()) {\n                    workerInfo.markAsReady();\n                }\n                return;\n            }\n            worker.emit('error', new Error(`Unexpected message on Worker: ${util_1.inspect(message)}`));\n        });\n        worker.on('error', (err) => {\n            // Work around the bug in https://github.com/nodejs/node/pull/33394\n            worker.ref = () => { };\n            // In case of an uncaught exception: Call the callback that was passed to\n            // `postTask` with the error, or emit an 'error' event if there is none.\n            const taskInfos = [...workerInfo.taskInfos.values()];\n            workerInfo.taskInfos.clear();\n            // Remove the worker from the list and potentially start a new Worker to\n            // replace the current one.\n            this._removeWorker(workerInfo);\n            if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n                this._ensureMinimumWorkers();\n            }\n            else {\n                // Do not start new workers over and over if they already fail during\n                // bootstrap, there's no point.\n                this.workerFailsDuringBootstrap = true;\n            }\n            if (taskInfos.length > 0) {\n                for (const taskInfo of taskInfos) {\n                    taskInfo.done(err, null);\n                }\n            }\n            else {\n                this.publicInterface.emit('error', err);\n            }\n        });\n        worker.unref();\n        port1.on('close', () => {\n            // The port is only closed if the Worker stops for some reason, but we\n            // always .unref() the Worker itself. We want to receive e.g. 'error'\n            // events on it, so we ref it once we know it's going to exit anyway.\n            worker.ref();\n        });\n        this.workers.add(workerInfo);\n    }\n    _processPendingMessages() {\n        if (this.inProcessPendingMessages || !this.options.useAtomics) {\n            return;\n        }\n        this.inProcessPendingMessages = true;\n        try {\n            for (const workerInfo of this.workers) {\n                workerInfo.processPendingMessages();\n            }\n        }\n        finally {\n            this.inProcessPendingMessages = false;\n        }\n    }\n    _removeWorker(workerInfo) {\n        workerInfo.destroy();\n        this.workers.delete(workerInfo);\n    }\n    _onWorkerAvailable(workerInfo) {\n        while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) &&\n            workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n            // The skipQueue will have tasks that we previously shifted off\n            // the task queue but had to skip over... we have to make sure\n            // we drain that before we drain the taskQueue.\n            const taskInfo = this.skipQueue.shift() ||\n                this.taskQueue.shift();\n            // If the task has an abortSignal and the worker has any other\n            // tasks, we cannot distribute the task to it. Skip for now.\n            if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n                this.skipQueue.push(taskInfo);\n                break;\n            }\n            const now = perf_hooks_1.performance.now();\n            this.waitTime.recordValue(now - taskInfo.created);\n            taskInfo.started = now;\n            workerInfo.postTask(taskInfo);\n            this._maybeDrain();\n            return;\n        }\n        if (workerInfo.taskInfos.size === 0 &&\n            this.workers.size > this.options.minThreads) {\n            workerInfo.idleTimeout = setTimeout(() => {\n                assert_1.default.strictEqual(workerInfo.taskInfos.size, 0);\n                if (this.workers.size > this.options.minThreads) {\n                    this._removeWorker(workerInfo);\n                }\n            }, this.options.idleTimeout).unref();\n        }\n    }\n    runTask(task, options) {\n        let { filename, name } = options;\n        const { transferList = [], signal = null } = options;\n        if (filename == null) {\n            filename = this.options.filename;\n        }\n        if (name == null) {\n            name = this.options.name;\n        }\n        if (typeof filename !== 'string') {\n            return Promise.reject(Errors.FilenameNotProvided());\n        }\n        filename = maybeFileURLToPath(filename);\n        let resolve;\n        let reject;\n        // eslint-disable-next-line\n        const ret = new Promise((res, rej) => { resolve = res; reject = rej; });\n        const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {\n            this.completed++;\n            if (taskInfo.started) {\n                this.runTime.recordValue(perf_hooks_1.performance.now() - taskInfo.started);\n            }\n            if (err !== null) {\n                reject(err);\n            }\n            else {\n                resolve(result);\n            }\n        }, signal, this.publicInterface.asyncResource.asyncId());\n        if (signal !== null) {\n            // If the AbortSignal has an aborted property and it's truthy,\n            // reject immediately.\n            if (signal.aborted) {\n                return Promise.reject(new AbortError());\n            }\n            taskInfo.abortListener = () => {\n                // Call reject() first to make sure we always reject with the AbortError\n                // if the task is aborted, not with an Error from the possible\n                // thread termination below.\n                reject(new AbortError());\n                if (taskInfo.workerInfo !== null) {\n                    // Already running: We cancel the Worker this is running on.\n                    this._removeWorker(taskInfo.workerInfo);\n                    this._ensureMinimumWorkers();\n                }\n                else {\n                    // Not yet running: Remove it from the queue.\n                    this.taskQueue.remove(taskInfo);\n                }\n            };\n            onabort(signal, taskInfo.abortListener);\n        }\n        // If there is a task queue, there's no point in looking for an available\n        // Worker thread. Add this task to the queue, if possible.\n        if (this.taskQueue.size > 0) {\n            const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n            if (this.taskQueue.size >= totalCapacity) {\n                if (this.options.maxQueue === 0) {\n                    return Promise.reject(Errors.NoTaskQueueAvailable());\n                }\n                else {\n                    return Promise.reject(Errors.TaskQueueAtLimit());\n                }\n            }\n            else {\n                if (this.workers.size < this.options.maxThreads) {\n                    this._addNewWorker();\n                }\n                this.taskQueue.push(taskInfo);\n            }\n            return ret;\n        }\n        // Look for a Worker with a minimum number of tasks it is currently running.\n        let workerInfo = this.workers.findAvailable();\n        // If we want the ability to abort this task, use only workers that have\n        // no running tasks.\n        if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n            workerInfo = null;\n        }\n        // If no Worker was found, or that Worker was handling another task in some\n        // way, and we still have the ability to spawn new threads, do so.\n        let waitingForNewWorker = false;\n        if ((workerInfo === null || workerInfo.currentUsage() > 0) &&\n            this.workers.size < this.options.maxThreads) {\n            this._addNewWorker();\n            waitingForNewWorker = true;\n        }\n        // If no Worker is found, try to put the task into the queue.\n        if (workerInfo === null) {\n            if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n                return Promise.reject(Errors.NoTaskQueueAvailable());\n            }\n            else {\n                this.taskQueue.push(taskInfo);\n            }\n            return ret;\n        }\n        // TODO(addaleax): Clean up the waitTime/runTime recording.\n        const now = perf_hooks_1.performance.now();\n        this.waitTime.recordValue(now - taskInfo.created);\n        taskInfo.started = now;\n        workerInfo.postTask(taskInfo);\n        this._maybeDrain();\n        return ret;\n    }\n    pendingCapacity() {\n        return this.workers.pendingItems.size *\n            this.options.concurrentTasksPerWorker;\n    }\n    _maybeDrain() {\n        if (this.taskQueue.size === 0 && this.skipQueue.length === 0) {\n            this.publicInterface.emit('drain');\n        }\n    }\n    async destroy() {\n        while (this.skipQueue.length > 0) {\n            const taskInfo = this.skipQueue.shift();\n            taskInfo.done(new Error('Terminating worker thread'));\n        }\n        while (this.taskQueue.size > 0) {\n            const taskInfo = this.taskQueue.shift();\n            taskInfo.done(new Error('Terminating worker thread'));\n        }\n        const exitEvents = [];\n        while (this.workers.size > 0) {\n            const [workerInfo] = this.workers;\n            exitEvents.push(events_1.once(workerInfo.worker, 'exit'));\n            this._removeWorker(workerInfo);\n        }\n        await Promise.all(exitEvents);\n    }\n}\nclass Piscina extends eventemitter_asyncresource_1.default {\n    constructor(options = {}) {\n        super({ ...options, name: 'Piscina' });\n        _Piscina_pool.set(this, void 0);\n        if (typeof options.filename !== 'string' && options.filename != null) {\n            throw new TypeError('options.filename must be a string or null');\n        }\n        if (typeof options.name !== 'string' && options.name != null) {\n            throw new TypeError('options.name must be a string or null');\n        }\n        if (options.minThreads !== undefined &&\n            (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n            throw new TypeError('options.minThreads must be a non-negative integer');\n        }\n        if (options.maxThreads !== undefined &&\n            (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n            throw new TypeError('options.maxThreads must be a positive integer');\n        }\n        if (options.minThreads !== undefined && options.maxThreads !== undefined &&\n            options.minThreads > options.maxThreads) {\n            throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n        }\n        if (options.idleTimeout !== undefined &&\n            (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n            throw new TypeError('options.idleTimeout must be a non-negative integer');\n        }\n        if (options.maxQueue !== undefined &&\n            options.maxQueue !== 'auto' &&\n            (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n            throw new TypeError('options.maxQueue must be a non-negative integer');\n        }\n        if (options.concurrentTasksPerWorker !== undefined &&\n            (typeof options.concurrentTasksPerWorker !== 'number' ||\n                options.concurrentTasksPerWorker < 1)) {\n            throw new TypeError('options.concurrentTasksPerWorker must be a positive integer');\n        }\n        if (options.useAtomics !== undefined &&\n            typeof options.useAtomics !== 'boolean') {\n            throw new TypeError('options.useAtomics must be a boolean value');\n        }\n        if (options.resourceLimits !== undefined &&\n            (typeof options.resourceLimits !== 'object' ||\n                options.resourceLimits === null)) {\n            throw new TypeError('options.resourceLimits must be an object');\n        }\n        if (options.taskQueue !== undefined && !common_1.isTaskQueue(options.taskQueue)) {\n            throw new TypeError('options.taskQueue must be a TaskQueue object');\n        }\n        if (options.niceIncrement !== undefined &&\n            (typeof options.niceIncrement !== 'number' || options.niceIncrement < 0)) {\n            throw new TypeError('options.niceIncrement must be a non-negative integer');\n        }\n        if (options.trackUnmanagedFds !== undefined &&\n            typeof options.trackUnmanagedFds !== 'boolean') {\n            throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n        }\n        __classPrivateFieldSet(this, _Piscina_pool, new ThreadPool(this, options), \"f\");\n    }\n    /** @deprecated Use run(task, options) instead **/\n    runTask(task, transferList, filename, signal) {\n        // If transferList is a string or AbortSignal, shift it.\n        if ((typeof transferList === 'object' && !Array.isArray(transferList)) ||\n            typeof transferList === 'string') {\n            signal = filename;\n            filename = transferList;\n            transferList = undefined;\n        }\n        // If filename is an AbortSignal, shift it.\n        if (typeof filename === 'object' && !Array.isArray(filename)) {\n            signal = filename;\n            filename = undefined;\n        }\n        if (transferList !== undefined && !Array.isArray(transferList)) {\n            return Promise.reject(new TypeError('transferList argument must be an Array'));\n        }\n        if (filename !== undefined && typeof filename !== 'string') {\n            return Promise.reject(new TypeError('filename argument must be a string'));\n        }\n        if (signal !== undefined && typeof signal !== 'object') {\n            return Promise.reject(new TypeError('signal argument must be an object'));\n        }\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n            transferList,\n            filename: filename || null,\n            name: 'default',\n            signal: signal || null\n        });\n    }\n    run(task, options = kDefaultRunOptions) {\n        if (options === null || typeof options !== 'object') {\n            return Promise.reject(new TypeError('options must be an object'));\n        }\n        const { transferList, filename, name, signal } = options;\n        if (transferList !== undefined && !Array.isArray(transferList)) {\n            return Promise.reject(new TypeError('transferList argument must be an Array'));\n        }\n        if (filename != null && typeof filename !== 'string') {\n            return Promise.reject(new TypeError('filename argument must be a string'));\n        }\n        if (name != null && typeof name !== 'string') {\n            return Promise.reject(new TypeError('name argument must be a string'));\n        }\n        if (signal != null && typeof signal !== 'object') {\n            return Promise.reject(new TypeError('signal argument must be an object'));\n        }\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, { transferList, filename, name, signal });\n    }\n    destroy() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").destroy();\n    }\n    get options() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").options;\n    }\n    get threads() {\n        const ret = [];\n        for (const workerInfo of __classPrivateFieldGet(this, _Piscina_pool, \"f\").workers) {\n            ret.push(workerInfo.worker);\n        }\n        return ret;\n    }\n    get queueSize() {\n        const pool = __classPrivateFieldGet(this, _Piscina_pool, \"f\");\n        return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n    }\n    get completed() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").completed;\n    }\n    get waitTime() {\n        const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime);\n        return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime, result);\n    }\n    get runTime() {\n        const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime);\n        return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime, result);\n    }\n    get utilization() {\n        // The capacity is the max compute time capacity of the\n        // pool to this point in time as determined by the length\n        // of time the pool has been running multiplied by the\n        // maximum number of threads.\n        const capacity = this.duration * __classPrivateFieldGet(this, _Piscina_pool, \"f\").options.maxThreads;\n        const totalMeanRuntime = __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.mean *\n            __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.totalCount;\n        // We calculate the appoximate pool utilization by multiplying\n        // the mean run time of all tasks by the number of runtime\n        // samples taken and dividing that by the capacity. The\n        // theory here is that capacity represents the absolute upper\n        // limit of compute time this pool could ever attain (but\n        // never will for a variety of reasons. Multiplying the\n        // mean run time by the number of tasks sampled yields an\n        // approximation of the realized compute time. The utilization\n        // then becomes a point-in-time measure of how active the\n        // pool is.\n        return totalMeanRuntime / capacity;\n    }\n    get duration() {\n        return perf_hooks_1.performance.now() - __classPrivateFieldGet(this, _Piscina_pool, \"f\").start;\n    }\n    static get isWorkerThread() {\n        return common_1.commonState.isWorkerThread;\n    }\n    static get workerData() {\n        return common_1.commonState.workerData;\n    }\n    static get version() {\n        return package_json_1.version;\n    }\n    static get Piscina() {\n        return Piscina;\n    }\n    static move(val) {\n        if (val != null && typeof val === 'object' && typeof val !== 'function') {\n            if (!common_1.isTransferable(val)) {\n                if (util_1.types.isArrayBufferView(val)) {\n                    val = new ArrayBufferViewTransferable(val);\n                }\n                else {\n                    val = new DirectlyTransferable(val);\n                }\n            }\n            common_1.markMovable(val);\n        }\n        return val;\n    }\n    static get transferableSymbol() { return common_1.kTransferable; }\n    static get valueSymbol() { return common_1.kValue; }\n    static get queueOptionsSymbol() { return common_1.kQueueOptions; }\n}\n_Piscina_pool = new WeakMap();\nmodule.exports = Piscina;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}